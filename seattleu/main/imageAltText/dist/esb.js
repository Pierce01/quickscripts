var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value2) {
      return value2 && typeof value2.length === "number" && value2.length >= 0 && value2.length % 1 === 0;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i2 = -1;
      var len = coll.length;
      return function next() {
        return ++i2 < len ? { value: coll[i2], key: i2 } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i2 = -1;
      return function next() {
        var item2 = iterator.next();
        if (item2.done)
          return null;
        i2++;
        return { value: item2.value, key: i2 };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i2 = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i2];
        if (key === "__proto__") {
          return next();
        }
        return i2 < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function") {
          return handlePromise(result, callback);
        } else {
          callback(null, result);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value2) => {
        invokeCallback(callback, null, value2);
      }, (err) => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error, value2) {
      try {
        callback(error, value2);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value: value2, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value2, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value2) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value2 === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value2, index, callback) => iteratee(value2, callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity = asyncFn.length) {
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve5, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve5(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS({
  "node_modules/async/eachLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 4);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS({
  "node_modules/async/eachSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachLimit = require_eachLimit();
    var _eachLimit2 = _interopRequireDefault(_eachLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachSeries(coll, iteratee, callback) {
      return (0, _eachLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachSeries, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/filter.js
var require_filter = __commonJS({
  "node_modules/async/internal/filter.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _filter;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = new Array(arr.length);
      eachfn(arr, (x, index, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index] = !!v;
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i2 = 0; i2 < arr.length; i2++) {
          if (truthValues[i2])
            results.push(arr[i2]);
        }
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v) {
            results.push({ index, value: x });
          }
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter = (0, _isArrayLike2.default)(coll) ? filterArray : filterGeneric;
      return filter(eachfn, coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/internal/reject.js
var require_reject = __commonJS({
  "node_modules/async/internal/reject.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = reject2;
    var _filter = require_filter();
    var _filter2 = _interopRequireDefault(_filter);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function reject2(eachfn, arr, _iteratee, callback) {
      const iteratee = (0, _wrapAsync2.default)(_iteratee);
      return (0, _filter2.default)(eachfn, arr, (value2, cb) => {
        iteratee(value2, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/async/rejectSeries.js
var require_rejectSeries = __commonJS({
  "node_modules/async/rejectSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _reject2 = require_reject();
    var _reject3 = _interopRequireDefault(_reject2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rejectSeries(coll, iteratee, callback) {
      return (0, _reject3.default)(_eachOfSeries2.default, coll, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(rejectSeries, 3);
    module2.exports = exports2["default"];
  }
});

// node_modules/mute-stream/mute.js
var require_mute = __commonJS({
  "node_modules/mute-stream/mute.js"(exports2, module2) {
    var Stream = require("stream");
    module2.exports = MuteStream;
    function MuteStream(opts) {
      Stream.apply(this);
      opts = opts || {};
      this.writable = this.readable = true;
      this.muted = false;
      this.on("pipe", this._onpipe);
      this.replace = opts.replace;
      this._prompt = opts.prompt || null;
      this._hadControl = false;
    }
    MuteStream.prototype = Object.create(Stream.prototype);
    Object.defineProperty(MuteStream.prototype, "constructor", {
      value: MuteStream,
      enumerable: false
    });
    MuteStream.prototype.mute = function() {
      this.muted = true;
    };
    MuteStream.prototype.unmute = function() {
      this.muted = false;
    };
    Object.defineProperty(MuteStream.prototype, "_onpipe", {
      value: onPipe,
      enumerable: false,
      writable: true,
      configurable: true
    });
    function onPipe(src) {
      this._src = src;
    }
    Object.defineProperty(MuteStream.prototype, "isTTY", {
      get: getIsTTY,
      set: setIsTTY,
      enumerable: true,
      configurable: true
    });
    function getIsTTY() {
      return this._dest ? this._dest.isTTY : this._src ? this._src.isTTY : false;
    }
    function setIsTTY(isTTY) {
      Object.defineProperty(this, "isTTY", {
        value: isTTY,
        enumerable: true,
        writable: true,
        configurable: true
      });
    }
    Object.defineProperty(MuteStream.prototype, "rows", {
      get: function() {
        return this._dest ? this._dest.rows : this._src ? this._src.rows : void 0;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(MuteStream.prototype, "columns", {
      get: function() {
        return this._dest ? this._dest.columns : this._src ? this._src.columns : void 0;
      },
      enumerable: true,
      configurable: true
    });
    MuteStream.prototype.pipe = function(dest, options) {
      this._dest = dest;
      return Stream.prototype.pipe.call(this, dest, options);
    };
    MuteStream.prototype.pause = function() {
      if (this._src)
        return this._src.pause();
    };
    MuteStream.prototype.resume = function() {
      if (this._src)
        return this._src.resume();
    };
    MuteStream.prototype.write = function(c) {
      if (this.muted) {
        if (!this.replace)
          return true;
        if (c.match(/^\u001b/)) {
          if (c.indexOf(this._prompt) === 0) {
            c = c.substr(this._prompt.length);
            c = c.replace(/./g, this.replace);
            c = this._prompt + c;
          }
          this._hadControl = true;
          return this.emit("data", c);
        } else {
          if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
            this._hadControl = false;
            this.emit("data", this._prompt);
            c = c.substr(this._prompt.length);
          }
          c = c.toString().replace(/./g, this.replace);
        }
      }
      this.emit("data", c);
    };
    MuteStream.prototype.end = function(c) {
      if (this.muted) {
        if (c && this.replace) {
          c = c.toString().replace(/./g, this.replace);
        } else {
          c = null;
        }
      }
      if (c)
        this.emit("data", c);
      this.emit("end");
    };
    function proxy(fn) {
      return function() {
        var d = this._dest;
        var s = this._src;
        if (d && d[fn])
          d[fn].apply(d, arguments);
        if (s && s[fn])
          s[fn].apply(s, arguments);
      };
    }
    MuteStream.prototype.destroy = proxy("destroy");
    MuteStream.prototype.destroySoon = proxy("destroySoon");
    MuteStream.prototype.close = proxy("close");
  }
});

// node_modules/read/lib/read.js
var require_read = __commonJS({
  "node_modules/read/lib/read.js"(exports2, module2) {
    module2.exports = read;
    var readline = require("readline");
    var Mute = require_mute();
    function read(opts, cb) {
      if (opts.num) {
        throw new Error("read() no longer accepts a char number limit");
      }
      if (typeof opts.default !== "undefined" && typeof opts.default !== "string" && typeof opts.default !== "number") {
        throw new Error("default value must be string or number");
      }
      var input = opts.input || process.stdin;
      var output = opts.output || process.stdout;
      var prompt2 = (opts.prompt || "").trim() + " ";
      var silent = opts.silent;
      var editDef = false;
      var timeout = opts.timeout;
      var def = opts.default || "";
      if (def) {
        if (silent) {
          prompt2 += "(<default hidden>) ";
        } else if (opts.edit) {
          editDef = true;
        } else {
          prompt2 += "(" + def + ") ";
        }
      }
      var terminal = !!(opts.terminal || output.isTTY);
      var m = new Mute({ replace: opts.replace, prompt: prompt2 });
      m.pipe(output, { end: false });
      output = m;
      var rlOpts = { input, output, terminal };
      if (process.version.match(/^v0\.6/)) {
        var rl = readline.createInterface(rlOpts.input, rlOpts.output);
      } else {
        var rl = readline.createInterface(rlOpts);
      }
      output.unmute();
      rl.setPrompt(prompt2);
      rl.prompt();
      if (silent) {
        output.mute();
      } else if (editDef) {
        rl.line = def;
        rl.cursor = def.length;
        rl._refreshLine();
      }
      var called = false;
      rl.on("line", onLine);
      rl.on("error", onError);
      rl.on("SIGINT", function() {
        rl.close();
        onError(new Error("canceled"));
      });
      var timer;
      if (timeout) {
        timer = setTimeout(function() {
          onError(new Error("timed out"));
        }, timeout);
      }
      function done() {
        called = true;
        rl.close();
        if (process.version.match(/^v0\.6/)) {
          rl.input.removeAllListeners("data");
          rl.input.removeAllListeners("keypress");
          rl.input.pause();
        }
        clearTimeout(timer);
        output.mute();
        output.end();
      }
      function onError(er) {
        if (called)
          return;
        done();
        return cb(er);
      }
      function onLine(line) {
        if (called)
          return;
        if (silent && terminal) {
          output.unmute();
          output.write("\r\n");
        }
        done();
        line = line.replace(/\r?\n$/, "");
        var isDefault = !!(editDef && line === def);
        if (def && !line) {
          isDefault = true;
          line = def;
        }
        cb(null, line, isDefault);
      }
    }
  }
});

// node_modules/revalidator/lib/revalidator.js
var require_revalidator = __commonJS({
  "node_modules/revalidator/lib/revalidator.js"(exports2, module2) {
    (function(exports3) {
      exports3.validate = validate;
      exports3.mixin = mixin;
      function validate(object, schema, options) {
        options = mixin({}, options, validate.defaults);
        var errors = [];
        validateObject(object, schema, options, errors);
        return {
          valid: !errors.length,
          errors
        };
      }
      ;
      validate.defaults = {
        /**
         * <p>
         * Enforce 'format' constraints.
         * </p><p>
         * <em>Default: <code>true</code></em>
         * </p>
         */
        validateFormats: true,
        /**
         * <p>
         * When {@link #validateFormats} is <code>true</code>,
         * treat unrecognized formats as validation errors.
         * </p><p>
         * <em>Default: <code>false</code></em>
         * </p>
         *
         * @see validation.formats for default supported formats.
         */
        validateFormatsStrict: false,
        /**
         * <p>
         * When {@link #validateFormats} is <code>true</code>,
         * also validate formats defined in {@link #validate.formatExtensions}.
         * </p><p>
         * <em>Default: <code>true</code></em>
         * </p>
         */
        validateFormatExtensions: true
      };
      validate.messages = {
        required: "is required",
        allowEmpty: "must not be empty",
        minLength: "is too short (minimum is %{expected} characters)",
        maxLength: "is too long (maximum is %{expected} characters)",
        pattern: "invalid input",
        minimum: "must be greater than or equal to %{expected}",
        maximum: "must be less than or equal to %{expected}",
        exclusiveMinimum: "must be greater than %{expected}",
        exclusiveMaximum: "must be less than %{expected}",
        divisibleBy: "must be divisible by %{expected}",
        minItems: "must contain more than %{expected} items",
        maxItems: "must contain less than %{expected} items",
        uniqueItems: "must hold a unique set of values",
        format: "is not a valid %{expected}",
        conform: "must conform to given constraint",
        type: "must be of %{expected} type"
      };
      validate.messages["enum"] = "must be present in given enumerator";
      validate.formats = {
        "email": /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
        "ip-address": /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/i,
        "ipv6": /^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$/,
        "date-time": /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:.\d{1,3})?Z$/,
        "date": /^\d{4}-\d{2}-\d{2}$/,
        "time": /^\d{2}:\d{2}:\d{2}$/,
        "color": /^#[a-z0-9]{6}|#[a-z0-9]{3}|(?:rgb\(\s*(?:[+-]?\d+%?)\s*,\s*(?:[+-]?\d+%?)\s*,\s*(?:[+-]?\d+%?)\s*\))aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow$/i,
        //'style':        (not supported)
        //'phone':        (not supported)
        //'uri':          (not supported)
        "host-name": /^(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])/,
        "utc-millisec": {
          test: function(value2) {
            return typeof value2 === "number" && value2 >= 0;
          }
        },
        "regex": {
          test: function(value2) {
            try {
              new RegExp(value2);
            } catch (e) {
              return false;
            }
            return true;
          }
        }
      };
      validate.formatExtensions = {
        "url": /^(https?|ftp|git):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
      };
      function mixin(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError("mixin non-object");
          }
          for (var p in source) {
            if (source.hasOwnProperty(p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      }
      ;
      function validateObject(object, schema, options, errors) {
        var props, allProps = Object.keys(object), visitedProps = [];
        if (schema.properties) {
          props = schema.properties;
          for (var p in props) {
            if (props.hasOwnProperty(p)) {
              visitedProps.push(p);
              validateProperty(object, object[p], p, props[p], options, errors);
            }
          }
        }
        if (schema.patternProperties) {
          props = schema.patternProperties;
          for (var p in props) {
            if (props.hasOwnProperty(p)) {
              var re = new RegExp(p);
              for (var k in object) {
                if (object.hasOwnProperty(k)) {
                  visitedProps.push(k);
                  if (re.exec(k) !== null) {
                    validateProperty(object, object[k], p, props[p], options, errors);
                  }
                }
              }
            }
          }
        }
        if (void 0 !== schema.additionalProperties) {
          var i2, l;
          var unvisitedProps = allProps.filter(function(k2) {
            return -1 === visitedProps.indexOf(k2);
          });
          if (schema.additionalProperties === false && unvisitedProps.length > 0) {
            for (i2 = 0, l = unvisitedProps.length; i2 < l; i2++) {
              error("additionalProperties", unvisitedProps[i2], object[unvisitedProps[i2]], false, errors);
            }
          } else if (typeof schema.additionalProperties == "object" && unvisitedProps.length > 0) {
            for (i2 = 0, l = unvisitedProps.length; i2 < l; i2++) {
              validateProperty(object, object[unvisitedProps[i2]], unvisitedProps[i2], schema.unvisitedProperties, options, errors);
            }
          }
        }
      }
      ;
      function validateProperty(object, value2, property, schema, options, errors) {
        var format, valid, spec, type;
        function constrain(name2, value3, assert) {
          if (schema[name2] !== void 0 && !assert(value3, schema[name2])) {
            error(name2, property, value3, schema, errors);
          }
        }
        if (value2 === void 0) {
          if (schema.required && schema.type !== "any") {
            return error("required", property, void 0, schema, errors);
          } else {
            return;
          }
        }
        if (options.cast) {
          if (("integer" === schema.type || "number" === schema.type) && value2 == +value2) {
            value2 = +value2;
            object[property] = value2;
          }
          if ("boolean" === schema.type) {
            if ("true" === value2 || "1" === value2 || 1 === value2) {
              value2 = true;
              object[property] = value2;
            }
            if ("false" === value2 || "0" === value2 || 0 === value2) {
              value2 = false;
              object[property] = value2;
            }
          }
        }
        if (schema.format && options.validateFormats) {
          format = schema.format;
          if (options.validateFormatExtensions) {
            spec = validate.formatExtensions[format];
          }
          if (!spec) {
            spec = validate.formats[format];
          }
          if (!spec) {
            if (options.validateFormatsStrict) {
              return error("format", property, value2, schema, errors);
            }
          } else {
            if (!spec.test(value2)) {
              return error("format", property, value2, schema, errors);
            }
          }
        }
        if (schema["enum"] && schema["enum"].indexOf(value2) === -1) {
          error("enum", property, value2, schema, errors);
        }
        if (typeof schema.dependencies === "string" && object[schema.dependencies] === void 0) {
          error("dependencies", property, null, schema, errors);
        }
        if (isArray(schema.dependencies)) {
          for (var i2 = 0, l = schema.dependencies.length; i2 < l; i2++) {
            if (object[schema.dependencies[i2]] === void 0) {
              error("dependencies", property, null, schema, errors);
            }
          }
        }
        if (typeof schema.dependencies === "object") {
          validateObject(object, schema.dependencies, options, errors);
        }
        checkType(value2, schema.type, function(err, type2) {
          if (err)
            return error("type", property, typeof value2, schema, errors);
          constrain("conform", value2, function(a, e) {
            return e(a, object);
          });
          switch (type2 || (isArray(value2) ? "array" : typeof value2)) {
            case "string":
              constrain("allowEmpty", value2, function(a, e) {
                return e ? e : a !== "";
              });
              constrain("minLength", value2.length, function(a, e) {
                return a >= e;
              });
              constrain("maxLength", value2.length, function(a, e) {
                return a <= e;
              });
              constrain("pattern", value2, function(a, e) {
                e = typeof e === "string" ? e = new RegExp(e) : e;
                return e.test(a);
              });
              break;
            case "integer":
            case "number":
              constrain("minimum", value2, function(a, e) {
                return a >= e;
              });
              constrain("maximum", value2, function(a, e) {
                return a <= e;
              });
              constrain("exclusiveMinimum", value2, function(a, e) {
                return a > e;
              });
              constrain("exclusiveMaximum", value2, function(a, e) {
                return a < e;
              });
              constrain("divisibleBy", value2, function(a, e) {
                var multiplier = Math.max((a - Math.floor(a)).toString().length - 2, (e - Math.floor(e)).toString().length - 2);
                multiplier = multiplier > 0 ? Math.pow(10, multiplier) : 1;
                return a * multiplier % (e * multiplier) === 0;
              });
              break;
            case "array":
              constrain("items", value2, function(a, e) {
                for (var i3 = 0, l2 = a.length; i3 < l2; i3++) {
                  validateProperty(object, a[i3], property, e, options, errors);
                }
                return true;
              });
              constrain("minItems", value2, function(a, e) {
                return a.length >= e;
              });
              constrain("maxItems", value2, function(a, e) {
                return a.length <= e;
              });
              constrain("uniqueItems", value2, function(a) {
                var h = {};
                for (var i3 = 0, l2 = a.length; i3 < l2; i3++) {
                  var key = JSON.stringify(a[i3]);
                  if (h[key])
                    return false;
                  h[key] = true;
                }
                return true;
              });
              break;
            case "object":
              if (schema.properties || schema.patternProperties || schema.additionalProperties) {
                validateObject(value2, schema, options, errors);
              }
              break;
          }
        });
      }
      ;
      function checkType(val, type, callback) {
        var result = false, types = isArray(type) ? type : [type];
        if (type === void 0)
          return callback(null, type);
        for (var i2 = 0, l = types.length; i2 < l; i2++) {
          type = types[i2].toLowerCase().trim();
          if (type === "string" ? typeof val === "string" : type === "array" ? isArray(val) : type === "object" ? val && typeof val === "object" && !isArray(val) : type === "number" ? typeof val === "number" : type === "integer" ? typeof val === "number" && ~~val === val : type === "null" ? val === null : type === "boolean" ? typeof val === "boolean" : type === "date" ? isDate(val) : type === "any" ? typeof val !== "undefined" : false) {
            return callback(null, type);
          }
        }
        ;
        callback(true);
      }
      ;
      function error(attribute, property, actual, schema, errors) {
        var lookup = { expected: schema[attribute], actual, attribute, property };
        var message = schema.messages && schema.messages[attribute] || schema.message || validate.messages[attribute] || "no default message";
        message = message.replace(/%\{([a-z]+)\}/ig, function(_, match) {
          return lookup[match.toLowerCase()] || "";
        });
        errors.push({
          attribute,
          property,
          expected: schema[attribute],
          actual,
          message
        });
      }
      ;
      function isArray(value2) {
        var s = typeof value2;
        if (s === "object") {
          if (value2) {
            if (typeof value2.length === "number" && !value2.propertyIsEnumerable("length") && typeof value2.splice === "function") {
              return true;
            }
          }
        }
        return false;
      }
      function isDate(value2) {
        var s = typeof value2;
        if (s === "object") {
          if (value2) {
            if (typeof value2.getTime === "function") {
              return true;
            }
          }
        }
        return false;
      }
    })(typeof module2 === "object" && module2 && module2.exports ? module2.exports : window);
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A multi-transport async logging library for Node.js",
      version: "2.4.7",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "Jarrett Cruger <jcrugzz@gmail.com>",
        "Alberto Pose <albertopose@gmail.com>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logging",
        "sysadmin",
        "tools"
      ],
      dependencies: {
        async: "^2.6.4",
        colors: "1.0.x",
        cycle: "1.0.x",
        eyes: "0.1.x",
        isstream: "0.1.x",
        "stack-trace": "0.0.x"
      },
      devDependencies: {
        "cross-spawn-async": "^2.0.0",
        hock: "1.x.x",
        "std-mocks": "~1.0.0",
        vows: "0.7.x"
      },
      main: "./lib/winston",
      scripts: {
        test: "vows --dot-matrix --isolate"
      },
      types: "./index.d.ts",
      engines: {
        node: ">= 0.10.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/cycle/cycle.js
var require_cycle = __commonJS({
  "node_modules/cycle/cycle.js"(exports, module) {
    var cycle = exports;
    cycle.decycle = function decycle(object) {
      "use strict";
      var objects = [], paths = [];
      return function derez(value2, path4) {
        var i2, name2, nu;
        if (typeof value2 === "object" && value2 !== null && !(value2 instanceof Boolean) && !(value2 instanceof Date) && !(value2 instanceof Number) && !(value2 instanceof RegExp) && !(value2 instanceof String)) {
          for (i2 = 0; i2 < objects.length; i2 += 1) {
            if (objects[i2] === value2) {
              return { $ref: paths[i2] };
            }
          }
          objects.push(value2);
          paths.push(path4);
          if (Object.prototype.toString.apply(value2) === "[object Array]") {
            nu = [];
            for (i2 = 0; i2 < value2.length; i2 += 1) {
              nu[i2] = derez(value2[i2], path4 + "[" + i2 + "]");
            }
          } else {
            nu = {};
            for (name2 in value2) {
              if (Object.prototype.hasOwnProperty.call(value2, name2)) {
                nu[name2] = derez(
                  value2[name2],
                  path4 + "[" + JSON.stringify(name2) + "]"
                );
              }
            }
          }
          return nu;
        }
        return value2;
      }(object, "$");
    };
    cycle.retrocycle = function retrocycle($) {
      "use strict";
      var px = /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;
      (function rez(value) {
        var i, item, name, path;
        if (value && typeof value === "object") {
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            for (i = 0; i < value.length; i += 1) {
              item = value[i];
              if (item && typeof item === "object") {
                path = item.$ref;
                if (typeof path === "string" && px.test(path)) {
                  value[i] = eval(path);
                } else {
                  rez(item);
                }
              }
            }
          } else {
            for (name in value) {
              if (typeof value[name] === "object") {
                item = value[name];
                if (item) {
                  path = item.$ref;
                  if (typeof path === "string" && px.test(path)) {
                    value[name] = eval(path);
                  } else {
                    rez(item);
                  }
                }
              }
            }
          }
        }
      })($);
      return $;
    };
  }
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/colors/lib/system/supports-colors.js"(exports2, module2) {
    var argv = process.argv;
    module2.exports = function() {
      if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
        return false;
      }
      if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function is_char(character) {
        var bool = false;
        all.filter(function(i2) {
          bool = i2 === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "", counts, l;
        options2 = options2 || {};
        options2["up"] = options2["up"] || true;
        options2["mid"] = options2["mid"] || true;
        options2["down"] = options2["down"] || true;
        options2["size"] = options2["size"] || "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (is_char(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.min = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.min = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i2 = 0; i2 <= counts[index]; i2++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text);
    };
  }
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/colors/lib/maps/america.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      return function(letter, i2, exploded) {
        if (letter === " ")
          return letter;
        switch (i2 % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/colors/lib/maps/zebra.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function(letter, i2, exploded) {
      return i2 % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/colors/lib/maps/rainbow.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i2, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i2++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/colors/lib/maps/random.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
      return function(letter, i2, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    }();
  }
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    colors.supportsColor = require_supports_colors();
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      return ansiStyles[style].open + str + ansiStyles[style].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!colors.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i2 = nestedStyles.length;
      while (i2--) {
        var code = ansiStyles[nestedStyles[i2]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      return str;
    }
    function applyTheme(theme) {
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            return colors[theme[style2]](str);
          };
        })(style);
      }
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split(""), i2 = 0;
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/winston/lib/winston/config/cli-config.js
var require_cli_config = __commonJS({
  "node_modules/winston/lib/winston/config/cli-config.js"(exports2) {
    var cliConfig = exports2;
    cliConfig.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    cliConfig.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/winston/lib/winston/config/npm-config.js
var require_npm_config = __commonJS({
  "node_modules/winston/lib/winston/config/npm-config.js"(exports2) {
    var npmConfig = exports2;
    npmConfig.levels = {
      error: 0,
      warn: 1,
      info: 2,
      verbose: 3,
      debug: 4,
      silly: 5
    };
    npmConfig.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/winston/lib/winston/config/syslog-config.js
var require_syslog_config = __commonJS({
  "node_modules/winston/lib/winston/config/syslog-config.js"(exports2) {
    var syslogConfig = exports2;
    syslogConfig.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    syslogConfig.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/winston/lib/winston/config.js
var require_config = __commonJS({
  "node_modules/winston/lib/winston/config.js"(exports2) {
    var colors = require_safe();
    colors.enabled = true;
    var config = exports2;
    var allColors = exports2.allColors = {};
    config.addColors = function(colors2) {
      mixin(allColors, colors2);
    };
    config.colorize = function(level, message) {
      if (typeof message === "undefined")
        message = level;
      var colorized = message;
      if (allColors[level] instanceof Array) {
        for (var i2 = 0, l = allColors[level].length; i2 < l; ++i2) {
          colorized = colors[allColors[level][i2]](colorized);
        }
      } else if (allColors[level].match(/\s/)) {
        var colorArr = allColors[level].split(/\s+/);
        for (var i2 = 0; i2 < colorArr.length; ++i2) {
          colorized = colors[colorArr[i2]](colorized);
        }
        allColors[level] = colorArr;
      } else {
        colorized = colors[allColors[level]](colorized);
      }
      return colorized;
    };
    config.cli = require_cli_config();
    config.npm = require_npm_config();
    config.syslog = require_syslog_config();
    config.addColors(config.cli.colors);
    config.addColors(config.npm.colors);
    config.addColors(config.syslog.colors);
    function mixin(target) {
      var args = Array.prototype.slice.call(arguments, 1);
      args.forEach(function(a) {
        var keys = Object.keys(a);
        for (var i2 = 0; i2 < keys.length; i2++) {
          target[keys[i2]] = a[keys[i2]];
        }
      });
      return target;
    }
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports2) {
    var util = require("util");
    var crypto = require("crypto");
    var cycle2 = require_cycle();
    var fs = require("fs");
    var StringDecoder = require("string_decoder").StringDecoder;
    var Stream = require("stream").Stream;
    var config = require_config();
    exports2.setLevels = function(target, past, current, isDefault) {
      var self2 = this;
      if (past) {
        Object.keys(past).forEach(function(level) {
          delete target[level];
        });
      }
      target.levels = current || config.npm.levels;
      if (target.padLevels) {
        target.levelLength = exports2.longestElement(Object.keys(target.levels));
      }
      Object.keys(target.levels).forEach(function(level) {
        if (level === "log") {
          console.warn('Log level named "log" will clash with the method "log". Consider using a different name.');
          return;
        }
        target[level] = function(msg) {
          var args = [level].concat(Array.prototype.slice.call(arguments));
          target.log.apply(target, args);
        };
      });
      return target;
    };
    exports2.longestElement = function(xs) {
      return Math.max.apply(
        null,
        xs.map(function(x) {
          return x.length;
        })
      );
    };
    exports2.clone = function(obj) {
      if (obj instanceof Error) {
        var copy = { message: obj.message };
        Object.getOwnPropertyNames(obj).forEach(function(key) {
          copy[key] = obj[key];
        });
        return cycle2.decycle(copy);
      } else if (!(obj instanceof Object)) {
        return obj;
      } else if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      return clone(cycle2.decycle(obj));
    };
    function clone(obj) {
      var copy = Array.isArray(obj) ? [] : {};
      for (var i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          if (Array.isArray(obj[i2])) {
            copy[i2] = obj[i2].slice(0);
          } else if (obj[i2] instanceof Buffer) {
            copy[i2] = obj[i2].slice(0);
          } else if (typeof obj[i2] != "function") {
            copy[i2] = obj[i2] instanceof Object ? exports2.clone(obj[i2]) : obj[i2];
          } else if (typeof obj[i2] === "function") {
            copy[i2] = obj[i2];
          }
        }
      }
      return copy;
    }
    exports2.log = function(options) {
      var timestampFn = typeof options.timestamp === "function" ? options.timestamp : exports2.timestamp, timestamp = options.timestamp ? timestampFn() : null, showLevel = options.showLevel === void 0 ? true : options.showLevel, meta = options.meta !== null && options.meta !== void 0 ? exports2.clone(options.meta) : options.meta || null, output;
      if (options.raw) {
        if (typeof meta !== "object" && meta != null) {
          meta = { meta };
        }
        output = exports2.clone(meta) || {};
        output.level = options.level;
        output.message = options.message.stripColors ? options.message.stripColors : options.message;
        return JSON.stringify(output);
      }
      if (options.json || true === options.logstash) {
        if (typeof meta !== "object" && meta != null) {
          meta = { meta };
        }
        output = exports2.clone(meta) || {};
        output.level = options.level;
        output.message = output.message || "";
        if (options.label) {
          output.label = options.label;
        }
        if (options.message) {
          output.message = options.message;
        }
        if (timestamp) {
          output.timestamp = timestamp;
        }
        if (options.logstash === true) {
          var logstashOutput = {};
          if (output.message !== void 0) {
            logstashOutput["@message"] = output.message;
            delete output.message;
          }
          if (output.timestamp !== void 0) {
            logstashOutput["@timestamp"] = output.timestamp;
            delete output.timestamp;
          }
          logstashOutput["@fields"] = exports2.clone(output);
          output = logstashOutput;
        }
        if (typeof options.stringify === "function") {
          return options.stringify(output);
        }
        return JSON.stringify(output, function(key, value2) {
          return value2 instanceof Buffer ? value2.toString("base64") : value2;
        });
      }
      if (typeof options.formatter == "function") {
        options.meta = meta || options.meta;
        if (options.meta instanceof Error) {
          options.meta = exports2.clone(options.meta);
        }
        return String(options.formatter(exports2.clone(options)));
      }
      output = timestamp ? timestamp + " - " : "";
      if (showLevel) {
        output += options.colorize === "all" || options.colorize === "level" || options.colorize === true ? config.colorize(options.level) : options.level;
      }
      output += options.align ? "	" : "";
      output += timestamp || showLevel ? ": " : "";
      output += options.label ? "[" + options.label + "] " : "";
      output += options.colorize === "all" || options.colorize === "message" ? config.colorize(options.level, options.message) : options.message;
      if (meta !== null && meta !== void 0) {
        if (typeof meta !== "object") {
          output += " " + meta;
        } else if (Object.keys(meta).length > 0) {
          if (typeof options.prettyPrint === "function") {
            output += " " + options.prettyPrint(meta);
          } else if (options.prettyPrint) {
            output += " \n" + util.inspect(meta, false, options.depth || null, options.colorize);
          } else if (options.humanReadableUnhandledException && Object.keys(meta).length >= 5 && meta.hasOwnProperty("date") && meta.hasOwnProperty("process") && meta.hasOwnProperty("os") && meta.hasOwnProperty("trace") && meta.hasOwnProperty("stack")) {
            var stack = meta.stack;
            delete meta.stack;
            delete meta.trace;
            output += " " + exports2.serialize(meta);
            if (stack) {
              output += "\n" + stack.join("\n");
            }
          } else {
            output += " " + exports2.serialize(meta);
          }
        }
      }
      return output;
    };
    exports2.capitalize = function(str) {
      return str && str[0].toUpperCase() + str.slice(1);
    };
    exports2.hash = function(str) {
      return crypto.createHash("sha1").update(str).digest("hex");
    };
    exports2.pad = function(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    };
    exports2.timestamp = function() {
      return (/* @__PURE__ */ new Date()).toISOString();
    };
    exports2.serialize = function(obj, key) {
      if (typeof key === "symbol") {
        key = key.toString();
      }
      if (typeof obj === "symbol") {
        obj = obj.toString();
      }
      if (obj === null) {
        obj = "null";
      } else if (obj === void 0) {
        obj = "undefined";
      } else if (obj === false) {
        obj = "false";
      }
      if (typeof obj !== "object") {
        return key ? key + "=" + obj : obj;
      }
      if (obj instanceof Buffer) {
        return key ? key + "=" + obj.toString("base64") : obj.toString("base64");
      }
      var msg = "", keys = Object.keys(obj), length = keys.length;
      for (var i2 = 0; i2 < length; i2++) {
        if (Array.isArray(obj[keys[i2]])) {
          msg += keys[i2] + "=[";
          for (var j = 0, l = obj[keys[i2]].length; j < l; j++) {
            msg += exports2.serialize(obj[keys[i2]][j]);
            if (j < l - 1) {
              msg += ", ";
            }
          }
          msg += "]";
        } else if (obj[keys[i2]] instanceof Date) {
          msg += keys[i2] + "=" + obj[keys[i2]];
        } else {
          msg += exports2.serialize(obj[keys[i2]], keys[i2]);
        }
        if (i2 < length - 1) {
          msg += ", ";
        }
      }
      return msg;
    };
    exports2.tailFile = function(options, callback) {
      var buffer = Buffer.alloc(64 * 1024), decode = new StringDecoder("utf8"), stream2 = new Stream(), buff = "", pos = 0, row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream2.readable = true;
      stream2.destroy = function() {
        stream2.destroyed = true;
        stream2.emit("end");
        stream2.emit("close");
      };
      fs.open(options.file, "a+", "0644", function(err, fd) {
        if (err) {
          if (!callback) {
            stream2.emit("error", err);
          } else {
            callback(err);
          }
          stream2.destroy();
          return;
        }
        (function read() {
          if (stream2.destroyed) {
            fs.close(fd, nop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, function(err2, bytes) {
            if (err2) {
              if (!callback) {
                stream2.emit("error", err2);
              } else {
                callback(err2);
              }
              stream2.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!callback) {
                    stream2.emit("line", buff);
                  } else {
                    callback(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            var data = decode.write(buffer.slice(0, bytes));
            if (!callback) {
              stream2.emit("data", data);
            }
            var data = (buff + data).split(/\n+/), l = data.length - 1, i2 = 0;
            for (; i2 < l; i2++) {
              if (options.start == null || row > options.start) {
                if (!callback) {
                  stream2.emit("line", data[i2]);
                } else {
                  callback(null, data[i2]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!callback) {
        return stream2;
      }
      return stream2.destroy;
    };
    exports2.stringArrayToSet = function(strArray, errMsg) {
      if (typeof errMsg === "undefined") {
        errMsg = "Cannot make set from Array with non-string elements";
      }
      return strArray.reduce(function(set, el) {
        if (!(typeof el === "string" || el instanceof String)) {
          throw new Error(errMsg);
        }
        set[el] = true;
        return set;
      }, /* @__PURE__ */ Object.create(null));
    };
    function nop() {
    }
  }
});

// node_modules/winston/lib/winston/transports/transport.js
var require_transport = __commonJS({
  "node_modules/winston/lib/winston/transports/transport.js"(exports2) {
    var events = require("events");
    var util = require("util");
    var Transport = exports2.Transport = function(options) {
      events.EventEmitter.call(this);
      options = options || {};
      this.silent = options.silent || false;
      this.raw = options.raw || false;
      this.name = options.name || this.name;
      this.formatter = options.formatter;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions || false;
      this.exceptionsLevel = options.exceptionsLevel || "error";
      this.humanReadableUnhandledException = options.humanReadableUnhandledException || false;
    };
    util.inherits(Transport, events.EventEmitter);
    Transport.prototype.formatQuery = function(query) {
      return query;
    };
    Transport.prototype.normalizeQuery = function(options) {
      options = options || {};
      options.rows = options.rows || options.limit || 10;
      options.start = options.start || 0;
      options.until = options.until || /* @__PURE__ */ new Date();
      if (typeof options.until !== "object") {
        options.until = new Date(options.until);
      }
      options.from = options.from || options.until - 24 * 60 * 60 * 1e3;
      if (typeof options.from !== "object") {
        options.from = new Date(options.from);
      }
      options.order = options.order || "desc";
      options.fields = options.fields;
      return options;
    };
    Transport.prototype.formatResults = function(results, options) {
      return results;
    };
    Transport.prototype.logException = function(msg, meta, callback) {
      var self2 = this, called;
      if (this.silent) {
        return callback();
      }
      function onComplete() {
        if (!called) {
          called = true;
          self2.removeListener("logged", onComplete);
          self2.removeListener("error", onComplete);
          callback();
        }
      }
      this.once("logged", onComplete);
      this.once("error", onComplete);
      this.log(self2.exceptionsLevel, msg, meta, function() {
      });
    };
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports2) {
    var events = require("events");
    var os = require("os");
    var util = require("util");
    var common = require_common();
    var Transport = require_transport().Transport;
    var Console = exports2.Console = function(options) {
      Transport.call(this, options);
      options = options || {};
      this.json = options.json || false;
      this.colorize = options.colorize || false;
      this.prettyPrint = options.prettyPrint || false;
      this.timestamp = typeof options.timestamp !== "undefined" ? options.timestamp : false;
      this.showLevel = options.showLevel === void 0 ? true : options.showLevel;
      this.label = options.label || null;
      this.logstash = options.logstash || false;
      this.depth = options.depth || null;
      this.align = options.align || false;
      this.stderrLevels = setStderrLevels(options.stderrLevels, options.debugStdout);
      this.eol = options.eol || os.EOL;
      if (this.json) {
        this.stringify = options.stringify || function(obj) {
          return JSON.stringify(obj, null, 2);
        };
      }
      function setStderrLevels(levels, debugStdout) {
        var defaultMsg = "Cannot have non-string elements in stderrLevels Array";
        if (debugStdout) {
          if (levels) {
            throw new Error("Cannot set debugStdout and stderrLevels together");
          }
          return common.stringArrayToSet(["error"], defaultMsg);
        }
        if (!levels) {
          return common.stringArrayToSet(["error", "debug"], defaultMsg);
        } else if (!Array.isArray(levels)) {
          throw new Error("Cannot set stderrLevels to type other than Array");
        }
        return common.stringArrayToSet(levels, defaultMsg);
      }
      ;
    };
    util.inherits(Console, Transport);
    Console.prototype.name = "console";
    Console.prototype.log = function(level, msg, meta, callback) {
      if (this.silent) {
        return callback(null, true);
      }
      var self2 = this, output;
      output = common.log({
        colorize: this.colorize,
        json: this.json,
        level,
        message: msg,
        meta,
        stringify: this.stringify,
        timestamp: this.timestamp,
        showLevel: this.showLevel,
        prettyPrint: this.prettyPrint,
        raw: this.raw,
        label: this.label,
        logstash: this.logstash,
        depth: this.depth,
        formatter: this.formatter,
        align: this.align,
        humanReadableUnhandledException: this.humanReadableUnhandledException
      });
      if (this.stderrLevels[level]) {
        process.stderr.write(output + this.eol);
      } else {
        process.stdout.write(output + this.eol);
      }
      self2.emit("logged");
      callback(null, true);
    };
  }
});

// node_modules/winston/node_modules/async/dist/async.js
var require_async = __commonJS({
  "node_modules/winston/node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = global2.async || {});
    })(exports2, function(exports3) {
      "use strict";
      function slice(arrayLike, start) {
        start = start | 0;
        var newLen = Math.max(arrayLike.length - start, 0);
        var newArr = Array(newLen);
        for (var idx = 0; idx < newLen; idx++) {
          newArr[idx] = arrayLike[start + idx];
        }
        return newArr;
      }
      var apply = function(fn) {
        var args = slice(arguments, 1);
        return function() {
          var callArgs = slice(arguments);
          return fn.apply(null, args.concat(callArgs));
        };
      };
      var initialParams = function(fn) {
        return function() {
          var args = slice(arguments);
          var callback = args.pop();
          fn.call(this, args, callback);
        };
      };
      function isObject(value2) {
        var type = typeof value2;
        return value2 != null && (type == "object" || type == "function");
      }
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return function(fn) {
          var args = slice(arguments, 1);
          defer(function() {
            fn.apply(null, args);
          });
        };
      }
      var _defer;
      if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (isObject(result) && typeof result.then === "function") {
            result.then(function(value2) {
              invokeCallback(callback, null, value2);
            }, function(err) {
              invokeCallback(callback, err.message ? err : new Error(err));
            });
          } else {
            callback(null, result);
          }
        });
      }
      function invokeCallback(callback, error, value2) {
        try {
          callback(error, value2);
        } catch (e) {
          setImmediate$1(rethrow, e);
        }
      }
      function rethrow(error) {
        throw error;
      }
      var supportsSymbol = typeof Symbol === "function";
      function isAsync(fn) {
        return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function wrapAsync(asyncFn) {
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function applyEach$1(eachfn) {
        return function(fns) {
          var args = slice(arguments, 1);
          var go = initialParams(function(args2, callback) {
            var that = this;
            return eachfn(fns, function(fn, cb) {
              wrapAsync(fn).apply(that, args2.concat(cb));
            }, callback);
          });
          if (args.length) {
            return go.apply(this, args);
          } else {
            return go;
          }
        };
      }
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value2) {
        var isOwn = hasOwnProperty.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
        try {
          value2[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value2);
        if (unmasked) {
          if (isOwn) {
            value2[symToStringTag$1] = tag;
          } else {
            delete value2[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$1 = Object.prototype;
      var nativeObjectToString$1 = objectProto$1.toString;
      function objectToString(value2) {
        return nativeObjectToString$1.call(value2);
      }
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value2) {
        if (value2 == null) {
          return value2 === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
      }
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value2) {
        if (!isObject(value2)) {
          return false;
        }
        var tag = baseGetTag(value2);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value2) {
        return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value2) {
        return value2 != null && isLength(value2.length) && !isFunction(value2);
      }
      var breakLoop = {};
      function noop() {
      }
      function once(fn) {
        return function() {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
        };
      }
      var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
      var getIterator = function(coll) {
        return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
      };
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function isObjectLike(value2) {
        return value2 != null && typeof value2 == "object";
      }
      var argsTag = "[object Arguments]";
      function baseIsArguments(value2) {
        return isObjectLike(value2) && baseGetTag(value2) == argsTag;
      }
      var objectProto$3 = Object.prototype;
      var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
      var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value2) {
        return isObjectLike(value2) && hasOwnProperty$2.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
      };
      var isArray = Array.isArray;
      function stubFalse() {
        return false;
      }
      var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value2, length) {
        var type = typeof value2;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
      }
      var argsTag$1 = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag$1 = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value2) {
        return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
      }
      function baseUnary(func) {
        return function(value2) {
          return func(value2);
        };
      }
      var freeExports$1 = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
      var freeModule$1 = freeExports$1 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
      function arrayLikeKeys(value2, inherited) {
        var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
        for (var key in value2) {
          if ((inherited || hasOwnProperty$1.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$5 = Object.prototype;
      function isPrototype(value2) {
        var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
        return value2 === proto;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$3.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function createArrayIterator(coll) {
        var i2 = -1;
        var len = coll.length;
        return function next() {
          return ++i2 < len ? { value: coll[i2], key: i2 } : null;
        };
      }
      function createES2015Iterator(iterator2) {
        var i2 = -1;
        return function next() {
          var item2 = iterator2.next();
          if (item2.done)
            return null;
          i2++;
          return { value: item2.value, key: i2 };
        };
      }
      function createObjectIterator(obj) {
        var okeys = keys(obj);
        var i2 = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i2];
          if (key === "__proto__") {
            return next();
          }
          return i2 < len ? { value: obj[key], key } : null;
        };
      }
      function iterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator2 = getIterator(coll);
        return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function() {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
        };
      }
      function _eachOfLimit(limit) {
        return function(obj, iteratee, callback) {
          callback = once(callback || noop);
          if (limit <= 0 || !obj) {
            return callback(null);
          }
          var nextElem = iterator(obj);
          var done = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value2) {
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (value2 === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      }
      function eachOfLimit(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      function doLimit(fn, limit) {
        return function(iterable, iteratee, callback) {
          return fn(iterable, limit, iteratee, callback);
        };
      }
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback || noop);
        var index2 = 0, completed = 0, length = coll.length;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value2) {
          if (err) {
            callback(err);
          } else if (++completed === length || value2 === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      var eachOfGeneric = doLimit(eachOfLimit, Infinity);
      var eachOf = function(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        eachOfImplementation(coll, wrapAsync(iteratee), callback);
      };
      function doParallel(fn) {
        return function(obj, iteratee, callback) {
          return fn(eachOf, obj, wrapAsync(iteratee), callback);
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        callback = callback || noop;
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        eachfn(arr, function(value2, _, callback2) {
          var index2 = counter++;
          _iteratee(value2, function(err, v) {
            results[index2] = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      }
      var map = doParallel(_asyncMap);
      var applyEach = applyEach$1(map);
      function doParallelLimit(fn) {
        return function(obj, limit, iteratee, callback) {
          return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
        };
      }
      var mapLimit = doParallelLimit(_asyncMap);
      var mapSeries = doLimit(mapLimit, 1);
      var applyEachSeries = applyEach$1(mapSeries);
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value2) {
        return value2 !== value2;
      }
      function strictIndexOf(array, value2, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value2) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value2, fromIndex) {
        return value2 === value2 ? strictIndexOf(array, value2, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var auto = function(tasks, concurrency, callback) {
        if (typeof concurrency === "function") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || noop);
        var keys$$1 = keys(tasks);
        var numTasks = keys$$1.length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var hasError = false;
        var listeners = /* @__PURE__ */ Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        baseForOwn(tasks, function(task, key) {
          if (!isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          arrayEach(dependencies, function(dependencyName) {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, function() {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(function() {
            runTask(key, task);
          });
        }
        function processQueue() {
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          arrayEach(taskListeners, function(fn) {
            fn();
          });
          processQueue();
        }
        function runTask(key, task) {
          if (hasError)
            return;
          var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length > 2) {
              result = slice(arguments, 1);
            }
            if (err) {
              var safeResults = {};
              baseForOwn(results, function(val, rkey) {
                safeResults[rkey] = val;
              });
              safeResults[key] = result;
              hasError = true;
              listeners = /* @__PURE__ */ Object.create(null);
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function(dependent) {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error(
              "async.auto cannot execute tasks due to a recursive dependency"
            );
          }
        }
        function getDependents(taskName) {
          var result = [];
          baseForOwn(tasks, function(task, key) {
            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
      };
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      var symbolTag = "[object Symbol]";
      function isSymbol(value2) {
        return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
      }
      var INFINITY = 1 / 0;
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value2) {
        if (typeof value2 == "string") {
          return value2;
        }
        if (isArray(value2)) {
          return arrayMap(value2, baseToString) + "";
        }
        if (isSymbol(value2)) {
          return symbolToString ? symbolToString.call(value2) : "";
        }
        var result = value2 + "";
        return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index2 < length) {
          result[index2] = array[index2 + start];
        }
        return result;
      }
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function asciiToArray(string) {
        return string.split("");
      }
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      var rsAstralRange$1 = "\\ud800-\\udfff";
      var rsComboMarksRange$1 = "\\u0300-\\u036f";
      var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
      var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
      var rsVarRange$1 = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange$1 + "]";
      var rsCombo = "[" + rsComboRange$1 + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange$1 + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ$1 = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange$1 + "]?";
      var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function toString(value2) {
        return value2 == null ? "" : baseToString(value2);
      }
      var reTrim = /^\s+|\s+$/g;
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === void 0)) {
          return string.replace(reTrim, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      function parseParams(func) {
        func = func.toString().replace(STRIP_COMMENTS, "");
        func = func.match(FN_ARGS)[2].replace(" ", "");
        func = func ? func.split(FN_ARG_SPLIT) : [];
        func = func.map(function(arg) {
          return trim(arg.replace(FN_ARG, ""));
        });
        return func;
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        baseForOwn(tasks, function(taskFn, key) {
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function(name2) {
              return results[name2];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
          }
        });
        auto(newTasks, callback);
      }
      function DLL() {
        this.head = this.tail = null;
        this.length = 0;
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      DLL.prototype.removeLink = function(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      };
      DLL.prototype.empty = function() {
        while (this.head)
          this.shift();
        return this;
      };
      DLL.prototype.insertAfter = function(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      };
      DLL.prototype.insertBefore = function(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      };
      DLL.prototype.unshift = function(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      };
      DLL.prototype.push = function(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      };
      DLL.prototype.shift = function() {
        return this.head && this.removeLink(this.head);
      };
      DLL.prototype.pop = function() {
        return this.tail && this.removeLink(this.tail);
      };
      DLL.prototype.toArray = function() {
        var arr = Array(this.length);
        var curr = this.head;
        for (var idx = 0; idx < this.length; idx++) {
          arr[idx] = curr.data;
          curr = curr.next;
        }
        return arr;
      };
      DLL.prototype.remove = function(testFn) {
        var curr = this.head;
        while (!!curr) {
          var next = curr.next;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      };
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new Error("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        var processingScheduled = false;
        function _insert(data, insertAtFront, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q.idle()) {
            return setImmediate$1(function() {
              q.drain();
            });
          }
          for (var i2 = 0, l = data.length; i2 < l; i2++) {
            var item2 = {
              data: data[i2],
              callback: callback || noop
            };
            if (insertAtFront) {
              q._tasks.unshift(item2);
            } else {
              q._tasks.push(item2);
            }
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(function() {
              processingScheduled = false;
              q.process();
            });
          }
        }
        function _next(tasks) {
          return function(err) {
            numRunning -= 1;
            for (var i2 = 0, l = tasks.length; i2 < l; i2++) {
              var task = tasks[i2];
              var index2 = baseIndexOf(workersList, task, 0);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback.apply(task, arguments);
              if (err != null) {
                q.error(err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              q.unsaturated();
            }
            if (q.idle()) {
              q.drain();
            }
            q.process();
          };
        }
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          concurrency,
          payload,
          saturated: noop,
          unsaturated: noop,
          buffer: concurrency / 4,
          empty: noop,
          drain: noop,
          error: noop,
          started: false,
          paused: false,
          push: function(data, callback) {
            _insert(data, false, callback);
          },
          kill: function() {
            q.drain = noop;
            q._tasks.empty();
          },
          unshift: function(data, callback) {
            _insert(data, true, callback);
          },
          remove: function(testFn) {
            q._tasks.remove(testFn);
          },
          process: function() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload)
                l = Math.min(l, q.payload);
              for (var i2 = 0; i2 < l; i2++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                q.empty();
              }
              if (numRunning === q.concurrency) {
                q.saturated();
              }
              var cb = onlyOnce(_next(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length: function() {
            return q._tasks.length;
          },
          running: function() {
            return numRunning;
          },
          workersList: function() {
            return workersList;
          },
          idle: function() {
            return q._tasks.length + numRunning === 0;
          },
          pause: function() {
            q.paused = true;
          },
          resume: function() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      var eachOfSeries = doLimit(eachOfLimit, 1);
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        eachOfSeries(coll, function(x, i2, callback2) {
          _iteratee(memo, x, function(err, v) {
            memo = v;
            callback2(err);
          });
        }, function(err) {
          callback(err, memo);
        });
      }
      function seq() {
        var _functions = arrayMap(arguments, wrapAsync);
        return function() {
          var args = slice(arguments);
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = noop;
          }
          reduce(
            _functions,
            args,
            function(newargs, fn, cb2) {
              fn.apply(that, newargs.concat(function(err) {
                var nextargs = slice(arguments, 1);
                cb2(err, nextargs);
              }));
            },
            function(err, results) {
              cb.apply(that, [err].concat(results));
            }
          );
        };
      }
      var compose = function() {
        return seq.apply(null, slice(arguments).reverse());
      };
      var _concat = Array.prototype.concat;
      var concatLimit = function(coll, limit, iteratee, callback) {
        callback = callback || noop;
        var _iteratee = wrapAsync(iteratee);
        mapLimit(coll, limit, function(val, callback2) {
          _iteratee(val, function(err) {
            if (err)
              return callback2(err);
            return callback2(null, slice(arguments, 1));
          });
        }, function(err, mapResults) {
          var result = [];
          for (var i2 = 0; i2 < mapResults.length; i2++) {
            if (mapResults[i2]) {
              result = _concat.apply(result, mapResults[i2]);
            }
          }
          return callback(err, result);
        });
      };
      var concat = doLimit(concatLimit, Infinity);
      var concatSeries = doLimit(concatLimit, 1);
      var constant = function() {
        var values = slice(arguments);
        var args = [null].concat(values);
        return function() {
          var callback = arguments[arguments.length - 1];
          return callback.apply(this, args);
        };
      };
      function identity(value2) {
        return value2;
      }
      function _createTester(check, getResult) {
        return function(eachfn, arr, iteratee, cb) {
          cb = cb || noop;
          var testPassed = false;
          var testResult;
          eachfn(arr, function(value2, _, callback) {
            iteratee(value2, function(err, result) {
              if (err) {
                callback(err);
              } else if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value2);
                callback(null, breakLoop);
              } else {
                callback();
              }
            });
          }, function(err) {
            if (err) {
              cb(err);
            } else {
              cb(null, testPassed ? testResult : getResult(false));
            }
          });
        };
      }
      function _findGetResult(v, x) {
        return x;
      }
      var detect = doParallel(_createTester(identity, _findGetResult));
      var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));
      var detectSeries = doLimit(detectLimit, 1);
      function consoleFunc(name2) {
        return function(fn) {
          var args = slice(arguments, 1);
          args.push(function(err) {
            var args2 = slice(arguments, 1);
            if (typeof console === "object") {
              if (err) {
                if (console.error) {
                  console.error(err);
                }
              } else if (console[name2]) {
                arrayEach(args2, function(x) {
                  console[name2](x);
                });
              }
            }
          });
          wrapAsync(fn).apply(null, args);
        };
      }
      var dir = consoleFunc("dir");
      function doDuring(fn, test, callback) {
        callback = onlyOnce(callback || noop);
        var _fn = wrapAsync(fn);
        var _test = wrapAsync(test);
        function next(err) {
          if (err)
            return callback(err);
          var args = slice(arguments, 1);
          args.push(check);
          _test.apply(this, args);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (!truth)
            return callback(null);
          _fn(next);
        }
        check(null, true);
      }
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        var next = function(err) {
          if (err)
            return callback(err);
          var args = slice(arguments, 1);
          if (test.apply(this, args))
            return _iteratee(next);
          callback.apply(null, [null].concat(args));
        };
        _iteratee(next);
      }
      function doUntil(iteratee, test, callback) {
        doWhilst(iteratee, function() {
          return !test.apply(this, arguments);
        }, callback);
      }
      function during(test, fn, callback) {
        callback = onlyOnce(callback || noop);
        var _fn = wrapAsync(fn);
        var _test = wrapAsync(test);
        function next(err) {
          if (err)
            return callback(err);
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (!truth)
            return callback(null);
          _fn(next);
        }
        _test(check);
      }
      function _withoutIndex(iteratee) {
        return function(value2, index2, callback) {
          return iteratee(value2, callback);
        };
      }
      function eachLimit(coll, iteratee, callback) {
        eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      function eachLimit$1(coll, limit, iteratee, callback) {
        _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachSeries = doLimit(eachLimit$1, 1);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return initialParams(function(args, callback) {
          var sync = true;
          args.push(function() {
            var innerArgs = arguments;
            if (sync) {
              setImmediate$1(function() {
                callback.apply(null, innerArgs);
              });
            } else {
              callback.apply(null, innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        });
      }
      function notId(v) {
        return !v;
      }
      var every = doParallel(_createTester(notId, notId));
      var everyLimit = doParallelLimit(_createTester(notId, notId));
      var everySeries = doLimit(everyLimit, 1);
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, function(x, index2, callback2) {
          iteratee(x, function(err, v) {
            truthValues[index2] = !!v;
            callback2(err);
          });
        }, function(err) {
          if (err)
            return callback(err);
          var results = [];
          for (var i2 = 0; i2 < arr.length; i2++) {
            if (truthValues[i2])
              results.push(arr[i2]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, function(x, index2, callback2) {
          iteratee(x, function(err, v) {
            if (err) {
              callback2(err);
            } else {
              if (v) {
                results.push({ index: index2, value: x });
              }
              callback2();
            }
          });
        }, function(err) {
          if (err) {
            callback(err);
          } else {
            callback(null, arrayMap(results.sort(function(a, b) {
              return a.index - b.index;
            }), baseProperty("value")));
          }
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        filter2(eachfn, coll, wrapAsync(iteratee), callback || noop);
      }
      var filter = doParallel(_filter);
      var filterLimit = doParallelLimit(_filter);
      var filterSeries = doLimit(filterLimit, 1);
      function forever(fn, errback) {
        var done = onlyOnce(errback || noop);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          task(next);
        }
        next();
      }
      var groupByLimit = function(coll, limit, iteratee, callback) {
        callback = callback || noop;
        var _iteratee = wrapAsync(iteratee);
        mapLimit(coll, limit, function(val, callback2) {
          _iteratee(val, function(err, key) {
            if (err)
              return callback2(err);
            return callback2(null, { key, val });
          });
        }, function(err, mapResults) {
          var result = {};
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          for (var i2 = 0; i2 < mapResults.length; i2++) {
            if (mapResults[i2]) {
              var key = mapResults[i2].key;
              var val = mapResults[i2].val;
              if (hasOwnProperty2.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      };
      var groupBy = doLimit(groupByLimit, Infinity);
      var groupBySeries = doLimit(groupByLimit, 1);
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback || noop);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        eachOfLimit(obj, limit, function(val, key, next) {
          _iteratee(val, key, function(err, result) {
            if (err)
              return next(err);
            newObj[key] = result;
            next();
          });
        }, function(err) {
          callback(err, newObj);
        });
      }
      var mapValues = doLimit(mapValuesLimit, Infinity);
      var mapValuesSeries = doLimit(mapValuesLimit, 1);
      function has(obj, key) {
        return key in obj;
      }
      function memoize(fn, hasher) {
        var memo = /* @__PURE__ */ Object.create(null);
        var queues = /* @__PURE__ */ Object.create(null);
        hasher = hasher || identity;
        var _fn = wrapAsync(fn);
        var memoized = initialParams(function memoized2(args, callback) {
          var key = hasher.apply(null, args);
          if (has(memo, key)) {
            setImmediate$1(function() {
              callback.apply(null, memo[key]);
            });
          } else if (has(queues, key)) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function() {
              var args2 = slice(arguments);
              memo[key] = args2;
              var q = queues[key];
              delete queues[key];
              for (var i2 = 0, l = q.length; i2 < l; i2++) {
                q[i2].apply(null, args2);
              }
            }));
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, function(task, key, callback2) {
          wrapAsync(task)(function(err, result) {
            if (arguments.length > 2) {
              result = slice(arguments, 1);
            }
            results[key] = result;
            callback2(err);
          });
        }, function(err) {
          callback(err, results);
        });
      }
      function parallelLimit(tasks, callback) {
        _parallel(eachOf, tasks, callback);
      }
      function parallelLimit$1(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
      }
      var queue$1 = function(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue(function(items, cb) {
          _worker(items[0], cb);
        }, concurrency, 1);
      };
      var priorityQueue = function(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        q.push = function(data, priority, callback) {
          if (callback == null)
            callback = noop;
          if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!isArray(data)) {
            data = [data];
          }
          if (data.length === 0) {
            return setImmediate$1(function() {
              q.drain();
            });
          }
          priority = priority || 0;
          var nextNode = q._tasks.head;
          while (nextNode && priority >= nextNode.priority) {
            nextNode = nextNode.next;
          }
          for (var i2 = 0, l = data.length; i2 < l; i2++) {
            var item2 = {
              data: data[i2],
              priority,
              callback
            };
            if (nextNode) {
              q._tasks.insertBefore(nextNode, item2);
            } else {
              q._tasks.push(item2);
            }
          }
          setImmediate$1(q.process);
        };
        delete q.unshift;
        return q;
      };
      function race(tasks, callback) {
        callback = once(callback || noop);
        if (!isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i2 = 0, l = tasks.length; i2 < l; i2++) {
          wrapAsync(tasks[i2])(callback);
        }
      }
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = slice(array).reverse();
        reduce(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push(function callback(error, cbArg) {
            if (error) {
              reflectCallback(null, { error });
            } else {
              var value2;
              if (arguments.length <= 2) {
                value2 = cbArg;
              } else {
                value2 = slice(arguments, 1);
              }
              reflectCallback(null, { value: value2 });
            }
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (isArray(tasks)) {
          results = arrayMap(tasks, reflect);
        } else {
          results = {};
          baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
          });
        }
        return results;
      }
      function reject$1(eachfn, arr, iteratee, callback) {
        _filter(eachfn, arr, function(value2, cb) {
          iteratee(value2, function(err, v) {
            cb(err, !v);
          });
        }, callback);
      }
      var reject2 = doParallel(reject$1);
      var rejectLimit = doParallelLimit(reject$1);
      var rejectSeries = doLimit(rejectLimit, 1);
      function constant$1(value2) {
        return function() {
          return value2;
        };
      }
      function retry(opts, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        function parseTimes(acc, t) {
          if (typeof t === "object") {
            acc.times = +t.times || DEFAULT_TIMES;
            acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
            acc.errorFilter = t.errorFilter;
          } else if (typeof t === "number" || typeof t === "string") {
            acc.times = +t || DEFAULT_TIMES;
          } else {
            throw new Error("Invalid arguments for async.retry");
          }
        }
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || noop;
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || noop;
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task(function(err) {
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
              callback.apply(null, arguments);
            }
          });
        }
        retryAttempt();
      }
      var retryable = function(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        var _task = wrapAsync(task);
        return initialParams(function(args, callback) {
          function taskFn(cb) {
            _task.apply(null, args.concat(cb));
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
        });
      };
      function series(tasks, callback) {
        _parallel(eachOfSeries, tasks, callback);
      }
      var some = doParallel(_createTester(Boolean, identity));
      var someLimit = doParallelLimit(_createTester(Boolean, identity));
      var someSeries = doLimit(someLimit, 1);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        map(coll, function(x, callback2) {
          _iteratee(x, function(err, criteria) {
            if (err)
              return callback2(err);
            callback2(null, { value: x, criteria });
          });
        }, function(err, results) {
          if (err)
            return callback(err);
          callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams(function(args, callback) {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name2 = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name2 + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push(function() {
            if (!timedOut) {
              callback.apply(null, arguments);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn.apply(null, args);
        });
      }
      var nativeCeil = Math.ceil;
      var nativeMax = Math.max;
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result;
      }
      function timeLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
      }
      var times = doLimit(timeLimit, Infinity);
      var timesSeries = doLimit(timeLimit, 1);
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3) {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = isArray(coll) ? [] : {};
        }
        callback = once(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        eachOf(coll, function(v, k, cb) {
          _iteratee(accumulator, v, k, cb);
        }, function(err) {
          callback(err, accumulator);
        });
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        callback = callback || noop;
        eachSeries(tasks, function(task, callback2) {
          wrapAsync(task)(function(err, res) {
            if (arguments.length > 2) {
              result = slice(arguments, 1);
            } else {
              result = res;
            }
            error = err;
            callback2(!err);
          });
        }, function() {
          callback(error, result);
        });
      }
      function unmemoize(fn) {
        return function() {
          return (fn.unmemoized || fn).apply(null, arguments);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback || noop);
        var _iteratee = wrapAsync(iteratee);
        if (!test())
          return callback(null);
        var next = function(err) {
          if (err)
            return callback(err);
          if (test())
            return _iteratee(next);
          var args = slice(arguments, 1);
          callback.apply(null, [null].concat(args));
        };
        _iteratee(next);
      }
      function until(test, iteratee, callback) {
        whilst(function() {
          return !test.apply(this, arguments);
        }, iteratee, callback);
      }
      var waterfall = function(tasks, callback) {
        callback = once(callback || noop);
        if (!isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          args.push(onlyOnce(next));
          task.apply(null, args);
        }
        function next(err) {
          if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
          }
          nextTask(slice(arguments, 1));
        }
        nextTask([]);
      };
      var index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        compose,
        concat,
        concatLimit,
        concatSeries,
        constant,
        detect,
        detectLimit,
        detectSeries,
        dir,
        doDuring,
        doUntil,
        doWhilst,
        during,
        each: eachLimit,
        eachLimit: eachLimit$1,
        eachOf,
        eachOfLimit,
        eachOfSeries,
        eachSeries,
        ensureAsync,
        every,
        everyLimit,
        everySeries,
        filter,
        filterLimit,
        filterSeries,
        forever,
        groupBy,
        groupByLimit,
        groupBySeries,
        log,
        map,
        mapLimit,
        mapSeries,
        mapValues,
        mapValuesLimit,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel: parallelLimit,
        parallelLimit: parallelLimit$1,
        priorityQueue,
        queue: queue$1,
        race,
        reduce,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject2,
        rejectLimit,
        rejectSeries,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some,
        someLimit,
        someSeries,
        sortBy,
        timeout,
        times,
        timesLimit: timeLimit,
        timesSeries,
        transform,
        tryEach,
        unmemoize,
        until,
        waterfall,
        whilst,
        // aliases
        all: every,
        allLimit: everyLimit,
        allSeries: everySeries,
        any: some,
        anyLimit: someLimit,
        anySeries: someSeries,
        find: detect,
        findLimit: detectLimit,
        findSeries: detectSeries,
        forEach: eachLimit,
        forEachSeries: eachSeries,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf,
        forEachOfSeries: eachOfSeries,
        forEachOfLimit: eachOfLimit,
        inject: reduce,
        foldl: reduce,
        foldr: reduceRight,
        select: filter,
        selectLimit: filterLimit,
        selectSeries: filterSeries,
        wrapSync: asyncify
      };
      exports3["default"] = index;
      exports3.apply = apply;
      exports3.applyEach = applyEach;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo;
      exports3.compose = compose;
      exports3.concat = concat;
      exports3.concatLimit = concatLimit;
      exports3.concatSeries = concatSeries;
      exports3.constant = constant;
      exports3.detect = detect;
      exports3.detectLimit = detectLimit;
      exports3.detectSeries = detectSeries;
      exports3.dir = dir;
      exports3.doDuring = doDuring;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst;
      exports3.during = during;
      exports3.each = eachLimit;
      exports3.eachLimit = eachLimit$1;
      exports3.eachOf = eachOf;
      exports3.eachOfLimit = eachOfLimit;
      exports3.eachOfSeries = eachOfSeries;
      exports3.eachSeries = eachSeries;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every;
      exports3.everyLimit = everyLimit;
      exports3.everySeries = everySeries;
      exports3.filter = filter;
      exports3.filterLimit = filterLimit;
      exports3.filterSeries = filterSeries;
      exports3.forever = forever;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit;
      exports3.groupBySeries = groupBySeries;
      exports3.log = log;
      exports3.map = map;
      exports3.mapLimit = mapLimit;
      exports3.mapSeries = mapSeries;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallelLimit;
      exports3.parallelLimit = parallelLimit$1;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue$1;
      exports3.race = race;
      exports3.reduce = reduce;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject2;
      exports3.rejectLimit = rejectLimit;
      exports3.rejectSeries = rejectSeries;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some;
      exports3.someLimit = someLimit;
      exports3.someSeries = someSeries;
      exports3.sortBy = sortBy;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timeLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall;
      exports3.whilst = whilst;
      exports3.all = every;
      exports3.allLimit = everyLimit;
      exports3.allSeries = everySeries;
      exports3.any = some;
      exports3.anyLimit = someLimit;
      exports3.anySeries = someSeries;
      exports3.find = detect;
      exports3.findLimit = detectLimit;
      exports3.findSeries = detectSeries;
      exports3.forEach = eachLimit;
      exports3.forEachSeries = eachSeries;
      exports3.forEachLimit = eachLimit$1;
      exports3.forEachOf = eachOf;
      exports3.forEachOfSeries = eachOfSeries;
      exports3.forEachOfLimit = eachOfLimit;
      exports3.inject = reduce;
      exports3.foldl = reduce;
      exports3.foldr = reduceRight;
      exports3.select = filter;
      exports3.selectLimit = filterLimit;
      exports3.selectSeries = filterSeries;
      exports3.wrapSync = asyncify;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS({
  "node_modules/isstream/isstream.js"(exports2, module2) {
    var stream2 = require("stream");
    function isStream(obj) {
      return obj instanceof stream2.Stream;
    }
    function isReadable(obj) {
      return isStream(obj) && typeof obj._read == "function" && typeof obj._readableState == "object";
    }
    function isWritable(obj) {
      return isStream(obj) && typeof obj._write == "function" && typeof obj._writableState == "object";
    }
    function isDuplex(obj) {
      return isReadable(obj) && isWritable(obj);
    }
    module2.exports = isStream;
    module2.exports.isReadable = isReadable;
    module2.exports.isWritable = isWritable;
    module2.exports.isDuplex = isDuplex;
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports2) {
    var events = require("events");
    var fs = require("fs");
    var path4 = require("path");
    var util = require("util");
    var async = require_async();
    var zlib = require("zlib");
    var common = require_common();
    var Transport = require_transport().Transport;
    var isWritable = require_isstream().isWritable;
    var Stream = require("stream").Stream;
    var os = require("os");
    var File = exports2.File = function(options) {
      var self2 = this;
      Transport.call(this, options);
      function throwIf(target) {
        Array.prototype.slice.call(arguments, 1).forEach(function(name2) {
          if (options[name2]) {
            throw new Error("Cannot set " + name2 + " and " + target + "together");
          }
        });
      }
      if (options.filename || options.dirname) {
        throwIf("filename or dirname", "stream");
        this._basename = this.filename = options.filename ? path4.basename(options.filename) : "winston.log";
        this.dirname = options.dirname || path4.dirname(options.filename);
        this.options = options.options || { flags: "a" };
        this.options.highWaterMark = this.options.highWaterMark || 24;
      } else if (options.stream) {
        throwIf("stream", "filename", "maxsize");
        this._stream = options.stream;
        this._isStreams2 = isWritable(this._stream);
        this._stream.on("error", function(error) {
          self2.emit("error", error);
        });
        this._stream.setMaxListeners(Infinity);
      } else {
        throw new Error("Cannot log to file without filename or stream.");
      }
      this.json = options.json !== false;
      this.logstash = options.logstash || false;
      this.colorize = options.colorize || false;
      this.maxsize = options.maxsize || null;
      this.rotationFormat = options.rotationFormat || false;
      this.zippedArchive = options.zippedArchive || false;
      this.maxFiles = options.maxFiles || null;
      this.prettyPrint = options.prettyPrint || false;
      this.label = options.label || null;
      this.timestamp = options.timestamp != null ? options.timestamp : true;
      this.eol = options.eol || os.EOL;
      this.tailable = options.tailable || false;
      this.depth = options.depth || null;
      this.showLevel = options.showLevel === void 0 ? true : options.showLevel;
      this.maxRetries = options.maxRetries || 2;
      if (this.json) {
        this.stringify = options.stringify;
      }
      this._size = 0;
      this._created = 0;
      this._buffer = [];
      this._draining = false;
      this._opening = false;
      this._failures = 0;
      this._archive = null;
    };
    util.inherits(File, Transport);
    File.prototype.name = "file";
    File.prototype.log = function(level, msg, meta, callback) {
      if (this.silent) {
        return callback(null, true);
      }
      if (this._failures >= this.maxRetries) {
        return callback(new Error("Transport is in a failed state."));
      }
      var self2 = this;
      if (typeof msg !== "string") {
        msg = "" + msg;
      }
      var output = common.log({
        level,
        message: msg,
        meta,
        json: this.json,
        logstash: this.logstash,
        colorize: this.colorize,
        prettyPrint: this.prettyPrint,
        timestamp: this.timestamp,
        showLevel: this.showLevel,
        stringify: this.stringify,
        label: this.label,
        depth: this.depth,
        formatter: this.formatter,
        humanReadableUnhandledException: this.humanReadableUnhandledException
      });
      if (typeof output === "string") {
        output += this.eol;
      }
      if (!this.filename) {
        this._write(output, callback);
        this._size += output.length;
        this._lazyDrain();
      } else {
        this.open(function(err) {
          if (err) {
            return self2._buffer.push([output, callback]);
          }
          self2._write(output, callback);
          self2._size += output.length;
          self2._lazyDrain();
        });
      }
    };
    File.prototype._write = function(data, callback) {
      if (this._isStreams2) {
        this._stream.write(data);
        return callback && process.nextTick(function() {
          callback(null, true);
        });
      }
      var ret = this._stream.write(data);
      if (!callback)
        return;
      if (ret === false) {
        return this._stream.once("drain", function() {
          callback(null, true);
        });
      }
      process.nextTick(function() {
        callback(null, true);
      });
    };
    File.prototype.query = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      var file = path4.join(this.dirname, this.filename), options = this.normalizeQuery(options), buff = "", results = [], row = 0;
      var stream2 = fs.createReadStream(file, {
        encoding: "utf8"
      });
      stream2.on("error", function(err) {
        if (stream2.readable) {
          stream2.destroy();
        }
        if (!callback)
          return;
        return err.code !== "ENOENT" ? callback(err) : callback(null, results);
      });
      stream2.on("data", function(data) {
        var data = (buff + data).split(/\n+/), l = data.length - 1, i2 = 0;
        for (; i2 < l; i2++) {
          if (!options.start || row >= options.start) {
            add(data[i2]);
          }
          row++;
        }
        buff = data[l];
      });
      stream2.on("close", function() {
        if (buff)
          add(buff, true);
        if (options.order === "desc") {
          results = results.reverse();
        }
        if (callback)
          callback(null, results);
      });
      function add(buff2, attempt) {
        try {
          var log = JSON.parse(buff2);
          if (check(log))
            push(log);
        } catch (e) {
          if (!attempt) {
            stream2.emit("error", e);
          }
        }
      }
      function push(log) {
        if (options.rows && results.length >= options.rows && options.order != "desc") {
          if (stream2.readable) {
            stream2.destroy();
          }
          return;
        }
        if (options.fields) {
          var obj = {};
          options.fields.forEach(function(key) {
            obj[key] = log[key];
          });
          log = obj;
        }
        if (options.order === "desc") {
          if (results.length >= options.rows) {
            results.shift();
          }
        }
        results.push(log);
      }
      function check(log) {
        if (!log)
          return;
        if (typeof log !== "object")
          return;
        var time = new Date(log.timestamp);
        if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
          return;
        }
        return true;
      }
    };
    File.prototype.stream = function(options) {
      var file = path4.join(this.dirname, this.filename), options = options || {}, stream2 = new Stream();
      var tail = {
        file,
        start: options.start
      };
      stream2.destroy = common.tailFile(tail, function(err, line) {
        if (err) {
          return stream2.emit("error", err);
        }
        try {
          stream2.emit("data", line);
          line = JSON.parse(line);
          stream2.emit("log", line);
        } catch (e) {
          stream2.emit("error", e);
        }
      });
      return stream2;
    };
    File.prototype.open = function(callback) {
      if (this.opening) {
        return callback(true);
      } else if (!this._stream || this.maxsize && this._size >= this.maxsize) {
        callback(true);
        return this._createStream();
      }
      this._archive = this.zippedArchive ? this._stream.path : null;
      callback();
    };
    File.prototype.close = function() {
      var self2 = this;
      if (this._stream) {
        this._stream.end();
        this._stream.destroySoon();
        this._stream.once("finish", function() {
          self2.emit("flush");
          self2.emit("closed");
        });
      }
    };
    File.prototype.flush = function() {
      var self2 = this;
      if (!this._buffer.length) {
        return self2.emit("flush");
      }
      this._buffer.forEach(function(item2) {
        var str = item2[0], callback = item2[1];
        process.nextTick(function() {
          self2._write(str, callback);
          self2._size += str.length;
        });
      });
      self2._buffer.length = 0;
      self2._stream.once("drain", function() {
        self2.emit("flush");
        self2.emit("logged");
      });
    };
    File.prototype._createStream = function() {
      var self2 = this;
      this.opening = true;
      (function checkFile(target) {
        var fullname = path4.join(self2.dirname, target);
        function createAndFlush(size) {
          if (self2._stream) {
            self2._stream.end();
            self2._stream.destroySoon();
          }
          self2._size = size;
          self2.filename = target;
          self2._stream = fs.createWriteStream(fullname, self2.options);
          self2._isStreams2 = isWritable(self2._stream);
          self2._stream.on("error", function(error) {
            if (self2._failures < self2.maxRetries) {
              self2._createStream();
              self2._failures++;
            } else {
              self2.emit("error", error);
            }
          });
          self2._stream.setMaxListeners(Infinity);
          self2.once("flush", function() {
            self2.flush();
            self2.opening = false;
            self2.emit("open", fullname);
          });
          self2.flush();
          compressFile();
        }
        function compressFile() {
          if (self2._archive) {
            var gzip = zlib.createGzip();
            var inp = fs.createReadStream(String(self2._archive));
            var out = fs.createWriteStream(self2._archive + ".gz");
            inp.pipe(gzip).pipe(out);
            fs.unlink(String(self2._archive), function() {
            });
            self2._archive = "";
          }
        }
        fs.stat(fullname, function(err, stats) {
          if (err) {
            if (err.code !== "ENOENT") {
              return self2.emit("error", err);
            }
            return createAndFlush(0);
          }
          if (!stats || self2.maxsize && stats.size >= self2.maxsize) {
            return self2._incFile(function() {
              checkFile(self2._getFile());
            });
          }
          createAndFlush(stats.size);
        });
      })(this._getFile());
    };
    File.prototype._incFile = function(callback) {
      var ext = path4.extname(this._basename), basename3 = path4.basename(this._basename, ext), oldest, target;
      if (!this.tailable) {
        this._created += 1;
        this._checkMaxFilesIncrementing(ext, basename3, callback);
      } else {
        this._checkMaxFilesTailable(ext, basename3, callback);
      }
    };
    File.prototype._getFile = function() {
      var ext = path4.extname(this._basename), basename3 = path4.basename(this._basename, ext);
      return !this.tailable && this._created ? basename3 + (this.rotationFormat ? this.rotationFormat() : this._created) + ext : basename3 + ext;
    };
    File.prototype._checkMaxFilesIncrementing = function(ext, basename3, callback) {
      var oldest, target, self2 = this;
      if (self2.zippedArchive) {
        self2._archive = path4.join(self2.dirname, basename3 + (self2._created === 1 ? "" : self2._created - 1) + ext);
      }
      if (!self2.maxFiles || self2._created < self2.maxFiles) {
        return callback();
      }
      oldest = self2._created - self2.maxFiles;
      target = path4.join(self2.dirname, basename3 + (oldest !== 0 ? oldest : "") + ext + (self2.zippedArchive ? ".gz" : ""));
      fs.unlink(target, callback);
    };
    File.prototype._checkMaxFilesTailable = function(ext, basename3, callback) {
      var tasks = [], self2 = this;
      if (!this.maxFiles)
        return;
      for (var x = this.maxFiles - 1; x > 0; x--) {
        tasks.push(function(i2) {
          return function(cb) {
            var tmppath = path4.join(self2.dirname, basename3 + (i2 - 1) + ext + (self2.zippedArchive ? ".gz" : ""));
            fs.exists(tmppath, function(exists) {
              if (!exists) {
                return cb(null);
              }
              fs.rename(tmppath, path4.join(self2.dirname, basename3 + i2 + ext + (self2.zippedArchive ? ".gz" : "")), cb);
            });
          };
        }(x));
      }
      if (self2.zippedArchive) {
        self2._archive = path4.join(self2.dirname, basename3 + 1 + ext);
      }
      async.series(tasks, function(err) {
        fs.rename(
          path4.join(self2.dirname, basename3 + ext),
          path4.join(self2.dirname, basename3 + 1 + ext),
          callback
        );
      });
    };
    File.prototype._lazyDrain = function() {
      var self2 = this;
      if (!this._draining && this._stream) {
        this._draining = true;
        this._stream.once("drain", function() {
          self2._draining = false;
          self2.emit("logged");
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports2) {
    var util = require("util");
    var winston = require_winston();
    var http = require("http");
    var https = require("https");
    var Stream = require("stream").Stream;
    var Transport = require_transport().Transport;
    var Http = exports2.Http = function(options) {
      Transport.call(this, options);
      options = options || {};
      this.name = "http";
      this.ssl = !!options.ssl;
      this.host = options.host || "localhost";
      this.port = options.port;
      this.auth = options.auth;
      this.path = options.path || "";
      this.agent = options.agent;
      this.headers = options.headers || {};
      this.headers["content-type"] = "application/json";
      if (!this.port) {
        this.port = this.ssl ? 443 : 80;
      }
    };
    util.inherits(Http, winston.Transport);
    Http.prototype.name = "http";
    Http.prototype._request = function(options, callback) {
      options = options || {};
      var auth = options.auth || this.auth, path4 = options.path || this.path || "", req;
      delete options.auth;
      delete options.path;
      req = (this.ssl ? https : http).request({
        host: this.host,
        port: this.port,
        path: "/" + path4.replace(/^\//, ""),
        method: "POST",
        headers: this.headers,
        agent: this.agent,
        auth: auth ? auth.username + ":" + auth.password : ""
      });
      req.on("error", callback);
      req.on("response", function(res) {
        var body = "";
        res.on("data", function(chunk2) {
          body += chunk2;
        });
        res.on("end", function() {
          callback(null, res, body);
        });
        res.resume();
      });
      req.end(new Buffer.from(JSON.stringify(options), "utf8"));
    };
    Http.prototype.log = function(level, msg, meta, callback) {
      var self2 = this;
      if (typeof meta === "function") {
        callback = meta;
        meta = {};
      }
      var options = {
        method: "collect",
        params: {
          level,
          message: msg,
          meta
        }
      };
      if (meta) {
        if (meta.path) {
          options.path = meta.path;
          delete meta.path;
        }
        if (meta.auth) {
          options.auth = meta.auth;
          delete meta.auth;
        }
      }
      this._request(options, function(err, res) {
        if (res && res.statusCode !== 200) {
          err = new Error("HTTP Status Code: " + res.statusCode);
        }
        if (err)
          return callback(err);
        self2.emit("logged");
        if (callback)
          callback(null, true);
      });
    };
    Http.prototype.query = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      var self2 = this, options = this.normalizeQuery(options);
      options = {
        method: "query",
        params: options
      };
      if (options.params.path) {
        options.path = options.params.path;
        delete options.params.path;
      }
      if (options.params.auth) {
        options.auth = options.params.auth;
        delete options.params.auth;
      }
      this._request(options, function(err, res, body) {
        if (res && res.statusCode !== 200) {
          err = new Error("HTTP Status Code: " + res.statusCode);
        }
        if (err)
          return callback(err);
        if (typeof body === "string") {
          try {
            body = JSON.parse(body);
          } catch (e) {
            return callback(e);
          }
        }
        callback(null, body);
      });
    };
    Http.prototype.stream = function(options) {
      options = options || {};
      var self2 = this, stream2 = new Stream(), req, buff;
      stream2.destroy = function() {
        req.destroy();
      };
      options = {
        method: "stream",
        params: options
      };
      if (options.params.path) {
        options.path = options.params.path;
        delete options.params.path;
      }
      if (options.params.auth) {
        options.auth = options.params.auth;
        delete options.params.auth;
      }
      req = this._request(options);
      buff = "";
      req.on("data", function(data) {
        var data = (buff + data).split(/\n+/), l = data.length - 1, i2 = 0;
        for (; i2 < l; i2++) {
          try {
            stream2.emit("log", JSON.parse(data[i2]));
          } catch (e) {
            stream2.emit("error", e);
          }
        }
        buff = data[l];
      });
      req.on("error", function(err) {
        stream2.emit("error", err);
      });
      return stream2;
    };
  }
});

// node_modules/winston/lib/winston/transports/memory.js
var require_memory = __commonJS({
  "node_modules/winston/lib/winston/transports/memory.js"(exports2) {
    var events = require("events");
    var util = require("util");
    var common = require_common();
    var Transport = require_transport().Transport;
    var Memory = exports2.Memory = function(options) {
      Transport.call(this, options);
      options = options || {};
      this.errorOutput = [];
      this.writeOutput = [];
      this.json = options.json || false;
      this.colorize = options.colorize || false;
      this.prettyPrint = options.prettyPrint || false;
      this.timestamp = typeof options.timestamp !== "undefined" ? options.timestamp : false;
      this.showLevel = options.showLevel === void 0 ? true : options.showLevel;
      this.label = options.label || null;
      this.depth = options.depth || null;
      if (this.json) {
        this.stringify = options.stringify || function(obj) {
          return JSON.stringify(obj, null, 2);
        };
      }
    };
    util.inherits(Memory, Transport);
    Memory.prototype.name = "memory";
    Memory.prototype.log = function(level, msg, meta, callback) {
      if (this.silent) {
        return callback(null, true);
      }
      var self2 = this, output;
      output = common.log({
        colorize: this.colorize,
        json: this.json,
        level,
        message: msg,
        meta,
        stringify: this.stringify,
        timestamp: this.timestamp,
        prettyPrint: this.prettyPrint,
        raw: this.raw,
        label: this.label,
        depth: this.depth,
        formatter: this.formatter,
        humanReadableUnhandledException: this.humanReadableUnhandledException
      });
      if (level === "error" || level === "debug") {
        this.errorOutput.push(output);
      } else {
        this.writeOutput.push(output);
      }
      self2.emit("logged");
      callback(null, true);
    };
    Memory.prototype.clearLogs = function() {
      this.errorOutput = [];
      this.writeOutput = [];
    };
  }
});

// node_modules/winston/lib/winston/transports.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports.js"(exports2) {
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get: function() {
        return require_console().Console;
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get: function() {
        return require_file().File;
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get: function() {
        return require_http().Http;
      }
    });
    Object.defineProperty(exports2, "Memory", {
      configurable: true,
      enumerable: true,
      get: function() {
        return require_memory().Memory;
      }
    });
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception.js
var require_exception = __commonJS({
  "node_modules/winston/lib/winston/exception.js"(exports2) {
    var os = require("os");
    var stackTrace = require_stack_trace();
    var exception = exports2;
    exception.getAllInfo = function(err) {
      return {
        date: (/* @__PURE__ */ new Date()).toString(),
        process: exception.getProcessInfo(),
        os: exception.getOsInfo(),
        trace: exception.getTrace(err),
        stack: err.stack && err.stack.split("\n")
      };
    };
    exception.getProcessInfo = function() {
      return {
        pid: process.pid,
        uid: process.getuid ? process.getuid() : null,
        gid: process.getgid ? process.getgid() : null,
        cwd: process.cwd(),
        execPath: process.execPath,
        version: process.version,
        argv: process.argv,
        memoryUsage: process.memoryUsage()
      };
    };
    exception.getOsInfo = function() {
      return {
        loadavg: os.loadavg(),
        uptime: os.uptime()
      };
    };
    exception.getTrace = function(err) {
      var trace = err ? stackTrace.parse(err) : stackTrace.get();
      return trace.map(function(site) {
        return {
          column: site.getColumnNumber(),
          file: site.getFileName(),
          function: site.getFunctionName(),
          line: site.getLineNumber(),
          method: site.getMethodName(),
          native: site.isNative()
        };
      });
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports2) {
    var common = require_common();
    var winston = require_winston();
    var extend = require("util")._extend;
    var Container = exports2.Container = function(options) {
      this.loggers = {};
      this.options = options || {};
      this.default = {
        transports: [
          new winston.transports.Console({
            level: "silly",
            colorize: false
          })
        ]
      };
    };
    Container.prototype.get = Container.prototype.add = function(id, options) {
      var self2 = this, existing;
      if (!this.loggers[id]) {
        options = extend({}, options || this.options || this.default);
        existing = options.transports || this.options.transports;
        options.transports = existing ? existing.slice() : [];
        if (options.transports.length === 0 && (!options || !options["console"])) {
          options.transports.push(this.default.transports[0]);
        }
        Object.keys(options).forEach(function(key) {
          if (key === "transports" || key === "filters" || key === "rewriters") {
            return;
          }
          var name2 = common.capitalize(key);
          if (!winston.transports[name2]) {
            throw new Error("Cannot add unknown transport: " + name2);
          }
          var namedOptions = options[key];
          namedOptions.id = id;
          options.transports.push(new winston.transports[name2](namedOptions));
        });
        options.id = id;
        this.loggers[id] = new winston.Logger(options);
        this.loggers[id].on("close", function() {
          self2._delete(id);
        });
      }
      return this.loggers[id];
    };
    Container.prototype.has = function(id) {
      return !!this.loggers[id];
    };
    Container.prototype.close = function(id) {
      var self2 = this;
      function _close(id2) {
        if (!self2.loggers[id2]) {
          return;
        }
        self2.loggers[id2].close();
        self2._delete(id2);
      }
      return id ? _close(id) : Object.keys(this.loggers).forEach(function(id2) {
        _close(id2);
      });
    };
    Container.prototype._delete = function(id) {
      delete this.loggers[id];
    };
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports2) {
    var events = require("events");
    var util = require("util");
    var async = require_async();
    var config = require_config();
    var common = require_common();
    var exception = require_exception();
    var Stream = require("stream").Stream;
    var formatRegExp = /%[sdj%]/g;
    var Logger = exports2.Logger = function(options) {
      events.EventEmitter.call(this);
      this.configure(options);
    };
    util.inherits(Logger, events.EventEmitter);
    Logger.prototype.configure = function(options) {
      var self2 = this;
      if (Array.isArray(this._names) && this._names.length) {
        this.clear();
      }
      options = options || {};
      this.transports = {};
      this._names = [];
      if (options.transports) {
        options.transports.forEach(function(transport) {
          self2.add(transport, null, true);
        });
      }
      this.padLevels = options.padLevels || false;
      this.setLevels(options.levels);
      if (options.colors) {
        config.addColors(options.colors);
      }
      this.id = options.id || null;
      this.level = options.level || "info";
      this.emitErrs = options.emitErrs || false;
      this.stripColors = options.stripColors || false;
      this.exitOnError = typeof options.exitOnError !== "undefined" ? options.exitOnError : true;
      this.exceptionHandlers = {};
      this.profilers = {};
      ["rewriters", "filters"].forEach(function(kind) {
        self2[kind] = Array.isArray(options[kind]) ? options[kind] : [];
      });
      if (options.exceptionHandlers) {
        this.handleExceptions(options.exceptionHandlers);
      }
    };
    Logger.prototype.log = function(level) {
      var args = Array.prototype.slice.call(arguments, 1), self2 = this, transports;
      while (args[args.length - 1] === null) {
        args.pop();
      }
      var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
      function onError(err) {
        if (callback) {
          callback(err);
        } else if (self2.emitErrs) {
          self2.emit("error", err);
        }
      }
      if (this._names.length === 0) {
        return onError(new Error("Cannot log with no transports."));
      } else if (typeof self2.levels[level] === "undefined") {
        return onError(new Error("Unknown log level: " + level));
      }
      var targets = this._names.filter(function(name2) {
        var transport = self2.transports[name2];
        return transport.level && self2.levels[transport.level] >= self2.levels[level] || !transport.level && self2.levels[self2.level] >= self2.levels[level];
      });
      if (!targets.length) {
        if (callback) {
          callback();
        }
        return;
      }
      var msg, meta = {}, validMeta = false;
      var hasFormat = args && args[0] && args[0].match && args[0].match(formatRegExp) !== null;
      var tokens = hasFormat ? args[0].match(formatRegExp) : [];
      var ptokens = tokens.filter(function(t) {
        return t === "%%";
      });
      if (args.length - 1 - (tokens.length - ptokens.length) > 0 || args.length === 1) {
        meta = args[args.length - 1] || args;
        var metaType = Object.prototype.toString.call(meta);
        validMeta = metaType === "[object Object]" || metaType === "[object Error]" || metaType === "[object Array]";
        meta = validMeta ? args.pop() : {};
      }
      msg = util.format.apply(null, args);
      function finish(err) {
        if (callback) {
          if (err)
            return callback(err);
          callback(null, level, msg, meta);
        }
        callback = null;
        if (!err) {
          self2.emit("logged", level, msg, meta);
        }
      }
      if (this.padLevels) {
        msg = new Array(this.levelLength - level.length + 1).join(" ") + msg;
      }
      this.rewriters.forEach(function(rewriter) {
        meta = rewriter(level, msg, meta, self2);
      });
      this.filters.forEach(function(filter) {
        var filtered = filter(level, msg, meta, self2);
        if (typeof filtered === "string")
          msg = filtered;
        else {
          msg = filtered.msg;
          meta = filtered.meta;
        }
      });
      if (this.stripColors) {
        var code = /\u001b\[(\d+(;\d+)*)?m/g;
        msg = ("" + msg).replace(code, "");
      }
      function transportLog(name2, next) {
        var transport = self2.transports[name2];
        transport.log(level, msg, meta, function(err) {
          if (err) {
            err.transport = transport;
            finish(err);
            return next();
          }
          self2.emit("logging", transport, level, msg, meta);
          next();
        });
      }
      async.forEach(targets, transportLog, finish);
      return this;
    };
    Logger.prototype.query = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      var self2 = this, options = options || {}, results = {}, query = common.clone(options.query) || {}, transports;
      function queryTransport(transport, next) {
        if (options.query) {
          options.query = transport.formatQuery(query);
        }
        transport.query(options, function(err, results2) {
          if (err) {
            return next(err);
          }
          next(null, transport.formatResults(results2, options.format));
        });
      }
      function addResults(transport, next) {
        queryTransport(transport, function(err, result) {
          if (next) {
            result = err || result;
            if (result) {
              results[transport.name] = result;
            }
            next();
          }
          next = null;
        });
      }
      if (options.transport) {
        options.transport = options.transport.toLowerCase();
        return queryTransport(this.transports[options.transport], callback);
      }
      transports = this._names.map(function(name2) {
        return self2.transports[name2];
      }).filter(function(transport) {
        return !!transport.query;
      });
      async.forEach(transports, addResults, function() {
        callback(null, results);
      });
    };
    Logger.prototype.stream = function(options) {
      var self2 = this, options = options || {}, out = new Stream(), streams = [], transports;
      if (options.transport) {
        var transport = this.transports[options.transport];
        delete options.transport;
        if (transport && transport.stream) {
          return transport.stream(options);
        }
      }
      out._streams = streams;
      out.destroy = function() {
        var i2 = streams.length;
        while (i2--)
          streams[i2].destroy();
      };
      transports = this._names.map(function(name2) {
        return self2.transports[name2];
      }).filter(function(transport2) {
        return !!transport2.stream;
      });
      transports.forEach(function(transport2) {
        var stream2 = transport2.stream(options);
        if (!stream2)
          return;
        streams.push(stream2);
        stream2.on("log", function(log) {
          log.transport = log.transport || [];
          log.transport.push(transport2.name);
          out.emit("log", log);
        });
        stream2.on("error", function(err) {
          err.transport = err.transport || [];
          err.transport.push(transport2.name);
          out.emit("error", err);
        });
      });
      return out;
    };
    Logger.prototype.close = function() {
      var self2 = this;
      this._names.forEach(function(name2) {
        var transport = self2.transports[name2];
        if (transport && transport.close) {
          transport.close();
        }
      });
      this.emit("close");
    };
    Logger.prototype.handleExceptions = function() {
      var args = Array.prototype.slice.call(arguments), handlers = [], self2 = this;
      args.forEach(function(a) {
        if (Array.isArray(a)) {
          handlers = handlers.concat(a);
        } else {
          handlers.push(a);
        }
      });
      this.exceptionHandlers = this.exceptionHandlers || {};
      handlers.forEach(function(handler) {
        self2.exceptionHandlers[handler.name] = handler;
      });
      this._hnames = Object.keys(self2.exceptionHandlers);
      if (!this.catchExceptions) {
        this.catchExceptions = this._uncaughtException.bind(this);
        process.on("uncaughtException", this.catchExceptions);
      }
    };
    Logger.prototype.unhandleExceptions = function() {
      var self2 = this;
      if (this.catchExceptions) {
        Object.keys(this.exceptionHandlers).forEach(function(name2) {
          var handler = self2.exceptionHandlers[name2];
          if (handler.close) {
            handler.close();
          }
        });
        this.exceptionHandlers = {};
        Object.keys(this.transports).forEach(function(name2) {
          var transport = self2.transports[name2];
          if (transport.handleExceptions) {
            transport.handleExceptions = false;
          }
        });
        process.removeListener("uncaughtException", this.catchExceptions);
        this.catchExceptions = false;
      }
    };
    Logger.prototype.add = function(transport, options, created) {
      var instance = created ? transport : new transport(options);
      if (!instance.name && !instance.log) {
        throw new Error("Unknown transport with no log() method");
      } else if (this.transports[instance.name]) {
        throw new Error("Transport already attached: " + instance.name + ", assign a different name");
      }
      this.transports[instance.name] = instance;
      this._names = Object.keys(this.transports);
      instance._onError = this._onError.bind(this, instance);
      if (!created) {
        instance.on("error", instance._onError);
      }
      if (instance.handleExceptions && !this.catchExceptions) {
        this.handleExceptions();
      }
      return this;
    };
    Logger.prototype.clear = function() {
      Object.keys(this.transports).forEach(function(name2) {
        this.remove({ name: name2 });
      }, this);
    };
    Logger.prototype.remove = function(transport) {
      var name2 = typeof transport !== "string" ? transport.name || transport.prototype.name : transport;
      if (!this.transports[name2]) {
        throw new Error("Transport " + name2 + " not attached to this instance");
      }
      var instance = this.transports[name2];
      delete this.transports[name2];
      this._names = Object.keys(this.transports);
      if (instance.close) {
        instance.close();
      }
      if (instance._onError) {
        instance.removeListener("error", instance._onError);
      }
      return this;
    };
    Logger.prototype.startTimer = function() {
      return new ProfileHandler(this);
    };
    Logger.prototype.profile = function(id) {
      var now = Date.now(), then, args, msg, meta, callback;
      if (this.profilers[id]) {
        then = this.profilers[id];
        delete this.profilers[id];
        args = Array.prototype.slice.call(arguments);
        callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
        meta = typeof args[args.length - 1] === "object" ? args.pop() : {};
        msg = args.length === 2 ? args[1] : id;
        meta.durationMs = now - then;
        return this.info(msg, meta, callback);
      } else {
        this.profilers[id] = now;
      }
      return this;
    };
    Logger.prototype.setLevels = function(target) {
      return common.setLevels(this, this.levels, target);
    };
    Logger.prototype.cli = function() {
      this.padLevels = true;
      this.setLevels(config.cli.levels);
      config.addColors(config.cli.colors);
      if (this.transports.console) {
        this.transports.console.colorize = this.transports.console.colorize || true;
        this.transports.console.timestamp = this.transports.console.timestamp || false;
      }
      return this;
    };
    Logger.prototype._uncaughtException = function(err) {
      var self2 = this, responded = false, info = exception.getAllInfo(err), handlers = this._getExceptionHandlers(), timeout, doExit;
      doExit = typeof this.exitOnError === "function" ? this.exitOnError(err) : this.exitOnError;
      function logAndWait(transport, next) {
        transport.logException("uncaughtException: " + (err.message || err), info, next, err);
      }
      function gracefulExit() {
        if (doExit && !responded) {
          clearTimeout(timeout);
          responded = true;
          process.exit(1);
        }
      }
      if (!handlers || handlers.length === 0) {
        return gracefulExit();
      }
      async.forEach(handlers, logAndWait, gracefulExit);
      if (doExit) {
        timeout = setTimeout(gracefulExit, 3e3);
      }
    };
    Logger.prototype._getExceptionHandlers = function() {
      var self2 = this;
      return this._hnames.map(function(name2) {
        return self2.exceptionHandlers[name2];
      }).concat(this._names.map(function(name2) {
        return self2.transports[name2].handleExceptions && self2.transports[name2];
      })).filter(Boolean);
    };
    Logger.prototype._onError = function(transport, err) {
      if (this.emitErrs) {
        this.emit("error", err, transport);
      }
    };
    function ProfileHandler(logger) {
      this.logger = logger;
      this.start = Date.now();
    }
    ProfileHandler.prototype.done = function(msg) {
      var args = Array.prototype.slice.call(arguments), callback = typeof args[args.length - 1] === "function" ? args.pop() : null, meta = typeof args[args.length - 1] === "object" ? args.pop() : {};
      meta.duration = Date.now() - this.start + "ms";
      return this.logger.info(msg, meta, callback);
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports2) {
    var winston = exports2;
    winston.version = require_package().version;
    winston.transports = require_transports();
    var common = require_common();
    winston.hash = common.hash;
    winston.clone = common.clone;
    winston.longestElement = common.longestElement;
    winston.exception = require_exception();
    winston.config = require_config();
    winston.addColors = winston.config.addColors;
    winston.Container = require_container().Container;
    winston.Logger = require_logger().Logger;
    winston.Transport = require_transport().Transport;
    winston.loggers = new winston.Container();
    var defaultLogger = new winston.Logger({
      transports: [new winston.transports.Console()]
    });
    var methods = [
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "extend",
      "cli",
      "handleExceptions",
      "unhandleExceptions",
      "configure"
    ];
    winston.padLevels = false;
    common.setLevels(winston, null, defaultLogger.levels);
    methods.forEach(function(method) {
      winston[method] = function() {
        return defaultLogger[method].apply(defaultLogger, arguments);
      };
    });
    winston.cli = function() {
      winston.padLevels = true;
      common.setLevels(winston, defaultLogger.levels, winston.config.cli.levels);
      defaultLogger.setLevels(winston.config.cli.levels);
      winston.config.addColors(winston.config.cli.colors);
      if (defaultLogger.transports.console) {
        defaultLogger.transports.console.colorize = true;
        defaultLogger.transports.console.timestamp = false;
      }
      return winston;
    };
    winston.setLevels = function(target) {
      common.setLevels(winston, defaultLogger.levels, target);
      defaultLogger.setLevels(target);
    };
    Object.defineProperty(winston, "level", {
      get: function() {
        return defaultLogger.level;
      },
      set: function(val) {
        defaultLogger.level = val;
        Object.keys(defaultLogger.transports).forEach(function(key) {
          defaultLogger.transports[key].level = val;
        });
      }
    });
    ["emitErrs", "exitOnError", "padLevels", "levelLength", "stripColors"].forEach(function(prop) {
      Object.defineProperty(winston, prop, {
        get: function() {
          return defaultLogger[prop];
        },
        set: function(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(winston, "default", {
      get: function() {
        return {
          transports: defaultLogger.transports,
          exceptionHandlers: defaultLogger.exceptionHandlers
        };
      }
    });
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles2 = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors2 = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream2) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream2 && !stream2.isTTY && forceColor !== true) {
        return 0;
      }
      var min2 = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min2;
      }
      return min2;
    }
    function getSupportLevel(stream2) {
      var level = supportsColor(stream2);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap2 = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo2 = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i2) {
          bool = i2 === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i2 = 0; i2 <= counts[index]; i2++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i2, exploded) {
        if (letter === " ")
          return letter;
        switch (i2 % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i2, exploded) {
        return i2 % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i2, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i2++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random2 = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i2, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors2 = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles2();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors2().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i2 = nestedStyles.length;
      while (i2--) {
        var code = ansiStyles[nestedStyles[i2]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i2 in theme[style2]) {
                out = colors[theme[style2][i2]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap2();
    colors.zalgo = require_zalgo2();
    colors.maps = {};
    colors.maps.america = require_america2()(colors);
    colors.maps.zebra = require_zebra2()(colors);
    colors.maps.rainbow = require_rainbow2()(colors);
    colors.maps.random = require_random2()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe2 = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors2();
    module2["exports"] = colors;
  }
});

// node_modules/prompt/package.json
var require_package2 = __commonJS({
  "node_modules/prompt/package.json"(exports2, module2) {
    module2.exports = {
      name: "prompt",
      version: "1.3.0",
      description: "A beautiful command-line prompt for node.js",
      author: "Nodejitsu Inc. <info@nodejitsu.com>",
      maintainers: [
        "indexzero <charlie@nodejitsu.com>",
        "jesusabdullah <josh@nodejitsu.com>"
      ],
      repository: {
        type: "git",
        url: "http://github.com/flatiron/prompt.git"
      },
      keywords: [
        "prompt",
        "command-line",
        "customize",
        "validation"
      ],
      dependencies: {
        "@colors/colors": "1.5.0",
        async: "3.2.3",
        read: "1.0.x",
        revalidator: "0.1.x",
        winston: "2.x"
      },
      devDependencies: {
        eslint: "^7.32.0",
        vows: "^0.7.0"
      },
      main: "./lib/prompt",
      scripts: {
        test: "vows test/prompt-test.js --spec",
        "test-all": "vows --spec"
      },
      license: "MIT",
      engines: {
        node: ">= 6.0.0"
      }
    };
  }
});

// node_modules/prompt/lib/prompt.js
var require_prompt = __commonJS({
  "node_modules/prompt/lib/prompt.js"(exports2, module2) {
    var events = require("events");
    var readline = require("readline");
    var eachSeries = require_eachSeries();
    var rejectSeries = require_rejectSeries();
    var read = require_read();
    var validate = require_revalidator().validate;
    var winston = require_winston();
    var colors = require_safe2();
    readline.Interface.prototype.setPrompt = function(prompt3, length) {
      this._prompt = prompt3;
      if (length) {
        this._promptLength = length;
      } else {
        var lines = prompt3.split(/[\r\n]/);
        var lastLine = lines[lines.length - 1];
        this._promptLength = lastLine.replace(/\u001b\[(\d+(;\d+)*)?m/g, "").length;
      }
    };
    module2.exports.version = require_package2().version;
    var stdin;
    var stdout;
    var history = [];
    var prompt2 = module2.exports = Object.create(events.EventEmitter.prototype);
    var logger = prompt2.logger = new winston.Logger({
      transports: [new winston.transports.Console()]
    });
    prompt2.started = false;
    prompt2.paused = false;
    prompt2.stopped = true;
    prompt2.allowEmpty = false;
    prompt2.message = "prompt";
    prompt2.delimiter = ": ";
    prompt2.colors = true;
    prompt2.properties = {};
    logger.cli();
    prompt2.start = function(options) {
      if (prompt2.started) {
        return;
      }
      options = options || {};
      stdin = options.stdin || process.stdin;
      stdout = options.stdout || process.stdout;
      prompt2.memory = options.memory || 10;
      prompt2.allowEmpty = options.allowEmpty || false;
      prompt2.message = options.message || prompt2.message;
      prompt2.delimiter = options.delimiter || prompt2.delimiter;
      prompt2.colors = options.colors || prompt2.colors;
      if (!options.noHandleSIGINT) {
        if (process.platform !== "win32") {
          process.on("SIGINT", function() {
            stdout.write("\n");
            process.exit(1);
          });
        } else {
          stdin.on("keypress", function(char, key) {
            if (key && key.ctrl && key.name == "c") {
              stdout.write("\n");
              process.emit("SIGINT");
              process.exit(1);
            }
          });
        }
      }
      prompt2.emit("start");
      prompt2.started = true;
      prompt2.stopped = false;
      return prompt2;
    };
    prompt2.pause = function() {
      if (!prompt2.started || prompt2.stopped || prompt2.paused) {
        return;
      }
      stdin.pause();
      prompt2.emit("pause");
      prompt2.paused = true;
      return prompt2;
    };
    prompt2.stop = function() {
      if (prompt2.stopped || !prompt2.started) {
        return;
      }
      stdin.destroy();
      prompt2.emit("stop");
      prompt2.stopped = true;
      prompt2.started = false;
      prompt2.paused = false;
      return prompt2;
    };
    prompt2.resume = function() {
      if (!prompt2.started || !prompt2.paused) {
        return;
      }
      stdin.resume();
      prompt2.emit("resume");
      prompt2.paused = false;
      return prompt2;
    };
    prompt2.history = function(search) {
      if (typeof search === "number") {
        return history[search] || {};
      }
      var names = history.map(function(pair) {
        return typeof pair.property === "string" ? pair.property : pair.property.name;
      });
      if (!~names.indexOf(search)) {
        return null;
      }
      return history.filter(function(pair) {
        return typeof pair.property === "string" ? pair.property === search : pair.property.name === search;
      })[0];
    };
    prompt2.get = function(schema, callback) {
      if (typeof callback === "function")
        return prompt2._get(schema, callback);
      return new Promise(function(resolve5, reject2) {
        prompt2._get(schema, function(err, result) {
          return err ? reject2(err) : resolve5(result);
        });
      });
    };
    prompt2._get = function(schema, callback) {
      function untangle(schema2, path4) {
        var results = [];
        path4 = path4 || [];
        if (schema2.properties) {
          Object.keys(schema2.properties).forEach(function(key) {
            var obj = {};
            obj[key] = schema2.properties[key];
            results = results.concat(untangle(obj[key], path4.concat(key)));
          });
          return results;
        }
        return {
          path: path4,
          schema: schema2
        };
      }
      function iterate(schema2, get, done) {
        var iterator = [], result = {};
        if (typeof schema2 === "string") {
          iterator.push({
            path: [schema2],
            schema: prompt2.properties[schema2.toLowerCase()] || {}
          });
        } else if (Array.isArray(schema2)) {
          iterator = schema2.map(function(element) {
            if (typeof element === "string") {
              return {
                path: [element],
                schema: prompt2.properties[element.toLowerCase()] || {}
              };
            } else if (element.properties) {
              return {
                path: [Object.keys(element.properties)[0]],
                schema: element.properties[Object.keys(element.properties)[0]]
              };
            } else if (element.path && element.schema) {
              return element;
            } else {
              return {
                path: [element.name || "question"],
                schema: element
              };
            }
          });
        } else if (schema2.properties) {
          iterator = untangle(schema2);
        } else {
          iterator = [{
            schema: schema2.schema ? schema2.schema : schema2,
            path: schema2.path || [schema2.name || "question"]
          }];
        }
        eachSeries(iterator, function(branch, next) {
          get(branch, function assembler(err, line) {
            if (err) {
              return next(err);
            }
            function build(path4, line2) {
              var obj = {};
              if (path4.length) {
                obj[path4[0]] = build(path4.slice(1), line2);
                return obj;
              }
              return line2;
            }
            function attach(obj, attr) {
              var keys;
              if (typeof attr !== "object" || attr instanceof Array) {
                return attr;
              }
              keys = Object.keys(attr);
              if (keys.length) {
                if (!obj[keys[0]]) {
                  obj[keys[0]] = {};
                }
                obj[keys[0]] = attach(obj[keys[0]], attr[keys[0]]);
              }
              return obj;
            }
            result = attach(result, build(branch.path, line));
            next();
          });
        }, function(err) {
          return err ? done(err) : done(null, result);
        });
      }
      iterate(schema, function get(target, next) {
        prompt2.getInput(target, function(err, line) {
          return err ? next(err) : next(null, line);
        });
      }, callback);
      return prompt2;
    };
    prompt2.confirm = function() {
      var args = Array.prototype.slice.call(arguments), msg = args.shift(), callback = args.pop(), opts = args.shift(), vars = !Array.isArray(msg) ? [msg] : msg, RX_Y = /^[yt]{1}/i, RX_YN = /^[yntf]{1}/i;
      function confirm(target, next) {
        var yes = target.yes || RX_Y, options = {
          description: typeof target === "string" ? target : target.description || "yes/no",
          pattern: target.pattern || RX_YN,
          name: "confirm",
          message: target.message || "yes/no"
        };
        for (var k in opts || {}) {
          if (opts.hasOwnProperty(k)) {
            options[k] = opts[k];
          }
        }
        prompt2.get([options], function(err, result) {
          next(null, err ? false : yes.test(result[options.name]));
        });
      }
      rejectSeries(vars, confirm, function(err, result) {
        callback(null, result.length === 0);
      });
    };
    var tmp = [];
    prompt2.getInput = function(prop, callback) {
      var schema = prop.schema || prop, propName = prop.path && prop.path.join(":") || prop, storedSchema = prompt2.properties[propName.toLowerCase()], delim = prompt2.delimiter, defaultLine, against, hidden, length, valid, name2, raw, msg;
      if (schema instanceof Object && !Object.keys(schema).length && typeof storedSchema !== "undefined") {
        schema = storedSchema;
      }
      if (typeof prop === "string" && !storedSchema) {
        schema = {};
      }
      schema = convert(schema);
      defaultLine = schema.default;
      name2 = prop.description || schema.description || propName;
      raw = prompt2.colors ? [colors.grey(name2), colors.grey(delim)] : [name2, delim];
      if (prompt2.message)
        raw.unshift(prompt2.message, delim);
      prop = {
        schema,
        path: propName.split(":")
      };
      if (!schema.properties) {
        schema = function() {
          var obj = { properties: {} };
          obj.properties[propName] = schema;
          return obj;
        }();
      }
      if (prompt2.override && prompt2.override.hasOwnProperty(propName)) {
        if (prompt2._performValidation(name2, prop, prompt2.override, schema, -1, callback)) {
          return callback(null, prompt2.override[propName]);
        }
        delete prompt2.override[propName];
      }
      if (typeof prop.schema.ask === "function" && !prop.schema.ask()) {
        return callback(null, prop.schema.default || "");
      }
      var type = (schema.properties && schema.properties[propName] && schema.properties[propName].type || "").toLowerCase().trim(), wait2 = type === "array";
      if (type === "array") {
        length = prop.schema.maxItems;
        if (length) {
          msg = (tmp.length + 1).toString() + "/" + length.toString();
        } else {
          msg = (tmp.length + 1).toString();
        }
        msg += delim;
        raw.push(prompt2.colors ? colors.grey(msg) : msg);
      }
      length = raw.join("").length;
      msg = raw.join("");
      if (schema.help) {
        schema.help.forEach(function(line) {
          logger.help(line);
        });
      }
      prompt2.emit("prompt", prop);
      if (typeof defaultLine === "function") {
        defaultLine = defaultLine();
      }
      if (typeof defaultLine === "undefined") {
        defaultLine = "";
      }
      defaultLine = defaultLine.toString();
      read({
        prompt: msg,
        silent: prop.schema && prop.schema.hidden,
        replace: prop.schema && prop.schema.replace,
        default: defaultLine,
        input: stdin,
        output: stdout
      }, function(err, line) {
        if (err && wait2 === false) {
          return callback(err);
        }
        var against2 = {}, numericInput, isValid;
        if (line !== "") {
          if (schema.properties[propName]) {
            var type2 = (schema.properties[propName].type || "").toLowerCase().trim() || void 0;
            if (type2 === "number" || type2 === "integer") {
              line = Number(line);
            }
            if (type2 == "boolean") {
              if (line.toLowerCase() === "true" || line.toLowerCase() === "t") {
                line = true;
              } else if (line.toLowerCase() === "false" || line.toLowerCase() === "f") {
                line = false;
              }
            }
            if (type2 == "array") {
              var length2 = prop.schema.maxItems;
              if (err) {
                if (err.message == "canceled") {
                  wait2 = false;
                  stdout.write("\n");
                }
              } else {
                if (length2) {
                  if (tmp.length + 1 < length2) {
                    isValid = false;
                    wait2 = true;
                  } else {
                    isValid = true;
                    wait2 = false;
                  }
                } else {
                  isValid = false;
                  wait2 = true;
                }
                tmp.push(line);
              }
              line = tmp;
            }
          }
          against2[propName] = line;
        }
        if (prop && prop.schema.before) {
          line = prop.schema.before(line);
        }
        if (isValid === void 0)
          isValid = prompt2._performValidation(name2, prop, against2, schema, line, callback);
        if (!isValid) {
          return prompt2.getInput(prop, callback);
        }
        logger.input(line.yellow);
        prompt2._remember(propName, line);
        callback(null, line);
        tmp = [];
      });
    };
    prompt2._performValidation = function(name2, prop, against, schema, line, callback) {
      var numericInput, valid, msg;
      try {
        valid = validate(against, schema);
      } catch (err) {
        return line !== -1 ? callback(err) : false;
      }
      if (!valid.valid) {
        if (prop.schema.message) {
          logger.error(prop.schema.message);
        } else {
          msg = line !== -1 ? "Invalid input for " : "Invalid command-line input for ";
          if (prompt2.colors) {
            logger.error(msg + colors.grey(name2));
          } else {
            logger.error(msg + name2);
          }
        }
        prompt2.emit("invalid", prop, line);
      }
      return valid.valid;
    };
    prompt2.addProperties = function(obj, properties, callback) {
      properties = properties.filter(function(prop) {
        return typeof obj[prop] === "undefined";
      });
      if (properties.length === 0) {
        return callback(null, obj);
      }
      prompt2.get(properties, function(err, results) {
        if (err) {
          return callback(err);
        } else if (!results) {
          return callback(null, obj);
        }
        function putNested(obj2, path4, value2) {
          var last = obj2, key;
          while (path4.length > 1) {
            key = path4.shift();
            if (!last[key]) {
              last[key] = {};
            }
            last = last[key];
          }
          last[path4.shift()] = value2;
        }
        Object.keys(results).forEach(function(key) {
          putNested(obj, key.split("."), results[key]);
        });
        callback(null, obj);
      });
      return prompt2;
    };
    prompt2._remember = function(property, value2) {
      history.unshift({
        property,
        value: value2
      });
      if (history.length > prompt2.memory) {
        history.splice(prompt2.memory, history.length - prompt2.memory);
      }
    };
    function convert(schema) {
      var newProps = Object.keys(validate.messages), newSchema = false, key;
      newProps = newProps.concat(["description", "dependencies"]);
      for (key in schema) {
        if (newProps.indexOf(key) > 0) {
          newSchema = true;
          break;
        }
      }
      if (!newSchema || schema.validator || schema.warning || typeof schema.empty !== "undefined") {
        if (typeof schema.message !== "undefined") {
          schema.description = schema.message;
        }
        if (typeof schema.warning !== "undefined") {
          schema.message = schema.warning;
        }
        if (typeof schema.validator === "function") {
          schema.conform = schema.validator;
        } else {
          schema.pattern = schema.validator;
        }
        if (typeof schema.empty !== "undefined") {
          schema.required = !schema.empty;
        }
        delete schema.warning;
        delete schema.validator;
        delete schema.empty;
      }
      return schema;
    }
  }
});

// node_modules/@jimp/utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/@jimp/utils/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isNodePattern = isNodePattern;
    exports2.scan = scan;
    exports2.scanIterator = scanIterator;
    exports2.throwError = throwError;
    function isNodePattern(cb) {
      if (typeof cb === "undefined") {
        return false;
      }
      if (typeof cb !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return true;
    }
    function throwError(error, cb) {
      if (typeof error === "string") {
        error = new Error(error);
      }
      if (typeof cb === "function") {
        return cb.call(this, error);
      }
      throw error;
    }
    function scan(image2, x, y, w, h, f) {
      x = Math.round(x);
      y = Math.round(y);
      w = Math.round(w);
      h = Math.round(h);
      for (let _y = y; _y < y + h; _y++) {
        for (let _x = x; _x < x + w; _x++) {
          const idx = image2.bitmap.width * _y + _x << 2;
          f.call(image2, _x, _y, idx);
        }
      }
      return image2;
    }
    function* scanIterator(image2, x, y, w, h) {
      x = Math.round(x);
      y = Math.round(y);
      w = Math.round(w);
      h = Math.round(h);
      for (let _y = y; _y < y + h; _y++) {
        for (let _x = x; _x < x + w; _x++) {
          const idx = image2.bitmap.width * _y + _x << 2;
          yield {
            x: _x,
            y: _y,
            idx,
            image: image2
          };
        }
      }
    }
  }
});

// node_modules/any-base/src/converter.js
var require_converter = __commonJS({
  "node_modules/any-base/src/converter.js"(exports2, module2) {
    "use strict";
    function Converter(srcAlphabet, dstAlphabet) {
      if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error("Bad alphabet");
      }
      this.srcAlphabet = srcAlphabet;
      this.dstAlphabet = dstAlphabet;
    }
    Converter.prototype.convert = function(number) {
      var i2, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = typeof number === "string" ? "" : [];
      if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
      }
      if (this.srcAlphabet === this.dstAlphabet) {
        return number;
      }
      for (i2 = 0; i2 < length; i2++) {
        numberMap[i2] = this.srcAlphabet.indexOf(number[i2]);
      }
      do {
        divide = 0;
        newlen = 0;
        for (i2 = 0; i2 < length; i2++) {
          divide = divide * fromBase + numberMap[i2];
          if (divide >= toBase) {
            numberMap[newlen++] = parseInt(divide / toBase, 10);
            divide = divide % toBase;
          } else if (newlen > 0) {
            numberMap[newlen++] = 0;
          }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
      } while (newlen !== 0);
      return result;
    };
    Converter.prototype.isValid = function(number) {
      var i2 = 0;
      for (; i2 < number.length; ++i2) {
        if (this.srcAlphabet.indexOf(number[i2]) === -1) {
          return false;
        }
      }
      return true;
    };
    module2.exports = Converter;
  }
});

// node_modules/any-base/index.js
var require_any_base = __commonJS({
  "node_modules/any-base/index.js"(exports2, module2) {
    var Converter = require_converter();
    function anyBase(srcAlphabet, dstAlphabet) {
      var converter = new Converter(srcAlphabet, dstAlphabet);
      return function(number) {
        return converter.convert(number);
      };
    }
    anyBase.BIN = "01";
    anyBase.OCT = "01234567";
    anyBase.DEC = "0123456789";
    anyBase.HEX = "0123456789abcdef";
    module2.exports = anyBase;
  }
});

// node_modules/pixelmatch/index.js
var require_pixelmatch = __commonJS({
  "node_modules/pixelmatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pixelmatch;
    function pixelmatch(img1, img2, output, width, height, options) {
      if (!options)
        options = {};
      var threshold = options.threshold === void 0 ? 0.1 : options.threshold;
      var maxDelta = 35215 * threshold * threshold, diff = 0;
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          var pos = (y * width + x) * 4;
          var delta = colorDelta(img1, img2, pos, pos);
          if (delta > maxDelta) {
            if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
              if (output)
                drawPixel(output, pos, 255, 255, 0);
            } else {
              if (output)
                drawPixel(output, pos, 255, 0, 0);
              diff++;
            }
          } else if (output) {
            var val = blend(grayPixel(img1, pos), 0.1);
            drawPixel(output, pos, val, val, val);
          }
        }
      }
      return diff;
    }
    function antialiased(img, x1, y1, width, height, img2) {
      var x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = (y1 * width + x1) * 4, zeroes = 0, positives = 0, negatives = 0, min2 = 0, max2 = 0, minX, minY, maxX, maxY;
      for (var x = x0; x <= x2; x++) {
        for (var y = y0; y <= y2; y++) {
          if (x === x1 && y === y1)
            continue;
          var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
          if (delta === 0)
            zeroes++;
          else if (delta < 0)
            negatives++;
          else if (delta > 0)
            positives++;
          if (zeroes > 2)
            return false;
          if (!img2)
            continue;
          if (delta < min2) {
            min2 = delta;
            minX = x;
            minY = y;
          }
          if (delta > max2) {
            max2 = delta;
            maxX = x;
            maxY = y;
          }
        }
      }
      if (!img2)
        return true;
      if (negatives === 0 || positives === 0)
        return false;
      return !antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height);
    }
    function colorDelta(img1, img2, k, m, yOnly) {
      var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
      if (yOnly)
        return y;
      var i2 = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
      return 0.5053 * y * y + 0.299 * i2 * i2 + 0.1957 * q * q;
    }
    function rgb2y(r, g, b) {
      return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
    }
    function rgb2i(r, g, b) {
      return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
    }
    function rgb2q(r, g, b) {
      return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
    }
    function blend(c, a) {
      return 255 + (c - 255) * a;
    }
    function drawPixel(output, pos, r, g, b) {
      output[pos + 0] = r;
      output[pos + 1] = g;
      output[pos + 2] = b;
      output[pos + 3] = 255;
    }
    function grayPixel(img, i2) {
      var a = img[i2 + 3] / 255, r = blend(img[i2 + 0], a), g = blend(img[i2 + 1], a), b = blend(img[i2 + 2], a);
      return rgb2y(r, g, b);
    }
  }
});

// node_modules/tinycolor2/cjs/tinycolor.js
var require_tinycolor = __commonJS({
  "node_modules/tinycolor2/cjs/tinycolor.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.tinycolor = factory());
    })(exports2, function() {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      var trimLeft = /^\s+/;
      var trimRight = /\s+$/;
      function tinycolor(color, opts) {
        color = color ? color : "";
        opts = opts || {};
        if (color instanceof tinycolor) {
          return color;
        }
        if (!(this instanceof tinycolor)) {
          return new tinycolor(color, opts);
        }
        var rgb = inputToRGB(color);
        this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;
        if (this._r < 1)
          this._r = Math.round(this._r);
        if (this._g < 1)
          this._g = Math.round(this._g);
        if (this._b < 1)
          this._b = Math.round(this._b);
        this._ok = rgb.ok;
      }
      tinycolor.prototype = {
        isDark: function isDark() {
          return this.getBrightness() < 128;
        },
        isLight: function isLight() {
          return !this.isDark();
        },
        isValid: function isValid() {
          return this._ok;
        },
        getOriginalInput: function getOriginalInput() {
          return this._originalInput;
        },
        getFormat: function getFormat() {
          return this._format;
        },
        getAlpha: function getAlpha() {
          return this._a;
        },
        getBrightness: function getBrightness() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        },
        getLuminance: function getLuminance() {
          var rgb = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B;
          RsRGB = rgb.r / 255;
          GsRGB = rgb.g / 255;
          BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928)
            R = RsRGB / 12.92;
          else
            R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          if (GsRGB <= 0.03928)
            G = GsRGB / 12.92;
          else
            G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          if (BsRGB <= 0.03928)
            B = BsRGB / 12.92;
          else
            B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function setAlpha(value2) {
          this._a = boundAlpha(value2);
          this._roundA = Math.round(100 * this._a) / 100;
          return this;
        },
        toHsv: function toHsv() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return {
            h: hsv.h * 360,
            s: hsv.s,
            v: hsv.v,
            a: this._a
          };
        },
        toHsvString: function toHsvString() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function toHsl() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          return {
            h: hsl.h * 360,
            s: hsl.s,
            l: hsl.l,
            a: this._a
          };
        },
        toHslString: function toHslString() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
          return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function toHex(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function toHexString(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function toHex8(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function toHex8String(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function toRgb() {
          return {
            r: Math.round(this._r),
            g: Math.round(this._g),
            b: Math.round(this._b),
            a: this._a
          };
        },
        toRgbString: function toRgbString() {
          return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function toPercentageRgb() {
          return {
            r: Math.round(bound01(this._r, 255) * 100) + "%",
            g: Math.round(bound01(this._g, 255) * 100) + "%",
            b: Math.round(bound01(this._b, 255) * 100) + "%",
            a: this._a
          };
        },
        toPercentageRgbString: function toPercentageRgbString() {
          return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function toName() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function toFilter(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function toString(format) {
          var formatSet = !!format;
          format = format || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
          if (needsAlphaFormat) {
            if (format === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
          }
          if (format === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format === "name") {
            formattedString = this.toName();
          }
          if (format === "hsl") {
            formattedString = this.toHslString();
          }
          if (format === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function clone() {
          return tinycolor(this.toString());
        },
        _applyModification: function _applyModification(fn, args) {
          var color = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color._r;
          this._g = color._g;
          this._b = color._b;
          this.setAlpha(color._a);
          return this;
        },
        lighten: function lighten() {
          return this._applyModification(_lighten, arguments);
        },
        brighten: function brighten() {
          return this._applyModification(_brighten, arguments);
        },
        darken: function darken() {
          return this._applyModification(_darken, arguments);
        },
        desaturate: function desaturate() {
          return this._applyModification(_desaturate, arguments);
        },
        saturate: function saturate() {
          return this._applyModification(_saturate, arguments);
        },
        greyscale: function greyscale() {
          return this._applyModification(_greyscale, arguments);
        },
        spin: function spin() {
          return this._applyModification(_spin, arguments);
        },
        _applyCombination: function _applyCombination(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function analogous() {
          return this._applyCombination(_analogous, arguments);
        },
        complement: function complement() {
          return this._applyCombination(_complement, arguments);
        },
        monochromatic: function monochromatic() {
          return this._applyCombination(_monochromatic, arguments);
        },
        splitcomplement: function splitcomplement() {
          return this._applyCombination(_splitcomplement, arguments);
        },
        // Disabled until https://github.com/bgrins/TinyColor/issues/254
        // polyad: function (number) {
        //   return this._applyCombination(polyad, [number]);
        // },
        triad: function triad() {
          return this._applyCombination(polyad, [3]);
        },
        tetrad: function tetrad() {
          return this._applyCombination(polyad, [4]);
        }
      };
      tinycolor.fromRatio = function(color, opts) {
        if (_typeof(color) == "object") {
          var newColor = {};
          for (var i2 in color) {
            if (color.hasOwnProperty(i2)) {
              if (i2 === "a") {
                newColor[i2] = color[i2];
              } else {
                newColor[i2] = convertToPercentage(color[i2]);
              }
            }
          }
          color = newColor;
        }
        return tinycolor(color, opts);
      };
      function inputToRGB(color) {
        var rgb = {
          r: 0,
          g: 0,
          b: 0
        };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;
        if (typeof color == "string") {
          color = stringInputToObject(color);
        }
        if (_typeof(color) == "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
          } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
          }
          if (color.hasOwnProperty("a")) {
            a = color.a;
          }
        }
        a = boundAlpha(a);
        return {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
        var h, s, l = (max2 + min2) / 2;
        if (max2 == min2) {
          h = s = 0;
        } else {
          var d = max2 - min2;
          s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          switch (max2) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return {
          h,
          s,
          l
        };
      }
      function hslToRgb(h, s, l) {
        var r, g, b;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        function hue2rgb(p2, q2, t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 2 / 3)
            return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        }
        if (s === 0) {
          r = g = b = l;
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return {
          r: r * 255,
          g: g * 255,
          b: b * 255
        };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
        var h, s, v = max2;
        var d = max2 - min2;
        s = max2 === 0 ? 0 : d / max2;
        if (max2 == min2) {
          h = 0;
        } else {
          switch (max2) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return {
          h,
          s,
          v
        };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i2 = Math.floor(h), f = h - i2, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i2 % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
        return {
          r: r * 255,
          g: g * 255,
          b: b * 255
        };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }
        return hex.join("");
      }
      function rgbaToArgbHex(r, g, b, a) {
        var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
        return hex.join("");
      }
      tinycolor.equals = function(color1, color2) {
        if (!color1 || !color2)
          return false;
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
      };
      tinycolor.random = function() {
        return tinycolor.fromRatio({
          r: Math.random(),
          g: Math.random(),
          b: Math.random()
        });
      };
      function _desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
      }
      function _saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
      }
      function _greyscale(color) {
        return tinycolor(color).desaturate(100);
      }
      function _lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
      }
      function _brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor(color).toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return tinycolor(rgb);
      }
      function _darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
      }
      function _spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
      }
      function _complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
      }
      function polyad(color, number) {
        if (isNaN(number) || number <= 0) {
          throw new Error("Argument to polyad must be a positive number");
        }
        var hsl = tinycolor(color).toHsl();
        var result = [tinycolor(color)];
        var step = 360 / number;
        for (var i2 = 1; i2 < number; i2++) {
          result.push(tinycolor({
            h: (hsl.h + i2 * step) % 360,
            s: hsl.s,
            l: hsl.l
          }));
        }
        return result;
      }
      function _splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [tinycolor(color), tinycolor({
          h: (h + 72) % 360,
          s: hsl.s,
          l: hsl.l
        }), tinycolor({
          h: (h + 216) % 360,
          s: hsl.s,
          l: hsl.l
        })];
      }
      function _analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(tinycolor(hsl));
        }
        return ret;
      }
      function _monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor({
            h,
            s,
            v
          }));
          v = (v + modification) % 1;
        }
        return ret;
      }
      tinycolor.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();
        var p = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor(rgba);
      };
      tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;
        for (var i2 = 0; i2 < colorList.length; i2++) {
          readability = tinycolor.readability(baseColor, colorList[i2]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i2]);
          }
        }
        if (tinycolor.isReadable(baseColor, bestColor, {
          level,
          size
        }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor.hexNames = flip(names);
      function flip(o) {
        var flipped = {};
        for (var i2 in o) {
          if (o.hasOwnProperty(i2)) {
            flipped[o[i2]] = i2;
          }
        }
        return flipped;
      }
      function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
        }
        return a;
      }
      function bound01(n, max2) {
        if (isOnePointZero(n))
          n = "100%";
        var processPercent = isPercentage(n);
        n = Math.min(max2, Math.max(0, parseFloat(n)));
        if (processPercent) {
          n = parseInt(n * max2, 10) / 100;
        }
        if (Math.abs(n - max2) < 1e-6) {
          return 1;
        }
        return n % max2 / parseFloat(max2);
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n === "string" && n.indexOf("%") != -1;
      }
      function pad2(c) {
        return c.length == 1 ? "0" + c : "" + c;
      }
      function convertToPercentage(n) {
        if (n <= 1) {
          n = n * 100 + "%";
        }
        return n;
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
      }
      function stringInputToObject(color) {
        color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named = false;
        if (names[color]) {
          color = names[color];
          named = true;
        } else if (color == "transparent") {
          return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
          };
        }
        var match;
        if (match = matchers.rgb.exec(color)) {
          return {
            r: match[1],
            g: match[2],
            b: match[3]
          };
        }
        if (match = matchers.rgba.exec(color)) {
          return {
            r: match[1],
            g: match[2],
            b: match[3],
            a: match[4]
          };
        }
        if (match = matchers.hsl.exec(color)) {
          return {
            h: match[1],
            s: match[2],
            l: match[3]
          };
        }
        if (match = matchers.hsla.exec(color)) {
          return {
            h: match[1],
            s: match[2],
            l: match[3],
            a: match[4]
          };
        }
        if (match = matchers.hsv.exec(color)) {
          return {
            h: match[1],
            s: match[2],
            v: match[3]
          };
        }
        if (match = matchers.hsva.exec(color)) {
          return {
            h: match[1],
            s: match[2],
            v: match[3],
            a: match[4]
          };
        }
        if (match = matchers.hex8.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex6.exec(color)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
          };
        }
        if (match = matchers.hex4.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            a: convertHexToDecimal(match[4] + "" + match[4]),
            format: named ? "name" : "hex8"
          };
        }
        if (match = matchers.hex3.exec(color)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            format: named ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size;
        parms = parms || {
          level: "AA",
          size: "small"
        };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size !== "small" && size !== "large") {
          size = "small";
        }
        return {
          level,
          size
        };
      }
      return tinycolor;
    });
  }
});

// node_modules/@jimp/core/dist/modules/phash.js
var require_phash = __commonJS({
  "node_modules/@jimp/core/dist/modules/phash.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function ImagePHash(size, smallerSize) {
      this.size = this.size || size;
      this.smallerSize = this.smallerSize || smallerSize;
      initCoefficients(this.size);
    }
    ImagePHash.prototype.size = 32;
    ImagePHash.prototype.smallerSize = 8;
    ImagePHash.prototype.distance = function(s1, s2) {
      let counter = 0;
      for (let k = 0; k < s1.length; k++) {
        if (s1[k] !== s2[k]) {
          counter++;
        }
      }
      return counter / s1.length;
    };
    ImagePHash.prototype.getHash = function(img) {
      img = img.clone().resize(this.size, this.size);
      img.grayscale();
      const vals = [];
      for (let x = 0; x < img.bitmap.width; x++) {
        vals[x] = [];
        for (let y = 0; y < img.bitmap.height; y++) {
          vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
        }
      }
      const dctVals = applyDCT(vals, this.size);
      let total = 0;
      for (let x = 0; x < this.smallerSize; x++) {
        for (let y = 0; y < this.smallerSize; y++) {
          total += dctVals[x][y];
        }
      }
      const avg = total / (this.smallerSize * this.smallerSize);
      let hash = "";
      for (let x = 0; x < this.smallerSize; x++) {
        for (let y = 0; y < this.smallerSize; y++) {
          hash += dctVals[x][y] > avg ? "1" : "0";
        }
      }
      return hash;
    };
    function intToRGBA(i2) {
      const rgba = {};
      rgba.r = Math.floor(i2 / Math.pow(256, 3));
      rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
      rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
      rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
      return rgba;
    }
    var c = [];
    function initCoefficients(size) {
      for (let i2 = 1; i2 < size; i2++) {
        c[i2] = 1;
      }
      c[0] = 1 / Math.sqrt(2);
    }
    function applyDCT(f, size) {
      const N = size;
      const F = [];
      for (let u = 0; u < N; u++) {
        F[u] = [];
        for (let v = 0; v < N; v++) {
          let sum = 0;
          for (let i2 = 0; i2 < N; i2++) {
            for (let j = 0; j < N; j++) {
              sum += Math.cos((2 * i2 + 1) / (2 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i2][j];
            }
          }
          sum *= c[u] * c[v] / 4;
          F[u][v] = sum;
        }
      }
      return F;
    }
    var _default = ImagePHash;
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i2 = 0; (c = x.codePointAt(i2)) !== void 0; ++i2) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i2 = 0; i2 < n; ++i2) {
        const c = S.charCodeAt(i2);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i2 === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i2 + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i2;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i2 = 0; i2 < keys.length; ++i2) {
        Object.defineProperty(target, keys[i2], Object.getOwnPropertyDescriptor(source, keys[i2]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i2 = 0; i2 < len; ++i2) {
        var codePoint = domain_name.codePointAt(i2);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i2 = 0; i2 < len; ++i2) {
        var status = findStatus(label.codePointAt(i2));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i2 = 0; i2 < labels.length; ++i2) {
        try {
          var validation = validateLabel(labels[i2]);
          labels[i2] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i2 = 0; i2 < labels.length; ++i2) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i2 = 0; i2 < buf.length; ++i2) {
        str += percentEncode(buf[i2]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i2 = 0; i2 < input.length; ++i2) {
        if (input[i2] !== 37) {
          output.push(input[i2]);
        } else if (input[i2] === 37 && isASCIIHex(input[i2 + 1]) && isASCIIHex(input[i2 + 2])) {
          output.push(parseInt(input.slice(i2 + 1, i2 + 3).toString(), 16));
          i2 += 2;
        } else {
          output.push(input[i2]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i2 = 0; i2 < numbers.length - 1; ++i2) {
        if (numbers[i2] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i2 = 1; i2 <= 4; ++i2) {
        output = String(n % 256) + output;
        if (i2 !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value2 = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value2 = value2 * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value2;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        output += percentEncodeChar(decoded[i2], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i2 = 0; i2 < arr.length; ++i2) {
        if (arr[i2] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i2;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path4 = url.path;
      if (path4.length === 0) {
        return;
      }
      if (url.scheme === "file" && path4.length === 1 && isNormalizedWindowsDriveLetter(path4[0])) {
        return;
      }
      path4.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i2 = 0; i2 < buffer.length; ++i2) {
          if (buffer[i2] < 33 || buffer[i2] > 126 || buffer[i2] === 34 || buffer[i2] === 35 || buffer[i2] === 60 || buffer[i2] === 62) {
            this.url.query += percentEncode(buffer[i2]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i2]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.username += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i2 = 0; i2 < decoded.length; ++i2) {
        url.password += percentEncodeChar(decoded[i2], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib();
    var utils2 = require_utils();
    var Impl = require_URL_impl();
    var impl = utils2.implSymbol;
    function URL(url) {
      if (!this || this[impl] || !(this instanceof URL)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 2; ++i2) {
        args[i2] = arguments[i2];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i2 = 0; i2 < arguments.length && i2 < 0; ++i2) {
        args[i2] = arguments[i2];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils2.wrapperSymbol] = obj;
      },
      interface: URL,
      expose: {
        Window: { URL },
        Worker: { URL }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob2 = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i2 = 0; i2 < length; i2++) {
            const element = a[i2];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob2.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob2([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name2 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name2);
          Object.defineProperty(proto, name2, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve5, reject2) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject2(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject2(err);
          } else {
            reject2(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk2) {
          if (abort || chunk2 === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk2.length > _this4.size) {
            abort = true;
            reject2(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk2.length;
          accum.push(chunk2);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve5(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject2(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name2) {
      name2 = `${name2}`;
      if (invalidTokenRegex.test(name2) || name2 === "") {
        throw new TypeError(`${name2} is not a legal HTTP header name`);
      }
    }
    function validateValue(value2) {
      value2 = `${value2}`;
      if (invalidHeaderCharRegex.test(value2)) {
        throw new TypeError(`${value2} is not a legal HTTP header value`);
      }
    }
    function find(map, name2) {
      name2 = name2.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name2) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value2 of rawHeaders[headerName]) {
              this.append(headerName, value2);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value2 = init[key];
              this.append(key, value2);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key = find(this[MAP], name2);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i2 = 0;
        while (i2 < pairs.length) {
          var _pairs$i = pairs[i2];
          const name2 = _pairs$i[0], value2 = _pairs$i[1];
          callback.call(thisArg, value2, name2, this);
          pairs = getHeaders(this);
          i2++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name2, value2) {
        name2 = `${name2}`;
        value2 = `${value2}`;
        validateName(name2);
        validateValue(value2);
        const key = find(this[MAP], name2);
        this[MAP][key !== void 0 ? key : name2] = [value2];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name2, value2) {
        name2 = `${name2}`;
        value2 = `${value2}`;
        validateName(name2);
        validateValue(value2);
        const key = find(this[MAP], name2);
        if (key !== void 0) {
          this[MAP][key].push(value2);
        } else {
          this[MAP][name2] = [value2];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name2) {
        name2 = `${name2}`;
        validateName(name2);
        return find(this[MAP], name2) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key = find(this[MAP], name2);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers.prototype.entries = Headers.prototype[Symbol.iterator];
    Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers();
      for (const name2 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name2)) {
          continue;
        }
        if (Array.isArray(obj[name2])) {
          for (const val of obj[name2]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name2] === void 0) {
              headers[MAP][name2] = [val];
            } else {
              headers[MAP][name2].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name2])) {
          headers[MAP][name2] = [obj[name2]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request.prototype);
    Object.defineProperty(Request.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve5, reject2) {
        const request = new Request(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject2(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject2(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject2(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s) {
            s.addListener("close", function(hadError) {
              const hasDataListener = s.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location === null ? null : new URL$1(location, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject2(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject2(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject2(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject2(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name2 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name2);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject2(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve5(fetch2(new Request(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk2) {
              if ((chunk2[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve5(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response(body, response_options);
                resolve5(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve5(response);
            return;
          }
          response = new Response(body, response_options);
          resolve5(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s) {
        socket = s;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream2, err) {
      if (stream2.destroy) {
        stream2.destroy(err);
      } else {
        stream2.emit("error", err);
        stream2.end();
      }
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers;
    exports2.Request = Request;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// node_modules/isomorphic-fetch/fetch-npm-node.js
var require_fetch_npm_node = __commonJS({
  "node_modules/isomorphic-fetch/fetch-npm-node.js"(exports2, module2) {
    "use strict";
    var realFetch = require_lib2();
    module2.exports = function(url, options) {
      if (/^\/\//.test(url)) {
        url = "https:" + url;
      }
      return realFetch.call(this, url, options);
    };
    if (!global.fetch) {
      global.fetch = module2.exports;
      global.Response = realFetch.Response;
      global.Headers = realFetch.Headers;
      global.Request = realFetch.Request;
    }
  }
});

// node_modules/@jimp/core/dist/request.js
var require_request = __commonJS({
  "node_modules/@jimp/core/dist/request.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    require_fetch_npm_node();
    var _default = (_ref, cb) => {
      let {
        url,
        ...options
      } = _ref;
      fetch(url, options).then((response) => {
        if (response.ok) {
          return response.arrayBuffer().catch((error) => {
            throw new Error(`Response is not a buffer for url ${url}. Error: ${error.message}`);
          });
        }
        throw new Error(`HTTP Status ${response.status} for url ${url}`);
      }).then((data) => cb(null, data)).catch((error) => cb(error));
    };
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/core/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@jimp/core/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VERTICAL_ALIGN_TOP = exports2.VERTICAL_ALIGN_MIDDLE = exports2.VERTICAL_ALIGN_BOTTOM = exports2.HORIZONTAL_ALIGN_RIGHT = exports2.HORIZONTAL_ALIGN_LEFT = exports2.HORIZONTAL_ALIGN_CENTER = exports2.EDGE_WRAP = exports2.EDGE_EXTEND = exports2.EDGE_CROP = exports2.BLEND_SOURCE_OVER = exports2.BLEND_SCREEN = exports2.BLEND_OVERLAY = exports2.BLEND_MULTIPLY = exports2.BLEND_LIGHTEN = exports2.BLEND_HARDLIGHT = exports2.BLEND_EXCLUSION = exports2.BLEND_DIFFERENCE = exports2.BLEND_DESTINATION_OVER = exports2.BLEND_DARKEN = exports2.BLEND_ADD = exports2.AUTO = void 0;
    var AUTO = -1;
    exports2.AUTO = AUTO;
    var HORIZONTAL_ALIGN_LEFT = 1;
    exports2.HORIZONTAL_ALIGN_LEFT = HORIZONTAL_ALIGN_LEFT;
    var HORIZONTAL_ALIGN_CENTER = 2;
    exports2.HORIZONTAL_ALIGN_CENTER = HORIZONTAL_ALIGN_CENTER;
    var HORIZONTAL_ALIGN_RIGHT = 4;
    exports2.HORIZONTAL_ALIGN_RIGHT = HORIZONTAL_ALIGN_RIGHT;
    var VERTICAL_ALIGN_TOP = 8;
    exports2.VERTICAL_ALIGN_TOP = VERTICAL_ALIGN_TOP;
    var VERTICAL_ALIGN_MIDDLE = 16;
    exports2.VERTICAL_ALIGN_MIDDLE = VERTICAL_ALIGN_MIDDLE;
    var VERTICAL_ALIGN_BOTTOM = 32;
    exports2.VERTICAL_ALIGN_BOTTOM = VERTICAL_ALIGN_BOTTOM;
    var BLEND_SOURCE_OVER = "srcOver";
    exports2.BLEND_SOURCE_OVER = BLEND_SOURCE_OVER;
    var BLEND_DESTINATION_OVER = "dstOver";
    exports2.BLEND_DESTINATION_OVER = BLEND_DESTINATION_OVER;
    var BLEND_MULTIPLY = "multiply";
    exports2.BLEND_MULTIPLY = BLEND_MULTIPLY;
    var BLEND_ADD = "add";
    exports2.BLEND_ADD = BLEND_ADD;
    var BLEND_SCREEN = "screen";
    exports2.BLEND_SCREEN = BLEND_SCREEN;
    var BLEND_OVERLAY = "overlay";
    exports2.BLEND_OVERLAY = BLEND_OVERLAY;
    var BLEND_DARKEN = "darken";
    exports2.BLEND_DARKEN = BLEND_DARKEN;
    var BLEND_LIGHTEN = "lighten";
    exports2.BLEND_LIGHTEN = BLEND_LIGHTEN;
    var BLEND_HARDLIGHT = "hardLight";
    exports2.BLEND_HARDLIGHT = BLEND_HARDLIGHT;
    var BLEND_DIFFERENCE = "difference";
    exports2.BLEND_DIFFERENCE = BLEND_DIFFERENCE;
    var BLEND_EXCLUSION = "exclusion";
    exports2.BLEND_EXCLUSION = BLEND_EXCLUSION;
    var EDGE_EXTEND = 1;
    exports2.EDGE_EXTEND = EDGE_EXTEND;
    var EDGE_WRAP = 2;
    exports2.EDGE_WRAP = EDGE_WRAP;
    var EDGE_CROP = 3;
    exports2.EDGE_CROP = EDGE_CROP;
  }
});

// node_modules/@jimp/core/dist/composite/composite-modes.js
var require_composite_modes = __commonJS({
  "node_modules/@jimp/core/dist/composite/composite-modes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.add = add;
    exports2.darken = darken;
    exports2.difference = difference;
    exports2.dstOver = dstOver;
    exports2.exclusion = exclusion;
    exports2.hardLight = hardLight;
    exports2.lighten = lighten;
    exports2.multiply = multiply;
    exports2.overlay = overlay;
    exports2.screen = screen;
    exports2.srcOver = srcOver;
    function srcOver(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
      const g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
      const b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function dstOver(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
      const g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
      const b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function multiply(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
      const g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
      const b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function add(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (sra + dra) / a;
      const g = (sga + dga) / a;
      const b = (sba + dba) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function screen(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
      const g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
      const b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function overlay(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
      const g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
      const b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function darken(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
      const g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
      const b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function lighten(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
      const g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
      const b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function hardLight(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
      const g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
      const b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function difference(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
      const g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
      const b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
    function exclusion(src, dst) {
      let ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      src.a *= ops;
      const a = dst.a + src.a - dst.a * src.a;
      const sra = src.r * src.a;
      const sga = src.g * src.a;
      const sba = src.b * src.a;
      const dra = dst.r * dst.a;
      const dga = dst.g * dst.a;
      const dba = dst.b * dst.a;
      const r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
      const g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
      const b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
      return {
        r,
        g,
        b,
        a
      };
    }
  }
});

// node_modules/@jimp/core/dist/composite/index.js
var require_composite = __commonJS({
  "node_modules/@jimp/core/dist/composite/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = composite;
    var _utils = require_dist();
    var constants2 = _interopRequireWildcard(require_constants());
    var compositeModes = _interopRequireWildcard(require_composite_modes());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function composite(src, x, y) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      let cb = arguments.length > 4 ? arguments[4] : void 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!(src instanceof this.constructor)) {
        return _utils.throwError.call(this, "The source must be a Jimp image", cb);
      }
      if (typeof x !== "number" || typeof y !== "number") {
        return _utils.throwError.call(this, "x and y must be numbers", cb);
      }
      let {
        mode,
        opacitySource,
        opacityDest
      } = options;
      if (!mode) {
        mode = constants2.BLEND_SOURCE_OVER;
      }
      if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
        opacitySource = 1;
      }
      if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
        opacityDest = 1;
      }
      const blendmode = compositeModes[mode];
      x = Math.round(x);
      y = Math.round(y);
      const baseImage = this;
      if (opacityDest !== 1) {
        baseImage.opacity(opacityDest);
      }
      src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
        const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants2.EDGE_CROP);
        if (dstIdx === -1) {
          return;
        }
        const blended = blendmode({
          r: this.bitmap.data[idx + 0] / 255,
          g: this.bitmap.data[idx + 1] / 255,
          b: this.bitmap.data[idx + 2] / 255,
          a: this.bitmap.data[idx + 3] / 255
        }, {
          r: baseImage.bitmap.data[dstIdx + 0] / 255,
          g: baseImage.bitmap.data[dstIdx + 1] / 255,
          b: baseImage.bitmap.data[dstIdx + 2] / 255,
          a: baseImage.bitmap.data[dstIdx + 3] / 255
        }, opacitySource);
        baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
        baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
        baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
        baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/core/dist/utils/promisify.js
var require_promisify = __commonJS({
  "node_modules/@jimp/core/dist/utils/promisify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var promisify = function(fun, ctx) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return new Promise((resolve5, reject2) => {
        args.push((err, data) => {
          if (err) {
            reject2(err);
          }
          resolve5(data);
        });
        fun.bind(ctx)(...args);
      });
    };
    var _default = promisify;
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/core/dist/utils/mime.js
var require_mime = __commonJS({
  "node_modules/@jimp/core/dist/utils/mime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getType = exports2.getExtension = exports2.addType = void 0;
    var mimeTypes = {};
    var findType = (extension) => Object.entries(mimeTypes).find((type) => type[1].includes(extension)) || [];
    var addType = (mime, extensions) => {
      mimeTypes[mime] = extensions;
    };
    exports2.addType = addType;
    var getType = (path4) => {
      const pathParts = path4.split("/").slice(-1);
      const extension = pathParts[pathParts.length - 1].split(".").pop();
      const type = findType(extension);
      return type[0];
    };
    exports2.getType = getType;
    var getExtension = (type) => (mimeTypes[type.toLowerCase()] || [])[0];
    exports2.getExtension = getExtension;
  }
});

// node_modules/strtok3/lib/FsPromise.js
var require_FsPromise = __commonJS({
  "node_modules/strtok3/lib/FsPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readFile = exports2.writeFileSync = exports2.writeFile = exports2.read = exports2.open = exports2.close = exports2.stat = exports2.createReadStream = exports2.pathExists = void 0;
    var fs = require("fs");
    exports2.pathExists = fs.existsSync;
    exports2.createReadStream = fs.createReadStream;
    async function stat3(path4) {
      return new Promise((resolve5, reject2) => {
        fs.stat(path4, (err, stats) => {
          if (err)
            reject2(err);
          else
            resolve5(stats);
        });
      });
    }
    exports2.stat = stat3;
    async function close(fd) {
      return new Promise((resolve5, reject2) => {
        fs.close(fd, (err) => {
          if (err)
            reject2(err);
          else
            resolve5();
        });
      });
    }
    exports2.close = close;
    async function open(path4, mode) {
      return new Promise((resolve5, reject2) => {
        fs.open(path4, mode, (err, fd) => {
          if (err)
            reject2(err);
          else
            resolve5(fd);
        });
      });
    }
    exports2.open = open;
    async function read(fd, buffer, offset, length, position) {
      return new Promise((resolve5, reject2) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
          if (err)
            reject2(err);
          else
            resolve5({ bytesRead, buffer: _buffer });
        });
      });
    }
    exports2.read = read;
    async function writeFile2(path4, data) {
      return new Promise((resolve5, reject2) => {
        fs.writeFile(path4, data, (err) => {
          if (err)
            reject2(err);
          else
            resolve5();
        });
      });
    }
    exports2.writeFile = writeFile2;
    function writeFileSync(path4, data) {
      fs.writeFileSync(path4, data);
    }
    exports2.writeFileSync = writeFileSync;
    async function readFile4(path4) {
      return new Promise((resolve5, reject2) => {
        fs.readFile(path4, (err, buffer) => {
          if (err)
            reject2(err);
          else
            resolve5(buffer);
        });
      });
    }
    exports2.readFile = readFile4;
  }
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS({
  "node_modules/peek-readable/lib/EndOfFileStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EndOfStreamError = exports2.defaultMessages = void 0;
    exports2.defaultMessages = "End-Of-Stream";
    var EndOfStreamError = class extends Error {
      constructor() {
        super(exports2.defaultMessages);
      }
    };
    exports2.EndOfStreamError = EndOfStreamError;
  }
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS({
  "node_modules/peek-readable/lib/Deferred.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve5, reject2) => {
          this.reject = reject2;
          this.resolve = resolve5;
        });
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS({
  "node_modules/peek-readable/lib/StreamReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    var Deferred_1 = require_Deferred();
    var EndOfFileStream_2 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_2.EndOfStreamError;
    } });
    var maxStreamReadSize = 1 * 1024 * 1024;
    var StreamReader = class {
      constructor(s) {
        this.s = s;
        this.deferred = null;
        this.endOfStream = false;
        this.peekQueue = [];
        if (!s.read || !s.once) {
          throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError()));
        this.s.once("error", (err) => this.reject(err));
        this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      /**
       * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
       * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes peeked
       */
      async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */
      async read(buffer, offset, length) {
        if (length === 0) {
          return 0;
        }
        if (this.peekQueue.length === 0 && this.endOfStream) {
          throw new EndOfFileStream_1.EndOfStreamError();
        }
        let remaining = length;
        let bytesRead = 0;
        while (this.peekQueue.length > 0 && remaining > 0) {
          const peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          const lenCopy = Math.min(peekData.length, remaining);
          buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
          bytesRead += lenCopy;
          remaining -= lenCopy;
          if (lenCopy < peekData.length) {
            this.peekQueue.push(peekData.subarray(lenCopy));
          }
        }
        while (remaining > 0 && !this.endOfStream) {
          const reqLen = Math.min(remaining, maxStreamReadSize);
          const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
          bytesRead += chunkLen;
          if (chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */
      async readFromStream(buffer, offset, length) {
        const readBuffer = this.s.read(length);
        if (readBuffer) {
          buffer.set(readBuffer, offset);
          return readBuffer.length;
        } else {
          const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred_1.Deferred()
          };
          this.deferred = request.deferred;
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
          return request.deferred.promise;
        }
      }
      /**
       * Process deferred read request
       * @param request Deferred read request
       */
      readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
        }
      }
      reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.reject(err);
          this.deferred = null;
        }
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/peek-readable/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/peek-readable/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return EndOfFileStream_1.EndOfStreamError;
    } });
    var StreamReader_1 = require_StreamReader();
    Object.defineProperty(exports2, "StreamReader", { enumerable: true, get: function() {
      return StreamReader_1.StreamReader;
    } });
  }
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS({
  "node_modules/strtok3/lib/AbstractTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractTokenizer = void 0;
    var peek_readable_1 = require_lib3();
    var AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
      }
      /**
       * Read a token from the tokenizer-stream
       * @param token - The token to read
       * @param position - If provided, the desired position in the tokenizer-stream
       * @returns Promise with token data
       */
      async readToken(token, position = this.position) {
        const uint8Array = Buffer.alloc(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Peek a token from the tokenizer-stream.
       * @param token - Token to peek from the tokenizer-stream.
       * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
       * @returns Promise with token data
       */
      async peekToken(token, position = this.position) {
        const uint8Array = Buffer.alloc(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to ignore
       * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
       */
      async ignore(length) {
        if (this.fileInfo.size !== void 0) {
          const bytesLeft = this.fileInfo.size - this.position;
          if (length > bytesLeft) {
            this.position += bytesLeft;
            return bytesLeft;
          }
        }
        this.position += length;
        return length;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options) {
        if (options && options.position !== void 0 && options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (options) {
          return {
            mayBeLess: options.mayBeLess === true,
            offset: options.offset ? options.offset : 0,
            length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
            position: options.position ? options.position : this.position
          };
        }
        return {
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
    exports2.AbstractTokenizer = AbstractTokenizer;
  }
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS({
  "node_modules/strtok3/lib/ReadStreamTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadStreamTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib3();
    var maxBufferSize = 256e3;
    var ReadStreamTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(stream2, fileInfo) {
        super(fileInfo);
        this.streamReader = new peek_readable_1.StreamReader(stream2);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with file information
       */
      async getFileInfo() {
        return this.fileInfo;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
       * @param options - Read behaviour options
       * @returns Promise with number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          await this.ignore(skipBytes);
          return this.readBuffer(uint8Array, options);
        } else if (skipBytes < 0) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (normOptions.length === 0) {
          return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise with number of bytes peeked
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
            uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
            return bytesRead - skipBytes;
          } else if (skipBytes < 0) {
            throw new Error("Cannot peek from a negative offset in a stream");
          }
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err) {
            if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {
              return 0;
            }
            throw err;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
            throw new peek_readable_1.EndOfStreamError();
          }
        }
        return bytesRead;
      }
      async ignore(length) {
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
          const remaining = length - totBytesRead;
          const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0) {
            return bytesRead;
          }
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
    exports2.ReadStreamTokenizer = ReadStreamTokenizer;
  }
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS({
  "node_modules/strtok3/lib/BufferTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BufferTokenizer = void 0;
    var peek_readable_1 = require_lib3();
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      /**
       * Construct BufferTokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param fileInfo - Pass additional file information to the tokenizer
       */
      constructor(uint8Array, fileInfo) {
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async readBuffer(uint8Array, options) {
        if (options && options.position) {
          if (options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        } else {
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
      }
      async close() {
      }
    };
    exports2.BufferTokenizer = BufferTokenizer;
  }
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS({
  "node_modules/strtok3/lib/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBuffer = exports2.fromStream = exports2.EndOfStreamError = void 0;
    var ReadStreamTokenizer_1 = require_ReadStreamTokenizer();
    var BufferTokenizer_1 = require_BufferTokenizer();
    var peek_readable_1 = require_lib3();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return peek_readable_1.EndOfStreamError;
    } });
    function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
    function fromBuffer2(uint8Array, fileInfo) {
      return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
    }
    exports2.fromBuffer = fromBuffer2;
  }
});

// node_modules/strtok3/lib/FileTokenizer.js
var require_FileTokenizer = __commonJS({
  "node_modules/strtok3/lib/FileTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromFile = exports2.FileTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer();
    var peek_readable_1 = require_lib3();
    var fs = require_FsPromise();
    var FileTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(fd, fileInfo) {
        super(fileInfo);
        this.fd = fd;
      }
      /**
       * Read buffer from file
       * @param uint8Array - Uint8Array to write result to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return res.bytesRead;
      }
      /**
       * Peek buffer from file
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await fs.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
          throw new peek_readable_1.EndOfStreamError();
        }
        return res.bytesRead;
      }
      async close() {
        return fs.close(this.fd);
      }
    };
    exports2.FileTokenizer = FileTokenizer;
    async function fromFile(sourceFilePath) {
      const stat3 = await fs.stat(sourceFilePath);
      if (!stat3.isFile) {
        throw new Error(`File not a file: ${sourceFilePath}`);
      }
      const fd = await fs.open(sourceFilePath, "r");
      return new FileTokenizer(fd, { path: sourceFilePath, size: stat3.size });
    }
    exports2.fromFile = fromFile;
  }
});

// node_modules/strtok3/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/strtok3/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromStream = exports2.fromBuffer = exports2.EndOfStreamError = exports2.fromFile = void 0;
    var fs = require_FsPromise();
    var core = require_core();
    var FileTokenizer_1 = require_FileTokenizer();
    Object.defineProperty(exports2, "fromFile", { enumerable: true, get: function() {
      return FileTokenizer_1.fromFile;
    } });
    var core_1 = require_core();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: true, get: function() {
      return core_1.EndOfStreamError;
    } });
    Object.defineProperty(exports2, "fromBuffer", { enumerable: true, get: function() {
      return core_1.fromBuffer;
    } });
    async function fromStream2(stream2, fileInfo) {
      fileInfo = fileInfo ? fileInfo : {};
      if (stream2.path) {
        const stat3 = await fs.stat(stream2.path);
        fileInfo.path = stream2.path;
        fileInfo.size = stat3.size;
      }
      return core.fromStream(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value2, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m = isNaN(value2) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value2 += rt / c;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value2 * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d] |= s * 128;
    };
  }
});

// node_modules/token-types/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/token-types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnsiStringType = exports2.StringType = exports2.BufferType = exports2.Uint8ArrayType = exports2.IgnoreType = exports2.Float80_LE = exports2.Float80_BE = exports2.Float64_LE = exports2.Float64_BE = exports2.Float32_LE = exports2.Float32_BE = exports2.Float16_LE = exports2.Float16_BE = exports2.INT64_BE = exports2.UINT64_BE = exports2.INT64_LE = exports2.UINT64_LE = exports2.INT32_LE = exports2.INT32_BE = exports2.INT24_BE = exports2.INT24_LE = exports2.INT16_LE = exports2.INT16_BE = exports2.INT8 = exports2.UINT32_BE = exports2.UINT32_LE = exports2.UINT24_BE = exports2.UINT24_LE = exports2.UINT16_BE = exports2.UINT16_LE = exports2.UINT8 = void 0;
    var ieee754 = require_ieee754();
    function dv(array) {
      return new DataView(array.buffer, array.byteOffset);
    }
    exports2.UINT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getUint8(offset);
      },
      put(array, offset, value2) {
        dv(array).setUint8(offset, value2);
        return offset + 1;
      }
    };
    exports2.UINT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setUint16(offset, value2, true);
        return offset + 2;
      }
    };
    exports2.UINT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset);
      },
      put(array, offset, value2) {
        dv(array).setUint16(offset, value2);
        return offset + 2;
      }
    };
    exports2.UINT24_LE = {
      len: 3,
      get(array, offset) {
        const dataView = dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
      },
      put(array, offset, value2) {
        const dataView = dv(array);
        dataView.setUint8(offset, value2 & 255);
        dataView.setUint16(offset + 1, value2 >> 8, true);
        return offset + 3;
      }
    };
    exports2.UINT24_BE = {
      len: 3,
      get(array, offset) {
        const dataView = dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
      },
      put(array, offset, value2) {
        const dataView = dv(array);
        dataView.setUint16(offset, value2 >> 8);
        dataView.setUint8(offset + 2, value2 & 255);
        return offset + 3;
      }
    };
    exports2.UINT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setUint32(offset, value2, true);
        return offset + 4;
      }
    };
    exports2.UINT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset);
      },
      put(array, offset, value2) {
        dv(array).setUint32(offset, value2);
        return offset + 4;
      }
    };
    exports2.INT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getInt8(offset);
      },
      put(array, offset, value2) {
        dv(array).setInt8(offset, value2);
        return offset + 1;
      }
    };
    exports2.INT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset);
      },
      put(array, offset, value2) {
        dv(array).setInt16(offset, value2);
        return offset + 2;
      }
    };
    exports2.INT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setInt16(offset, value2, true);
        return offset + 2;
      }
    };
    exports2.INT24_LE = {
      len: 3,
      get(array, offset) {
        const unsigned = exports2.UINT24_LE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value2) {
        const dataView = dv(array);
        dataView.setUint8(offset, value2 & 255);
        dataView.setUint16(offset + 1, value2 >> 8, true);
        return offset + 3;
      }
    };
    exports2.INT24_BE = {
      len: 3,
      get(array, offset) {
        const unsigned = exports2.UINT24_BE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value2) {
        const dataView = dv(array);
        dataView.setUint16(offset, value2 >> 8);
        dataView.setUint8(offset + 2, value2 & 255);
        return offset + 3;
      }
    };
    exports2.INT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset);
      },
      put(array, offset, value2) {
        dv(array).setInt32(offset, value2);
        return offset + 4;
      }
    };
    exports2.INT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setInt32(offset, value2, true);
        return offset + 4;
      }
    };
    exports2.UINT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setBigUint64(offset, value2, true);
        return offset + 8;
      }
    };
    exports2.INT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setBigInt64(offset, value2, true);
        return offset + 8;
      }
    };
    exports2.UINT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset);
      },
      put(array, offset, value2) {
        dv(array).setBigUint64(offset, value2);
        return offset + 8;
      }
    };
    exports2.INT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset);
      },
      put(array, offset, value2) {
        dv(array).setBigInt64(offset, value2);
        return offset + 8;
      }
    };
    exports2.Float16_BE = {
      len: 2,
      get(dataView, offset) {
        return ieee754.read(dataView, offset, false, 10, this.len);
      },
      put(dataView, offset, value2) {
        ieee754.write(dataView, value2, offset, false, 10, this.len);
        return offset + this.len;
      }
    };
    exports2.Float16_LE = {
      len: 2,
      get(array, offset) {
        return ieee754.read(array, offset, true, 10, this.len);
      },
      put(array, offset, value2) {
        ieee754.write(array, value2, offset, true, 10, this.len);
        return offset + this.len;
      }
    };
    exports2.Float32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset);
      },
      put(array, offset, value2) {
        dv(array).setFloat32(offset, value2);
        return offset + 4;
      }
    };
    exports2.Float32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setFloat32(offset, value2, true);
        return offset + 4;
      }
    };
    exports2.Float64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset);
      },
      put(array, offset, value2) {
        dv(array).setFloat64(offset, value2);
        return offset + 8;
      }
    };
    exports2.Float64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset, true);
      },
      put(array, offset, value2) {
        dv(array).setFloat64(offset, value2, true);
        return offset + 8;
      }
    };
    exports2.Float80_BE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, false, 63, this.len);
      },
      put(array, offset, value2) {
        ieee754.write(array, value2, offset, false, 63, this.len);
        return offset + this.len;
      }
    };
    exports2.Float80_LE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, true, 63, this.len);
      },
      put(array, offset, value2) {
        ieee754.write(array, value2, offset, true, 63, this.len);
        return offset + this.len;
      }
    };
    var IgnoreType = class {
      /**
       * @param len number of bytes to ignore
       */
      constructor(len) {
        this.len = len;
      }
      // ToDo: don't read, but skip data
      get(array, off) {
      }
    };
    exports2.IgnoreType = IgnoreType;
    var Uint8ArrayType = class {
      constructor(len) {
        this.len = len;
      }
      get(array, offset) {
        return array.subarray(offset, offset + this.len);
      }
    };
    exports2.Uint8ArrayType = Uint8ArrayType;
    var BufferType = class {
      constructor(len) {
        this.len = len;
      }
      get(uint8Array, off) {
        return Buffer.from(uint8Array.subarray(off, off + this.len));
      }
    };
    exports2.BufferType = BufferType;
    var StringType = class {
      constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
      }
      get(uint8Array, offset) {
        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    };
    exports2.StringType = StringType;
    var AnsiStringType = class _AnsiStringType {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer, offset, until) {
        let str = "";
        for (let i2 = offset; i2 < until; ++i2) {
          str += _AnsiStringType.codePointToString(_AnsiStringType.singleByteDecoder(buffer[i2]));
        }
        return str;
      }
      static inRange(a, min2, max2) {
        return min2 <= a && a <= max2;
      }
      static codePointToString(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        } else {
          cp -= 65536;
          return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
        }
      }
      static singleByteDecoder(bite) {
        if (_AnsiStringType.inRange(bite, 0, 127)) {
          return bite;
        }
        const codePoint = _AnsiStringType.windows1252[bite - 128];
        if (codePoint === null) {
          throw Error("invaliding encoding");
        }
        return codePoint;
      }
      get(buffer, offset = 0) {
        return _AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    };
    exports2.AnsiStringType = AnsiStringType;
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// node_modules/file-type/util.js
var require_util = __commonJS({
  "node_modules/file-type/util.js"(exports2) {
    "use strict";
    exports2.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
    exports2.tarHeaderChecksumMatches = (buffer, offset = 0) => {
      const readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(readSum)) {
        return false;
      }
      let sum = 8 * 32;
      for (let i2 = offset; i2 < offset + 148; i2++) {
        sum += buffer[i2];
      }
      for (let i2 = offset + 156; i2 < offset + 512; i2++) {
        sum += buffer[i2];
      }
      return readSum === sum;
    };
    exports2.uint32SyncSafeToken = {
      get: (buffer, offset) => {
        return buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21;
      },
      len: 4
    };
  }
});

// node_modules/file-type/supported.js
var require_supported = __commonJS({
  "node_modules/file-type/supported.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      extensions: [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf"
      ],
      mimeTypes: [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/vnd.wave",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "audio/opus",
        "video/ogg",
        "audio/ogg",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd"
      ]
    };
  }
});

// node_modules/file-type/core.js
var require_core2 = __commonJS({
  "node_modules/file-type/core.js"(exports, module) {
    "use strict";
    var Token = require_lib5();
    var strtok3 = require_core();
    var {
      stringToBytes,
      tarHeaderChecksumMatches,
      uint32SyncSafeToken
    } = require_util();
    var supported = require_supported();
    var minimumBytes = 4100;
    async function fromStream(stream2) {
      const tokenizer = await strtok3.fromStream(stream2);
      try {
        return await fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async function fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer = input instanceof Buffer ? input : Buffer.from(input);
      if (!(buffer && buffer.length > 1)) {
        return;
      }
      const tokenizer = strtok3.fromBuffer(buffer);
      return fromTokenizer(tokenizer);
    }
    function _check(buffer, headers, options) {
      options = {
        offset: 0,
        ...options
      };
      for (const [index, header] of headers.entries()) {
        if (options.mask) {
          if (header !== (options.mask[index] & buffer[index + options.offset])) {
            return false;
          }
        } else if (header !== buffer[index + options.offset]) {
          return false;
        }
      }
      return true;
    }
    async function fromTokenizer(tokenizer) {
      try {
        return _fromTokenizer(tokenizer);
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError)) {
          throw error;
        }
      }
    }
    async function _fromTokenizer(tokenizer) {
      let buffer = Buffer.alloc(minimumBytes);
      const bytesRead = 12;
      const check = (header, options) => _check(buffer, header, options);
      const checkString = (header, options) => check(stringToBytes(header), options);
      if (!tokenizer.fileInfo.size) {
        tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
      }
      await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: true });
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if (check([37, 33])) {
        await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: true });
        if (checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 })) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (checkString("ID3")) {
        await tokenizer.ignore(6);
        const id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
        if (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        await tokenizer.ignore(id3HeaderLen);
        return fromTokenizer(tokenizer);
      }
      if (checkString("MP+")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (checkString("FLIF")) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if (checkString("8BPS")) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (checkString("MPCK")) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (checkString("FORM")) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("icns", { offset: 0 })) {
        return {
          ext: "icns",
          mime: "image/icns"
        };
      }
      if (check([80, 75, 3, 4])) {
        try {
          while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
            await tokenizer.readBuffer(buffer, { length: 30 });
            const zipHeader = {
              compressedSize: buffer.readUInt32LE(18),
              uncompressedSize: buffer.readUInt32LE(22),
              filenameLength: buffer.readUInt16LE(26),
              extraFieldLength: buffer.readUInt16LE(28)
            };
            zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8"));
            await tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.filename === "META-INF/mozilla.rsa") {
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            }
            if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
              const type = zipHeader.filename.split("/")[0];
              switch (type) {
                case "_rels":
                  break;
                case "word":
                  return {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                case "ppt":
                  return {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                case "xl":
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                default:
                  break;
              }
            }
            if (zipHeader.filename.startsWith("xl/")) {
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
            if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
              return {
                ext: "3mf",
                mime: "model/3mf"
              };
            }
            if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
              const mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"));
              switch (mimeType) {
                case "application/epub+zip":
                  return {
                    ext: "epub",
                    mime: "application/epub+zip"
                  };
                case "application/vnd.oasis.opendocument.text":
                  return {
                    ext: "odt",
                    mime: "application/vnd.oasis.opendocument.text"
                  };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return {
                    ext: "ods",
                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                  };
                case "application/vnd.oasis.opendocument.presentation":
                  return {
                    ext: "odp",
                    mime: "application/vnd.oasis.opendocument.presentation"
                  };
                default:
              }
            }
            if (zipHeader.compressedSize === 0) {
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                await tokenizer.peekBuffer(buffer, { mayBeLess: true });
                nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex");
                await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
              }
            } else {
              await tokenizer.ignore(zipHeader.compressedSize);
            }
          }
        } catch (error) {
          if (!(error instanceof strtok3.EndOfStreamError)) {
            throw error;
          }
        }
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("OggS")) {
        await tokenizer.ignore(28);
        const type = Buffer.alloc(8);
        await tokenizer.readBuffer(type);
        if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
          return {
            ext: "opus",
            mime: "audio/opus"
          };
        }
        if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (_check(type, [127, 70, 76, 65, 67])) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("ftyp", { offset: 4 }) && (buffer[8] & 96) !== 0) {
        const brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (checkString("MThd")) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (checkString("DSD ")) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      }
      if (checkString("LZIP")) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (checkString("fLaC")) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (checkString("wvpk")) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (checkString("%PDF")) {
        await tokenizer.ignore(1350);
        const maxBufferSize = 10 * 1024 * 1024;
        const buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
        await tokenizer.readBuffer(buffer2, { mayBeLess: true });
        if (buffer2.includes(Buffer.from("AIPrivateData"))) {
          return {
            ext: "ai",
            mime: "application/postscript"
          };
        }
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([73, 73, 42, 0])) {
        if (checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 })) {
          return {
            ext: "nef",
            mime: "image/x-nikon-nef"
          };
        }
        if (check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 }))) {
          return {
            ext: "dng",
            mime: "image/x-adobe-dng"
          };
        }
        buffer = Buffer.alloc(24);
        await tokenizer.peekBuffer(buffer);
        if ((check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
        check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })) {
          return {
            ext: "arw",
            mime: "image/x-sony-arw"
          };
        }
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (checkString("MAC ")) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([26, 69, 223, 163])) {
        async function readField() {
          const msb = await tokenizer.peekNumber(Token.UINT8);
          let mask = 128;
          let ic = 0;
          while ((msb & mask) === 0 && mask !== 0) {
            ++ic;
            mask >>= 1;
          }
          const id = Buffer.alloc(ic + 1);
          await tokenizer.readBuffer(id);
          return id;
        }
        async function readElement() {
          const id = await readField();
          const lenField = await readField();
          lenField[0] ^= 128 >> lenField.length - 1;
          const nrLen = Math.min(6, lenField.length);
          return {
            id: id.readUIntBE(0, id.length),
            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
          };
        }
        async function readChildren(level, children2) {
          while (children2 > 0) {
            const e = await readElement();
            if (e.id === 17026) {
              return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
            }
            await tokenizer.ignore(e.len);
            --children2;
          }
        }
        const re = await readElement();
        const docType = await readChildren(1, re.len);
        switch (docType) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          default:
            return;
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (checkString("SQLi")) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (checkString("Cr24")) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (checkString("MSCF") || checkString("ISc(")) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([197, 208, 211, 198])) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      if (check([40, 181, 47, 253])) {
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (checkString("#!AMR")) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (checkString("{\\rtf")) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (checkString("IMPM")) {
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      }
      if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 })) {
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      }
      if (check([0, 0, 1, 186])) {
        if (check([33], { offset: 4, mask: [241] })) {
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        }
        if (check([68], { offset: 4, mask: [196] })) {
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
        }
      }
      if (checkString("ITSF")) {
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (checkString("solid ")) {
        return {
          ext: "stl",
          mime: "model/stl"
        };
      }
      if (checkString("BLENDER")) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (checkString("!<arch>")) {
        await tokenizer.ignore(8);
        const str = await tokenizer.readToken(new Token.StringType(13, "ascii"));
        if (str === "debian-binary") {
          return {
            ext: "deb",
            mime: "application/x-deb"
          };
        }
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(Token.INT32_BE),
            type: await tokenizer.readToken(new Token.StringType(4, "binary"))
          };
        }
        do {
          const chunk2 = await readChunkHeader();
          if (chunk2.length < 0) {
            return;
          }
          switch (chunk2.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk2.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([65, 82, 82, 79, 87, 49, 0, 0])) {
        return {
          ext: "arrow",
          mime: "application/x-apache-arrow"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
      check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // `moov`
      check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (checkString("gimp xcf ")) {
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      }
      if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          const guid = Buffer.alloc(16);
          await tokenizer.readBuffer(guid);
          return {
            id: guid,
            size: Number(await tokenizer.readToken(Token.UINT64_LE))
          };
        }
        await tokenizer.ignore(30);
        while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
          const header = await readHeader();
          let payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const typeId = Buffer.alloc(16);
            payload -= await tokenizer.readBuffer(typeId);
            if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            }
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 })) {
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      }
      if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        await tokenizer.ignore(20);
        const type = await tokenizer.readToken(new Token.StringType(4, "ascii"));
        switch (type) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      }
      if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      }
      await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
      if (checkString("BEGIN:")) {
        if (checkString("VCARD", { offset: 6 })) {
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        }
        if (checkString("VCALENDAR", { offset: 6 })) {
          return {
            ext: "ics",
            mime: "text/calendar"
          };
        }
      }
      if (checkString("FUJIFILMCCD-RAW")) {
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      }
      if (checkString("Extended Module:")) {
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      }
      if (checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (check([4, 0, 0, 0]) && buffer.length >= 16) {
        const jsonSize = buffer.readUInt32LE(12);
        if (jsonSize > 12 && buffer.length >= jsonSize + 16) {
          try {
            const header = buffer.slice(16, jsonSize + 16).toString();
            const json = JSON.parse(header);
            if (json.files) {
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
            }
          } catch (_) {
          }
        }
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (checkString("SCRM", { offset: 44 })) {
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      }
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      }
      await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
      if (tarHeaderChecksumMatches(buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      if (checkString("-----BEGIN PGP MESSAGE-----")) {
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      }
      if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
        if (check([16], { offset: 1, mask: [22] })) {
          if (check([8], { offset: 1, mask: [8] })) {
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        if (check([2], { offset: 1, mask: [6] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([4], { offset: 1, mask: [6] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([6], { offset: 1, mask: [6] })) {
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
        }
      }
    }
    var stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.on("error", reject);
      readableStream.once("readable", async () => {
        const pass = new stream.PassThrough();
        let outputStream;
        if (stream.pipeline) {
          outputStream = stream.pipeline(readableStream, pass, () => {
          });
        } else {
          outputStream = readableStream.pipe(pass);
        }
        const chunk2 = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
        try {
          const fileType2 = await fromBuffer(chunk2);
          pass.fileType = fileType2;
        } catch (error) {
          reject(error);
        }
        resolve(outputStream);
      });
    });
    var fileType = {
      fromStream,
      fromTokenizer,
      fromBuffer,
      stream
    };
    Object.defineProperty(fileType, "extensions", {
      get() {
        return new Set(supported.extensions);
      }
    });
    Object.defineProperty(fileType, "mimeTypes", {
      get() {
        return new Set(supported.mimeTypes);
      }
    });
    module.exports = fileType;
  }
});

// node_modules/file-type/index.js
var require_file_type = __commonJS({
  "node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    var strtok32 = require_lib4();
    var core = require_core2();
    async function fromFile(path4) {
      const tokenizer = await strtok32.fromFile(path4);
      try {
        return await core.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    var fileType2 = {
      fromFile
    };
    Object.assign(fileType2, core);
    Object.defineProperty(fileType2, "extensions", {
      get() {
        return core.extensions;
      }
    });
    Object.defineProperty(fileType2, "mimeTypes", {
      get() {
        return core.mimeTypes;
      }
    });
    module2.exports = fileType2;
  }
});

// node_modules/exif-parser/lib/jpeg.js
var require_jpeg = __commonJS({
  "node_modules/exif-parser/lib/jpeg.js"(exports2, module2) {
    module2.exports = {
      parseSections: function(stream2, iterator) {
        var len, markerType;
        stream2.setBigEndian(true);
        while (stream2.remainingLength() > 0 && markerType !== 218) {
          if (stream2.nextUInt8() !== 255) {
            throw new Error("Invalid JPEG section offset");
          }
          markerType = stream2.nextUInt8();
          if (markerType >= 208 && markerType <= 217 || markerType === 218) {
            len = 0;
          } else {
            len = stream2.nextUInt16() - 2;
          }
          iterator(markerType, stream2.branch(0, len));
          stream2.skip(len);
        }
      },
      //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
      getSizeFromSOFSection: function(stream2) {
        stream2.skip(1);
        return {
          height: stream2.nextUInt16(),
          width: stream2.nextUInt16()
        };
      },
      getSectionName: function(markerType) {
        var name2, index;
        switch (markerType) {
          case 216:
            name2 = "SOI";
            break;
          case 196:
            name2 = "DHT";
            break;
          case 219:
            name2 = "DQT";
            break;
          case 221:
            name2 = "DRI";
            break;
          case 218:
            name2 = "SOS";
            break;
          case 254:
            name2 = "COM";
            break;
          case 217:
            name2 = "EOI";
            break;
          default:
            if (markerType >= 224 && markerType <= 239) {
              name2 = "APP";
              index = markerType - 224;
            } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
              name2 = "SOF";
              index = markerType - 192;
            } else if (markerType >= 208 && markerType <= 215) {
              name2 = "RST";
              index = markerType - 208;
            }
            break;
        }
        var nameStruct = {
          name: name2
        };
        if (typeof index === "number") {
          nameStruct.index = index;
        }
        return nameStruct;
      }
    };
  }
});

// node_modules/exif-parser/lib/exif.js
var require_exif = __commonJS({
  "node_modules/exif-parser/lib/exif.js"(exports2, module2) {
    function readExifValue(format, stream2) {
      switch (format) {
        case 1:
          return stream2.nextUInt8();
        case 3:
          return stream2.nextUInt16();
        case 4:
          return stream2.nextUInt32();
        case 5:
          return [stream2.nextUInt32(), stream2.nextUInt32()];
        case 6:
          return stream2.nextInt8();
        case 8:
          return stream2.nextUInt16();
        case 9:
          return stream2.nextUInt32();
        case 10:
          return [stream2.nextInt32(), stream2.nextInt32()];
        case 11:
          return stream2.nextFloat();
        case 12:
          return stream2.nextDouble();
        default:
          throw new Error("Invalid format while decoding: " + format);
      }
    }
    function getBytesPerComponent(format) {
      switch (format) {
        case 1:
        case 2:
        case 6:
        case 7:
          return 1;
        case 3:
        case 8:
          return 2;
        case 4:
        case 9:
        case 11:
          return 4;
        case 5:
        case 10:
        case 12:
          return 8;
        default:
          return 0;
      }
    }
    function readExifTag(tiffMarker, stream2) {
      var tagType = stream2.nextUInt16(), format = stream2.nextUInt16(), bytesPerComponent = getBytesPerComponent(format), components = stream2.nextUInt32(), valueBytes = bytesPerComponent * components, values, value2, c;
      if (valueBytes > 4) {
        stream2 = tiffMarker.openWithOffset(stream2.nextUInt32());
      }
      if (format === 2) {
        values = stream2.nextString(components);
        var lastNull = values.indexOf("\0");
        if (lastNull !== -1) {
          values = values.substr(0, lastNull);
        }
      } else if (format === 7) {
        values = stream2.nextBuffer(components);
      } else if (format !== 0) {
        values = [];
        for (c = 0; c < components; ++c) {
          values.push(readExifValue(format, stream2));
        }
      }
      if (valueBytes < 4) {
        stream2.skip(4 - valueBytes);
      }
      return [tagType, values, format];
    }
    function readIFDSection(tiffMarker, stream2, iterator) {
      var numberOfEntries = stream2.nextUInt16(), tag, i2;
      for (i2 = 0; i2 < numberOfEntries; ++i2) {
        tag = readExifTag(tiffMarker, stream2);
        iterator(tag[0], tag[1], tag[2]);
      }
    }
    function readHeader(stream2) {
      var exifHeader = stream2.nextString(6);
      if (exifHeader !== "Exif\0\0") {
        throw new Error("Invalid EXIF header");
      }
      var tiffMarker = stream2.mark();
      var tiffHeader = stream2.nextUInt16();
      if (tiffHeader === 18761) {
        stream2.setBigEndian(false);
      } else if (tiffHeader === 19789) {
        stream2.setBigEndian(true);
      } else {
        throw new Error("Invalid TIFF header");
      }
      if (stream2.nextUInt16() !== 42) {
        throw new Error("Invalid TIFF data");
      }
      return tiffMarker;
    }
    module2.exports = {
      IFD0: 1,
      IFD1: 2,
      GPSIFD: 3,
      SubIFD: 4,
      InteropIFD: 5,
      parseTags: function(stream2, iterator) {
        var tiffMarker;
        try {
          tiffMarker = readHeader(stream2);
        } catch (e) {
          return false;
        }
        var subIfdOffset, gpsOffset, interopOffset;
        var ifd0Stream = tiffMarker.openWithOffset(stream2.nextUInt32()), IFD0 = this.IFD0;
        readIFDSection(tiffMarker, ifd0Stream, function(tagType, value2, format) {
          switch (tagType) {
            case 34853:
              gpsOffset = value2[0];
              break;
            case 34665:
              subIfdOffset = value2[0];
              break;
            default:
              iterator(IFD0, tagType, value2, format);
              break;
          }
        });
        var ifd1Offset = ifd0Stream.nextUInt32();
        if (ifd1Offset !== 0) {
          var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
          readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
        }
        if (gpsOffset) {
          var gpsStream = tiffMarker.openWithOffset(gpsOffset);
          readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
        }
        if (subIfdOffset) {
          var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
          readIFDSection(tiffMarker, subIfdStream, function(tagType, value2, format) {
            if (tagType === 40965) {
              interopOffset = value2[0];
            } else {
              iterator(InteropIFD, tagType, value2, format);
            }
          });
        }
        if (interopOffset) {
          var interopStream = tiffMarker.openWithOffset(interopOffset);
          readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
        }
        return true;
      }
    };
  }
});

// node_modules/exif-parser/lib/date.js
var require_date = __commonJS({
  "node_modules/exif-parser/lib/date.js"(exports2, module2) {
    function parseNumber(s) {
      return parseInt(s, 10);
    }
    var hours = 3600;
    var minutes = 60;
    function parseDateTimeParts(dateParts, timeParts) {
      dateParts = dateParts.map(parseNumber);
      timeParts = timeParts.map(parseNumber);
      var year = dateParts[0];
      var month = dateParts[1] - 1;
      var day = dateParts[2];
      var hours2 = timeParts[0];
      var minutes2 = timeParts[1];
      var seconds = timeParts[2];
      var date = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
      var timestamp = date / 1e3;
      return timestamp;
    }
    function parseDateWithTimezoneFormat(dateTimeStr) {
      var dateParts = dateTimeStr.substr(0, 10).split("-");
      var timeParts = dateTimeStr.substr(11, 8).split(":");
      var timezoneStr = dateTimeStr.substr(19, 6);
      var timezoneParts = timezoneStr.split(":").map(parseNumber);
      var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
      var timestamp = parseDateTimeParts(dateParts, timeParts);
      timestamp -= timezoneOffset;
      if (typeof timestamp === "number" && !isNaN(timestamp)) {
        return timestamp;
      }
    }
    function parseDateWithSpecFormat(dateTimeStr) {
      var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
      var timestamp = parseDateTimeParts(dateParts, timeParts);
      if (typeof timestamp === "number" && !isNaN(timestamp)) {
        return timestamp;
      }
    }
    function parseExifDate(dateTimeStr) {
      var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
      var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
      var timestamp;
      if (isTimezoneFormat) {
        return parseDateWithTimezoneFormat(dateTimeStr);
      } else if (isSpecFormat) {
        return parseDateWithSpecFormat(dateTimeStr);
      }
    }
    module2.exports = {
      parseDateWithSpecFormat,
      parseDateWithTimezoneFormat,
      parseExifDate
    };
  }
});

// node_modules/exif-parser/lib/simplify.js
var require_simplify = __commonJS({
  "node_modules/exif-parser/lib/simplify.js"(exports2, module2) {
    var exif = require_exif();
    var date = require_date();
    var degreeTags = [
      {
        section: exif.GPSIFD,
        type: 2,
        name: "GPSLatitude",
        refType: 1,
        refName: "GPSLatitudeRef",
        posVal: "N"
      },
      {
        section: exif.GPSIFD,
        type: 4,
        name: "GPSLongitude",
        refType: 3,
        refName: "GPSLongitudeRef",
        posVal: "E"
      }
    ];
    var dateTags = [
      {
        section: exif.SubIFD,
        type: 306,
        name: "ModifyDate"
      },
      {
        section: exif.SubIFD,
        type: 36867,
        name: "DateTimeOriginal"
      },
      {
        section: exif.SubIFD,
        type: 36868,
        name: "CreateDate"
      },
      {
        section: exif.SubIFD,
        type: 306,
        name: "ModifyDate"
      }
    ];
    module2.exports = {
      castDegreeValues: function(getTagValue, setTagValue) {
        degreeTags.forEach(function(t) {
          var degreeVal = getTagValue(t);
          if (degreeVal) {
            var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });
            var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
            var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
            setTagValue(t, degree);
          }
        });
      },
      castDateValues: function(getTagValue, setTagValue) {
        dateTags.forEach(function(t) {
          var dateStrVal = getTagValue(t);
          if (dateStrVal) {
            var timestamp = date.parseExifDate(dateStrVal);
            if (typeof timestamp !== "undefined") {
              setTagValue(t, timestamp);
            }
          }
        });
      },
      simplifyValue: function(values, format) {
        if (Array.isArray(values)) {
          values = values.map(function(value2) {
            if (format === 10 || format === 5) {
              return value2[0] / value2[1];
            }
            return value2;
          });
          if (values.length === 1) {
            values = values[0];
          }
        }
        return values;
      }
    };
  }
});

// node_modules/exif-parser/lib/exif-tags.js
var require_exif_tags = __commonJS({
  "node_modules/exif-parser/lib/exif-tags.js"(exports2, module2) {
    module2.exports = {
      exif: {
        1: "InteropIndex",
        2: "InteropVersion",
        11: "ProcessingSoftware",
        254: "SubfileType",
        255: "OldSubfileType",
        256: "ImageWidth",
        257: "ImageHeight",
        258: "BitsPerSample",
        259: "Compression",
        262: "PhotometricInterpretation",
        263: "Thresholding",
        264: "CellWidth",
        265: "CellLength",
        266: "FillOrder",
        269: "DocumentName",
        270: "ImageDescription",
        271: "Make",
        272: "Model",
        273: "StripOffsets",
        274: "Orientation",
        277: "SamplesPerPixel",
        278: "RowsPerStrip",
        279: "StripByteCounts",
        280: "MinSampleValue",
        281: "MaxSampleValue",
        282: "XResolution",
        283: "YResolution",
        284: "PlanarConfiguration",
        285: "PageName",
        286: "XPosition",
        287: "YPosition",
        288: "FreeOffsets",
        289: "FreeByteCounts",
        290: "GrayResponseUnit",
        291: "GrayResponseCurve",
        292: "T4Options",
        293: "T6Options",
        296: "ResolutionUnit",
        297: "PageNumber",
        300: "ColorResponseUnit",
        301: "TransferFunction",
        305: "Software",
        306: "ModifyDate",
        315: "Artist",
        316: "HostComputer",
        317: "Predictor",
        318: "WhitePoint",
        319: "PrimaryChromaticities",
        320: "ColorMap",
        321: "HalftoneHints",
        322: "TileWidth",
        323: "TileLength",
        324: "TileOffsets",
        325: "TileByteCounts",
        326: "BadFaxLines",
        327: "CleanFaxData",
        328: "ConsecutiveBadFaxLines",
        330: "SubIFD",
        332: "InkSet",
        333: "InkNames",
        334: "NumberofInks",
        336: "DotRange",
        337: "TargetPrinter",
        338: "ExtraSamples",
        339: "SampleFormat",
        340: "SMinSampleValue",
        341: "SMaxSampleValue",
        342: "TransferRange",
        343: "ClipPath",
        344: "XClipPathUnits",
        345: "YClipPathUnits",
        346: "Indexed",
        347: "JPEGTables",
        351: "OPIProxy",
        400: "GlobalParametersIFD",
        401: "ProfileType",
        402: "FaxProfile",
        403: "CodingMethods",
        404: "VersionYear",
        405: "ModeNumber",
        433: "Decode",
        434: "DefaultImageColor",
        435: "T82Options",
        437: "JPEGTables",
        512: "JPEGProc",
        513: "ThumbnailOffset",
        514: "ThumbnailLength",
        515: "JPEGRestartInterval",
        517: "JPEGLosslessPredictors",
        518: "JPEGPointTransforms",
        519: "JPEGQTables",
        520: "JPEGDCTables",
        521: "JPEGACTables",
        529: "YCbCrCoefficients",
        530: "YCbCrSubSampling",
        531: "YCbCrPositioning",
        532: "ReferenceBlackWhite",
        559: "StripRowCounts",
        700: "ApplicationNotes",
        999: "USPTOMiscellaneous",
        4096: "RelatedImageFileFormat",
        4097: "RelatedImageWidth",
        4098: "RelatedImageHeight",
        18246: "Rating",
        18247: "XP_DIP_XML",
        18248: "StitchInfo",
        18249: "RatingPercent",
        32781: "ImageID",
        32931: "WangTag1",
        32932: "WangAnnotation",
        32933: "WangTag3",
        32934: "WangTag4",
        32995: "Matteing",
        32996: "DataType",
        32997: "ImageDepth",
        32998: "TileDepth",
        33405: "Model2",
        33421: "CFARepeatPatternDim",
        33422: "CFAPattern2",
        33423: "BatteryLevel",
        33424: "KodakIFD",
        33432: "Copyright",
        33434: "ExposureTime",
        33437: "FNumber",
        33445: "MDFileTag",
        33446: "MDScalePixel",
        33447: "MDColorTable",
        33448: "MDLabName",
        33449: "MDSampleInfo",
        33450: "MDPrepDate",
        33451: "MDPrepTime",
        33452: "MDFileUnits",
        33550: "PixelScale",
        33589: "AdventScale",
        33590: "AdventRevision",
        33628: "UIC1Tag",
        33629: "UIC2Tag",
        33630: "UIC3Tag",
        33631: "UIC4Tag",
        33723: "IPTC-NAA",
        33918: "IntergraphPacketData",
        33919: "IntergraphFlagRegisters",
        33920: "IntergraphMatrix",
        33921: "INGRReserved",
        33922: "ModelTiePoint",
        34016: "Site",
        34017: "ColorSequence",
        34018: "IT8Header",
        34019: "RasterPadding",
        34020: "BitsPerRunLength",
        34021: "BitsPerExtendedRunLength",
        34022: "ColorTable",
        34023: "ImageColorIndicator",
        34024: "BackgroundColorIndicator",
        34025: "ImageColorValue",
        34026: "BackgroundColorValue",
        34027: "PixelIntensityRange",
        34028: "TransparencyIndicator",
        34029: "ColorCharacterization",
        34030: "HCUsage",
        34031: "TrapIndicator",
        34032: "CMYKEquivalent",
        34118: "SEMInfo",
        34152: "AFCP_IPTC",
        34232: "PixelMagicJBIGOptions",
        34264: "ModelTransform",
        34306: "WB_GRGBLevels",
        34310: "LeafData",
        34377: "PhotoshopSettings",
        34665: "ExifOffset",
        34675: "ICC_Profile",
        34687: "TIFF_FXExtensions",
        34688: "MultiProfiles",
        34689: "SharedData",
        34690: "T88Options",
        34732: "ImageLayer",
        34735: "GeoTiffDirectory",
        34736: "GeoTiffDoubleParams",
        34737: "GeoTiffAsciiParams",
        34850: "ExposureProgram",
        34852: "SpectralSensitivity",
        34853: "GPSInfo",
        34855: "ISO",
        34856: "Opto-ElectricConvFactor",
        34857: "Interlace",
        34858: "TimeZoneOffset",
        34859: "SelfTimerMode",
        34864: "SensitivityType",
        34865: "StandardOutputSensitivity",
        34866: "RecommendedExposureIndex",
        34867: "ISOSpeed",
        34868: "ISOSpeedLatitudeyyy",
        34869: "ISOSpeedLatitudezzz",
        34908: "FaxRecvParams",
        34909: "FaxSubAddress",
        34910: "FaxRecvTime",
        34954: "LeafSubIFD",
        36864: "ExifVersion",
        36867: "DateTimeOriginal",
        36868: "CreateDate",
        37121: "ComponentsConfiguration",
        37122: "CompressedBitsPerPixel",
        37377: "ShutterSpeedValue",
        37378: "ApertureValue",
        37379: "BrightnessValue",
        37380: "ExposureCompensation",
        37381: "MaxApertureValue",
        37382: "SubjectDistance",
        37383: "MeteringMode",
        37384: "LightSource",
        37385: "Flash",
        37386: "FocalLength",
        37387: "FlashEnergy",
        37388: "SpatialFrequencyResponse",
        37389: "Noise",
        37390: "FocalPlaneXResolution",
        37391: "FocalPlaneYResolution",
        37392: "FocalPlaneResolutionUnit",
        37393: "ImageNumber",
        37394: "SecurityClassification",
        37395: "ImageHistory",
        37396: "SubjectArea",
        37397: "ExposureIndex",
        37398: "TIFF-EPStandardID",
        37399: "SensingMethod",
        37434: "CIP3DataFile",
        37435: "CIP3Sheet",
        37436: "CIP3Side",
        37439: "StoNits",
        37500: "MakerNote",
        37510: "UserComment",
        37520: "SubSecTime",
        37521: "SubSecTimeOriginal",
        37522: "SubSecTimeDigitized",
        37679: "MSDocumentText",
        37680: "MSPropertySetStorage",
        37681: "MSDocumentTextPosition",
        37724: "ImageSourceData",
        40091: "XPTitle",
        40092: "XPComment",
        40093: "XPAuthor",
        40094: "XPKeywords",
        40095: "XPSubject",
        40960: "FlashpixVersion",
        40961: "ColorSpace",
        40962: "ExifImageWidth",
        40963: "ExifImageHeight",
        40964: "RelatedSoundFile",
        40965: "InteropOffset",
        41483: "FlashEnergy",
        41484: "SpatialFrequencyResponse",
        41485: "Noise",
        41486: "FocalPlaneXResolution",
        41487: "FocalPlaneYResolution",
        41488: "FocalPlaneResolutionUnit",
        41489: "ImageNumber",
        41490: "SecurityClassification",
        41491: "ImageHistory",
        41492: "SubjectLocation",
        41493: "ExposureIndex",
        41494: "TIFF-EPStandardID",
        41495: "SensingMethod",
        41728: "FileSource",
        41729: "SceneType",
        41730: "CFAPattern",
        41985: "CustomRendered",
        41986: "ExposureMode",
        41987: "WhiteBalance",
        41988: "DigitalZoomRatio",
        41989: "FocalLengthIn35mmFormat",
        41990: "SceneCaptureType",
        41991: "GainControl",
        41992: "Contrast",
        41993: "Saturation",
        41994: "Sharpness",
        41995: "DeviceSettingDescription",
        41996: "SubjectDistanceRange",
        42016: "ImageUniqueID",
        42032: "OwnerName",
        42033: "SerialNumber",
        42034: "LensInfo",
        42035: "LensMake",
        42036: "LensModel",
        42037: "LensSerialNumber",
        42112: "GDALMetadata",
        42113: "GDALNoData",
        42240: "Gamma",
        44992: "ExpandSoftware",
        44993: "ExpandLens",
        44994: "ExpandFilm",
        44995: "ExpandFilterLens",
        44996: "ExpandScanner",
        44997: "ExpandFlashLamp",
        48129: "PixelFormat",
        48130: "Transformation",
        48131: "Uncompressed",
        48132: "ImageType",
        48256: "ImageWidth",
        48257: "ImageHeight",
        48258: "WidthResolution",
        48259: "HeightResolution",
        48320: "ImageOffset",
        48321: "ImageByteCount",
        48322: "AlphaOffset",
        48323: "AlphaByteCount",
        48324: "ImageDataDiscard",
        48325: "AlphaDataDiscard",
        50215: "OceScanjobDesc",
        50216: "OceApplicationSelector",
        50217: "OceIDNumber",
        50218: "OceImageLogic",
        50255: "Annotations",
        50341: "PrintIM",
        50560: "USPTOOriginalContentType",
        50706: "DNGVersion",
        50707: "DNGBackwardVersion",
        50708: "UniqueCameraModel",
        50709: "LocalizedCameraModel",
        50710: "CFAPlaneColor",
        50711: "CFALayout",
        50712: "LinearizationTable",
        50713: "BlackLevelRepeatDim",
        50714: "BlackLevel",
        50715: "BlackLevelDeltaH",
        50716: "BlackLevelDeltaV",
        50717: "WhiteLevel",
        50718: "DefaultScale",
        50719: "DefaultCropOrigin",
        50720: "DefaultCropSize",
        50721: "ColorMatrix1",
        50722: "ColorMatrix2",
        50723: "CameraCalibration1",
        50724: "CameraCalibration2",
        50725: "ReductionMatrix1",
        50726: "ReductionMatrix2",
        50727: "AnalogBalance",
        50728: "AsShotNeutral",
        50729: "AsShotWhiteXY",
        50730: "BaselineExposure",
        50731: "BaselineNoise",
        50732: "BaselineSharpness",
        50733: "BayerGreenSplit",
        50734: "LinearResponseLimit",
        50735: "CameraSerialNumber",
        50736: "DNGLensInfo",
        50737: "ChromaBlurRadius",
        50738: "AntiAliasStrength",
        50739: "ShadowScale",
        50740: "DNGPrivateData",
        50741: "MakerNoteSafety",
        50752: "RawImageSegmentation",
        50778: "CalibrationIlluminant1",
        50779: "CalibrationIlluminant2",
        50780: "BestQualityScale",
        50781: "RawDataUniqueID",
        50784: "AliasLayerMetadata",
        50827: "OriginalRawFileName",
        50828: "OriginalRawFileData",
        50829: "ActiveArea",
        50830: "MaskedAreas",
        50831: "AsShotICCProfile",
        50832: "AsShotPreProfileMatrix",
        50833: "CurrentICCProfile",
        50834: "CurrentPreProfileMatrix",
        50879: "ColorimetricReference",
        50898: "PanasonicTitle",
        50899: "PanasonicTitle2",
        50931: "CameraCalibrationSig",
        50932: "ProfileCalibrationSig",
        50933: "ProfileIFD",
        50934: "AsShotProfileName",
        50935: "NoiseReductionApplied",
        50936: "ProfileName",
        50937: "ProfileHueSatMapDims",
        50938: "ProfileHueSatMapData1",
        50939: "ProfileHueSatMapData2",
        50940: "ProfileToneCurve",
        50941: "ProfileEmbedPolicy",
        50942: "ProfileCopyright",
        50964: "ForwardMatrix1",
        50965: "ForwardMatrix2",
        50966: "PreviewApplicationName",
        50967: "PreviewApplicationVersion",
        50968: "PreviewSettingsName",
        50969: "PreviewSettingsDigest",
        50970: "PreviewColorSpace",
        50971: "PreviewDateTime",
        50972: "RawImageDigest",
        50973: "OriginalRawFileDigest",
        50974: "SubTileBlockSize",
        50975: "RowInterleaveFactor",
        50981: "ProfileLookTableDims",
        50982: "ProfileLookTableData",
        51008: "OpcodeList1",
        51009: "OpcodeList2",
        51022: "OpcodeList3",
        51041: "NoiseProfile",
        51043: "TimeCodes",
        51044: "FrameRate",
        51058: "TStop",
        51081: "ReelName",
        51089: "OriginalDefaultFinalSize",
        51090: "OriginalBestQualitySize",
        51091: "OriginalDefaultCropSize",
        51105: "CameraLabel",
        51107: "ProfileHueSatMapEncoding",
        51108: "ProfileLookTableEncoding",
        51109: "BaselineExposureOffset",
        51110: "DefaultBlackRender",
        51111: "NewRawImageDigest",
        51112: "RawToPreviewGain",
        51125: "DefaultUserCrop",
        59932: "Padding",
        59933: "OffsetSchema",
        65e3: "OwnerName",
        65001: "SerialNumber",
        65002: "Lens",
        65024: "KDC_IFD",
        65100: "RawFile",
        65101: "Converter",
        65102: "WhiteBalance",
        65105: "Exposure",
        65106: "Shadows",
        65107: "Brightness",
        65108: "Contrast",
        65109: "Saturation",
        65110: "Sharpness",
        65111: "Smoothness",
        65112: "MoireFilter"
      },
      gps: {
        0: "GPSVersionID",
        1: "GPSLatitudeRef",
        2: "GPSLatitude",
        3: "GPSLongitudeRef",
        4: "GPSLongitude",
        5: "GPSAltitudeRef",
        6: "GPSAltitude",
        7: "GPSTimeStamp",
        8: "GPSSatellites",
        9: "GPSStatus",
        10: "GPSMeasureMode",
        11: "GPSDOP",
        12: "GPSSpeedRef",
        13: "GPSSpeed",
        14: "GPSTrackRef",
        15: "GPSTrack",
        16: "GPSImgDirectionRef",
        17: "GPSImgDirection",
        18: "GPSMapDatum",
        19: "GPSDestLatitudeRef",
        20: "GPSDestLatitude",
        21: "GPSDestLongitudeRef",
        22: "GPSDestLongitude",
        23: "GPSDestBearingRef",
        24: "GPSDestBearing",
        25: "GPSDestDistanceRef",
        26: "GPSDestDistance",
        27: "GPSProcessingMethod",
        28: "GPSAreaInformation",
        29: "GPSDateStamp",
        30: "GPSDifferential",
        31: "GPSHPositioningError"
      }
    };
  }
});

// node_modules/exif-parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/exif-parser/lib/parser.js"(exports2, module2) {
    var jpeg = require_jpeg();
    var exif = require_exif();
    var simplify = require_simplify();
    function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
      this.startMarker = startMarker;
      this.tags = tags;
      this.imageSize = imageSize;
      this.thumbnailOffset = thumbnailOffset;
      this.thumbnailLength = thumbnailLength;
      this.thumbnailType = thumbnailType;
      this.app1Offset = app1Offset;
    }
    ExifResult.prototype = {
      hasThumbnail: function(mime) {
        if (!this.thumbnailOffset || !this.thumbnailLength) {
          return false;
        }
        if (typeof mime !== "string") {
          return true;
        }
        if (mime.toLowerCase().trim() === "image/jpeg") {
          return this.thumbnailType === 6;
        }
        if (mime.toLowerCase().trim() === "image/tiff") {
          return this.thumbnailType === 1;
        }
        return false;
      },
      getThumbnailOffset: function() {
        return this.app1Offset + 6 + this.thumbnailOffset;
      },
      getThumbnailLength: function() {
        return this.thumbnailLength;
      },
      getThumbnailBuffer: function() {
        return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
      },
      _getThumbnailStream: function() {
        return this.startMarker.openWithOffset(this.getThumbnailOffset());
      },
      getImageSize: function() {
        return this.imageSize;
      },
      getThumbnailSize: function() {
        var stream2 = this._getThumbnailStream(), size;
        jpeg.parseSections(stream2, function(sectionType, sectionStream) {
          if (jpeg.getSectionName(sectionType).name === "SOF") {
            size = jpeg.getSizeFromSOFSection(sectionStream);
          }
        });
        return size;
      }
    };
    function Parser(stream2) {
      this.stream = stream2;
      this.flags = {
        readBinaryTags: false,
        resolveTagNames: true,
        simplifyValues: true,
        imageSize: true,
        hidePointers: true,
        returnTags: true
      };
    }
    Parser.prototype = {
      enableBinaryFields: function(enable) {
        this.flags.readBinaryTags = !!enable;
        return this;
      },
      enablePointers: function(enable) {
        this.flags.hidePointers = !enable;
        return this;
      },
      enableTagNames: function(enable) {
        this.flags.resolveTagNames = !!enable;
        return this;
      },
      enableImageSize: function(enable) {
        this.flags.imageSize = !!enable;
        return this;
      },
      enableReturnTags: function(enable) {
        this.flags.returnTags = !!enable;
        return this;
      },
      enableSimpleValues: function(enable) {
        this.flags.simplifyValues = !!enable;
        return this;
      },
      parse: function() {
        var start = this.stream.mark(), stream2 = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
        if (flags.resolveTagNames) {
          tagNames = require_exif_tags();
        }
        if (flags.resolveTagNames) {
          tags = {};
          getTagValue = function(t) {
            return tags[t.name];
          };
          setTagValue = function(t, value2) {
            tags[t.name] = value2;
          };
        } else {
          tags = [];
          getTagValue = function(t) {
            var i2;
            for (i2 = 0; i2 < tags.length; ++i2) {
              if (tags[i2].type === t.type && tags[i2].section === t.section) {
                return tags.value;
              }
            }
          };
          setTagValue = function(t, value2) {
            var i2;
            for (i2 = 0; i2 < tags.length; ++i2) {
              if (tags[i2].type === t.type && tags[i2].section === t.section) {
                tags.value = value2;
                return;
              }
            }
          };
        }
        jpeg.parseSections(stream2, function(sectionType, sectionStream) {
          var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
          if (sectionType === 225) {
            validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value2, format) {
              if (!flags.readBinaryTags && format === 7) {
                return;
              }
              if (tagType === 513) {
                thumbnailOffset = value2[0];
                if (flags.hidePointers) {
                  return;
                }
              } else if (tagType === 514) {
                thumbnailLength = value2[0];
                if (flags.hidePointers) {
                  return;
                }
              } else if (tagType === 259) {
                thumbnailType = value2[0];
                if (flags.hidePointers) {
                  return;
                }
              }
              if (!flags.returnTags) {
                return;
              }
              if (flags.simplifyValues) {
                value2 = simplify.simplifyValue(value2, format);
              }
              if (flags.resolveTagNames) {
                var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
                var name2 = sectionTagNames[tagType];
                if (!name2) {
                  name2 = tagNames.exif[tagType];
                }
                if (!tags.hasOwnProperty(name2)) {
                  tags[name2] = value2;
                }
              } else {
                tags.push({
                  section: ifdSection,
                  type: tagType,
                  value: value2
                });
              }
            });
            if (validExifHeaders) {
              app1Offset = sectionOffset;
            }
          } else if (flags.imageSize && jpeg.getSectionName(sectionType).name === "SOF") {
            imageSize = jpeg.getSizeFromSOFSection(sectionStream);
          }
        });
        if (flags.simplifyValues) {
          simplify.castDegreeValues(getTagValue, setTagValue);
          simplify.castDateValues(getTagValue, setTagValue);
        }
        return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
      }
    };
    module2.exports = Parser;
  }
});

// node_modules/exif-parser/lib/dom-bufferstream.js
var require_dom_bufferstream = __commonJS({
  "node_modules/exif-parser/lib/dom-bufferstream.js"(exports2, module2) {
    function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global2, parentOffset) {
      this.global = global2;
      offset = offset || 0;
      length = length || arrayBuffer.byteLength - offset;
      this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
      this.view = new global2.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
      this.setBigEndian(bigEndian);
      this.offset = 0;
      this.parentOffset = (parentOffset || 0) + offset;
    }
    DOMBufferStream.prototype = {
      setBigEndian: function(bigEndian) {
        this.littleEndian = !bigEndian;
      },
      nextUInt8: function() {
        var value2 = this.view.getUint8(this.offset);
        this.offset += 1;
        return value2;
      },
      nextInt8: function() {
        var value2 = this.view.getInt8(this.offset);
        this.offset += 1;
        return value2;
      },
      nextUInt16: function() {
        var value2 = this.view.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value2;
      },
      nextUInt32: function() {
        var value2 = this.view.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value2;
      },
      nextInt16: function() {
        var value2 = this.view.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value2;
      },
      nextInt32: function() {
        var value2 = this.view.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value2;
      },
      nextFloat: function() {
        var value2 = this.view.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value2;
      },
      nextDouble: function() {
        var value2 = this.view.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value2;
      },
      nextBuffer: function(length) {
        var value2 = this.arrayBuffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return value2;
      },
      remainingLength: function() {
        return this.arrayBuffer.byteLength - this.offset;
      },
      nextString: function(length) {
        var value2 = this.arrayBuffer.slice(this.offset, this.offset + length);
        value2 = String.fromCharCode.apply(null, new this.global.Uint8Array(value2));
        this.offset += length;
        return value2;
      },
      mark: function() {
        var self2 = this;
        return {
          openWithOffset: function(offset) {
            offset = (offset || 0) + this.offset;
            return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
          },
          offset: this.offset,
          getParentOffset: function() {
            return self2.parentOffset;
          }
        };
      },
      offsetFrom: function(marker) {
        return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
      },
      skip: function(amount) {
        this.offset += amount;
      },
      branch: function(offset, length) {
        length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
        return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
      }
    };
    module2.exports = DOMBufferStream;
  }
});

// node_modules/exif-parser/lib/bufferstream.js
var require_bufferstream = __commonJS({
  "node_modules/exif-parser/lib/bufferstream.js"(exports2, module2) {
    function BufferStream(buffer, offset, length, bigEndian) {
      this.buffer = buffer;
      this.offset = offset || 0;
      length = typeof length === "number" ? length : buffer.length;
      this.endPosition = this.offset + length;
      this.setBigEndian(bigEndian);
    }
    BufferStream.prototype = {
      setBigEndian: function(bigEndian) {
        this.bigEndian = !!bigEndian;
      },
      nextUInt8: function() {
        var value2 = this.buffer.readUInt8(this.offset);
        this.offset += 1;
        return value2;
      },
      nextInt8: function() {
        var value2 = this.buffer.readInt8(this.offset);
        this.offset += 1;
        return value2;
      },
      nextUInt16: function() {
        var value2 = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
        this.offset += 2;
        return value2;
      },
      nextUInt32: function() {
        var value2 = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return value2;
      },
      nextInt16: function() {
        var value2 = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
        this.offset += 2;
        return value2;
      },
      nextInt32: function() {
        var value2 = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return value2;
      },
      nextFloat: function() {
        var value2 = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
        this.offset += 4;
        return value2;
      },
      nextDouble: function() {
        var value2 = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
        this.offset += 8;
        return value2;
      },
      nextBuffer: function(length) {
        var value2 = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return value2;
      },
      remainingLength: function() {
        return this.endPosition - this.offset;
      },
      nextString: function(length) {
        var value2 = this.buffer.toString("utf8", this.offset, this.offset + length);
        this.offset += length;
        return value2;
      },
      mark: function() {
        var self2 = this;
        return {
          openWithOffset: function(offset) {
            offset = (offset || 0) + this.offset;
            return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
          },
          offset: this.offset
        };
      },
      offsetFrom: function(marker) {
        return this.offset - marker.offset;
      },
      skip: function(amount) {
        this.offset += amount;
      },
      branch: function(offset, length) {
        length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
        return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
      }
    };
    module2.exports = BufferStream;
  }
});

// node_modules/exif-parser/index.js
var require_exif_parser = __commonJS({
  "node_modules/exif-parser/index.js"(exports2, module2) {
    var Parser = require_parser();
    function getGlobal() {
      return (1, eval)("this");
    }
    module2.exports = {
      create: function(buffer, global2) {
        global2 = global2 || getGlobal();
        if (buffer instanceof global2.ArrayBuffer) {
          var DOMBufferStream = require_dom_bufferstream();
          return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global2));
        } else {
          var NodeBufferStream = require_bufferstream();
          return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
        }
      }
    };
  }
});

// node_modules/@jimp/core/dist/utils/image-bitmap.js
var require_image_bitmap = __commonJS({
  "node_modules/@jimp/core/dist/utils/image-bitmap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getBuffer = getBuffer;
    exports2.getBufferAsync = getBufferAsync;
    exports2.parseBitmap = parseBitmap;
    var _fileType = _interopRequireDefault(require_file_type());
    var _exifParser = _interopRequireDefault(require_exif_parser());
    var _utils = require_dist();
    var constants2 = _interopRequireWildcard(require_constants());
    var MIME = _interopRequireWildcard(require_mime());
    var _promisify = _interopRequireDefault(require_promisify());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function getMIMEFromBuffer(buffer, path4) {
      const fileTypeFromBuffer = await _fileType.default.fromBuffer(buffer);
      if (fileTypeFromBuffer) {
        return fileTypeFromBuffer.mime;
      }
      if (path4) {
        return MIME.getType(path4);
      }
      return null;
    }
    function getExifOrientation(img) {
      return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
    }
    function getExifOrientationTransformation(img) {
      const w = img.getWidth();
      const h = img.getHeight();
      switch (getExifOrientation(img)) {
        case 1:
          return null;
        case 2:
          return function(x, y) {
            return [w - x - 1, y];
          };
        case 3:
          return function(x, y) {
            return [w - x - 1, h - y - 1];
          };
        case 4:
          return function(x, y) {
            return [x, h - y - 1];
          };
        case 5:
          return function(x, y) {
            return [y, x];
          };
        case 6:
          return function(x, y) {
            return [y, h - x - 1];
          };
        case 7:
          return function(x, y) {
            return [w - y - 1, h - x - 1];
          };
        case 8:
          return function(x, y) {
            return [w - y - 1, x];
          };
        default:
          return null;
      }
    }
    function transformBitmap(img, width, height, transformation) {
      const _data = img.bitmap.data;
      const _width = img.bitmap.width;
      const data = Buffer.alloc(_data.length);
      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          const [_x, _y] = transformation(x, y);
          const idx = width * y + x << 2;
          const _idx = _width * _y + _x << 2;
          const pixel = _data.readUInt32BE(_idx);
          data.writeUInt32BE(pixel, idx);
        }
      }
      img.bitmap.data = data;
      img.bitmap.width = width;
      img.bitmap.height = height;
    }
    function exifRotate(img) {
      if (getExifOrientation(img) < 2)
        return;
      const transformation = getExifOrientationTransformation(img);
      const swapDimensions = getExifOrientation(img) > 4;
      const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
      const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
      transformBitmap(img, newWidth, newHeight, transformation);
    }
    async function parseBitmap(data, path4, cb) {
      const mime = await getMIMEFromBuffer(data, path4);
      if (typeof mime !== "string") {
        return cb(new Error("Could not find MIME for Buffer <" + path4 + ">"));
      }
      this._originalMime = mime.toLowerCase();
      try {
        const mime2 = this.getMIME();
        if (this.constructor.decoders[mime2]) {
          this.bitmap = this.constructor.decoders[mime2](data);
        } else {
          return _utils.throwError.call(this, "Unsupported MIME type: " + mime2, cb);
        }
      } catch (error) {
        return cb.call(this, error, this);
      }
      try {
        this._exif = _exifParser.default.create(data).parse();
        exifRotate(this);
      } catch (error) {
      }
      cb.call(this, null, this);
      return this;
    }
    function compositeBitmapOverBackground(Jimp, image2) {
      return new Jimp(image2.bitmap.width, image2.bitmap.height, image2._background).composite(image2, 0, 0).bitmap;
    }
    function getBuffer(mime, cb) {
      if (mime === constants2.AUTO) {
        mime = this.getMIME();
      }
      if (typeof mime !== "string") {
        return _utils.throwError.call(this, "mime must be a string", cb);
      }
      if (typeof cb !== "function") {
        return _utils.throwError.call(this, "cb must be a function", cb);
      }
      mime = mime.toLowerCase();
      if (this._rgba && this.constructor.hasAlpha[mime]) {
        this.bitmap.data = Buffer.from(this.bitmap.data);
      } else {
        this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
      }
      if (this.constructor.encoders[mime]) {
        const buffer = this.constructor.encoders[mime](this);
        if (buffer instanceof Promise) {
          buffer.then((buff) => {
            cb.call(this, null, buff);
          });
        } else {
          cb.call(this, null, buffer);
        }
      } else {
        return _utils.throwError.call(this, "Unsupported MIME type: " + mime, cb);
      }
      return this;
    }
    function getBufferAsync(mime) {
      return (0, _promisify.default)(getBuffer, this, mime);
    }
  }
});

// node_modules/@jimp/core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@jimp/core/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addConstants = addConstants;
    exports2.addJimpMethods = addJimpMethods;
    Object.defineProperty(exports2, "addType", {
      enumerable: true,
      get: function() {
        return MIME.addType;
      }
    });
    exports2.default = void 0;
    exports2.jimpEvChange = jimpEvChange;
    exports2.jimpEvMethod = jimpEvMethod;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _events = _interopRequireDefault(require("events"));
    var _utils = require_dist();
    var _anyBase = _interopRequireDefault(require_any_base());
    var _pixelmatch = _interopRequireDefault(require_pixelmatch());
    var _tinycolor = _interopRequireDefault(require_tinycolor());
    var _phash = _interopRequireDefault(require_phash());
    var _request = _interopRequireDefault(require_request());
    var _composite = _interopRequireDefault(require_composite());
    var _promisify = _interopRequireDefault(require_promisify());
    var MIME = _interopRequireWildcard(require_mime());
    var _imageBitmap = require_image_bitmap();
    var constants2 = _interopRequireWildcard(require_constants());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
    var maxHashLength = [NaN, NaN];
    for (let i2 = 2; i2 < 65; i2++) {
      const maxHash = (0, _anyBase.default)(_anyBase.default.BIN, alphabet.slice(0, i2))(new Array(64 + 1).join("1"));
      maxHashLength.push(maxHash.length);
    }
    function noop() {
    }
    function isArrayBuffer(test) {
      return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
    }
    function bufferFromArrayBuffer(arrayBuffer) {
      const buffer = Buffer.alloc(arrayBuffer.byteLength);
      const view = new Uint8Array(arrayBuffer);
      for (let i2 = 0; i2 < buffer.length; ++i2) {
        buffer[i2] = view[i2];
      }
      return buffer;
    }
    function loadFromURL(options, cb) {
      (0, _request.default)(options, (err, data) => {
        if (err) {
          return cb(err);
        }
        if (typeof data === "object" && Buffer.isBuffer(data)) {
          return cb(null, data);
        }
        if (typeof data === "object" && isArrayBuffer(data)) {
          return cb(null, bufferFromArrayBuffer(data));
        }
        return new Error(`Could not load Buffer from <${options.url}>`);
      });
    }
    function loadBufferFromPath(src, cb) {
      if (_fs.default && typeof _fs.default.readFile === "function" && !src.match(/^(http|ftp)s?:\/\/./)) {
        _fs.default.readFile(src, cb);
      } else {
        loadFromURL({
          url: src
        }, cb);
      }
    }
    function isRawRGBAData(obj) {
      return obj && typeof obj === "object" && typeof obj.width === "number" && typeof obj.height === "number" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === "function" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
    }
    function makeRGBABufferFromRGB(buffer) {
      if (buffer.length % 3 !== 0) {
        throw new Error("Buffer length is incorrect");
      }
      const rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
      let j = 0;
      for (let i2 = 0; i2 < buffer.length; i2++) {
        rgbaBuffer[j] = buffer[i2];
        if ((i2 + 1) % 3 === 0) {
          rgbaBuffer[++j] = 255;
        }
        j++;
      }
      return rgbaBuffer;
    }
    var emptyBitmap = {
      data: null,
      width: null,
      height: null
    };
    var Jimp = class _Jimp extends _events.default {
      // An object representing a bitmap in memory, comprising:
      //  - data: a buffer of the bitmap data
      //  - width: the width of the image in pixels
      //  - height: the height of the image in pixels
      // Default colour to use for new pixels
      // Default MIME is PNG
      // Exif data for the image
      // Whether Transparency supporting formats will be exported as RGB or RGBA
      constructor() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        super();
        _defineProperty(this, "bitmap", emptyBitmap);
        _defineProperty(this, "_background", 0);
        _defineProperty(this, "_originalMime", _Jimp.MIME_PNG);
        _defineProperty(this, "_exif", null);
        _defineProperty(this, "_rgba", true);
        _defineProperty(this, "writeAsync", (path4) => (0, _promisify.default)(this.write, this, path4));
        _defineProperty(this, "getBase64Async", (mime) => (0, _promisify.default)(this.getBase64, this, mime));
        _defineProperty(this, "getBuffer", _imageBitmap.getBuffer);
        _defineProperty(this, "getBufferAsync", _imageBitmap.getBufferAsync);
        _defineProperty(this, "getPixelColour", this.getPixelColor);
        _defineProperty(this, "setPixelColour", this.setPixelColor);
        const jimpInstance = this;
        let cb = noop;
        if (isArrayBuffer(args[0])) {
          args[0] = bufferFromArrayBuffer(args[0]);
        }
        function finish() {
          for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args2[_key2] = arguments[_key2];
          }
          const [err] = args2;
          const evData = err || {};
          evData.methodName = "constructor";
          setTimeout(() => {
            if (err && cb === noop) {
              jimpInstance.emitError("constructor", err);
            } else if (!err) {
              jimpInstance.emitMulti("constructor", "initialized");
            }
            cb.call(jimpInstance, ...args2);
          }, 1);
        }
        if (typeof args[0] === "number" && typeof args[1] === "number" || parseInt(args[0], 10) && parseInt(args[1], 10)) {
          const w = parseInt(args[0], 10);
          const h = parseInt(args[1], 10);
          cb = args[2];
          if (typeof args[2] === "number") {
            this._background = args[2];
            cb = args[3];
          }
          if (typeof args[2] === "string") {
            this._background = _Jimp.cssColorToHex(args[2]);
            cb = args[3];
          }
          if (typeof cb === "undefined") {
            cb = noop;
          }
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", finish);
          }
          this.bitmap = {
            data: Buffer.alloc(w * h * 4),
            width: w,
            height: h
          };
          for (let i2 = 0; i2 < this.bitmap.data.length; i2 += 4) {
            this.bitmap.data.writeUInt32BE(this._background, i2);
          }
          finish(null, this);
        } else if (typeof args[0] === "object" && args[0].url) {
          cb = args[1] || noop;
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", finish);
          }
          loadFromURL(args[0], (err, data) => {
            if (err) {
              return _utils.throwError.call(this, err, finish);
            }
            this.parseBitmap(data, args[0].url, finish);
          });
        } else if (args[0] instanceof _Jimp) {
          const [original] = args;
          cb = args[1];
          if (typeof cb === "undefined") {
            cb = noop;
          }
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", finish);
          }
          this.bitmap = {
            data: Buffer.from(original.bitmap.data),
            width: original.bitmap.width,
            height: original.bitmap.height
          };
          this._quality = original._quality;
          this._deflateLevel = original._deflateLevel;
          this._deflateStrategy = original._deflateStrategy;
          this._filterType = original._filterType;
          this._rgba = original._rgba;
          this._background = original._background;
          this._originalMime = original._originalMime;
          finish(null, this);
        } else if (isRawRGBAData(args[0])) {
          const [imageData] = args;
          cb = args[1] || noop;
          const isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
          const buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
          this.bitmap = {
            data: buffer,
            width: imageData.width,
            height: imageData.height
          };
          finish(null, this);
        } else if (typeof args[0] === "string") {
          const path4 = args[0];
          cb = args[1];
          if (typeof cb === "undefined") {
            cb = noop;
          }
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", finish);
          }
          loadBufferFromPath(path4, (err, data) => {
            if (err) {
              return _utils.throwError.call(this, err, finish);
            }
            this.parseBitmap(data, path4, finish);
          });
        } else if (typeof args[0] === "object" && Buffer.isBuffer(args[0])) {
          const data = args[0];
          cb = args[1];
          if (typeof cb !== "function") {
            return _utils.throwError.call(this, "cb must be a function", finish);
          }
          this.parseBitmap(data, null, finish);
        } else {
          cb = args[args.length - 1];
          if (typeof cb !== "function") {
            cb = args[args.length - 2];
            if (typeof cb !== "function") {
              cb = noop;
            }
          }
          const extraConstructor = _Jimp.__extraConstructors.find((c) => c.test(...args));
          if (extraConstructor) {
            new Promise((resolve5, reject2) => {
              extraConstructor.run.call(this, resolve5, reject2, ...args);
            }).then(() => finish(null, this)).catch(finish);
          } else {
            return _utils.throwError.call(this, "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish);
          }
        }
      }
      /**
       * Parse a bitmap with the loaded image types.
       *
       * @param {Buffer} data raw image data
       * @param {string} path optional path to file
       * @param {function(Error, Jimp)} finish (optional) a callback for when complete
       * @memberof Jimp
       */
      parseBitmap(data, path4, finish) {
        _imageBitmap.parseBitmap.call(this, data, null, finish);
      }
      /**
       * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
       * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      rgba(bool, cb) {
        if (typeof bool !== "boolean") {
          return _utils.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb);
        }
        this._rgba = bool;
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
      /**
       * Emit for multiple listeners
       * @param {string} methodName name of the method to emit an error for
       * @param {string} eventName name of the eventName to emit an error for
       * @param {object} data to emit
       */
      emitMulti(methodName, eventName) {
        let data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        data = Object.assign(data, {
          methodName,
          eventName
        });
        this.emit("any", data);
        if (methodName) {
          this.emit(methodName, data);
        }
        this.emit(eventName, data);
      }
      emitError(methodName, err) {
        this.emitMulti(methodName, "error", err);
      }
      /**
       * Get the current height of the image
       * @return {number} height of the image
       */
      getHeight() {
        return this.bitmap.height;
      }
      /**
       * Get the current width of the image
       * @return {number} width of the image
       */
      getWidth() {
        return this.bitmap.width;
      }
      /**
       * Nicely format Jimp object when sent to the console e.g. console.log(image)
       * @returns {string} pretty printed
       */
      inspect() {
        return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
      }
      /**
       * Nicely format Jimp object when converted to a string
       * @returns {string} pretty printed
       */
      toString() {
        return "[object Jimp]";
      }
      /**
       * Returns the original MIME of the image (default: "image/png")
       * @returns {string} the MIME
       */
      getMIME() {
        const mime = this._originalMime || _Jimp.MIME_PNG;
        return mime;
      }
      /**
       * Returns the appropriate file extension for the original MIME of the image (default: "png")
       * @returns {string} the file extension
       */
      getExtension() {
        const mime = this.getMIME();
        return MIME.getExtension(mime);
      }
      /**
       * Writes the image to a file
       * @param {string} path a path to the destination file
       * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
       * @returns {Jimp} this for chaining of methods
       */
      write(path4, cb) {
        if (!_fs.default || !_fs.default.createWriteStream) {
          throw new Error("Cant access the filesystem. You can use the getBase64 method.");
        }
        if (typeof path4 !== "string") {
          return _utils.throwError.call(this, "path must be a string", cb);
        }
        if (typeof cb === "undefined") {
          cb = noop;
        }
        if (typeof cb !== "function") {
          return _utils.throwError.call(this, "cb must be a function", cb);
        }
        const mime = MIME.getType(path4) || this.getMIME();
        const pathObj = _path.default.parse(path4);
        if (pathObj.dir) {
          _fs.default.mkdirSync(pathObj.dir, {
            recursive: true
          });
        }
        this.getBuffer(mime, (err, buffer) => {
          if (err) {
            return _utils.throwError.call(this, err, cb);
          }
          const stream2 = _fs.default.createWriteStream(path4);
          stream2.on("open", () => {
            stream2.write(buffer);
            stream2.end();
          }).on("error", (err2) => {
            return _utils.throwError.call(this, err2, cb);
          });
          stream2.on("finish", () => {
            cb.call(this, null, this);
          });
        });
        return this;
      }
      /**
       * Converts the image to a base 64 string
       * @param {string} mime the mime type of the image data to be created
       * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
       * @returns {Jimp} this for chaining of methods
       */
      getBase64(mime, cb) {
        if (mime === _Jimp.AUTO) {
          mime = this.getMIME();
        }
        if (typeof mime !== "string") {
          return _utils.throwError.call(this, "mime must be a string", cb);
        }
        if (typeof cb !== "function") {
          return _utils.throwError.call(this, "cb must be a function", cb);
        }
        this.getBuffer(mime, function(err, data) {
          if (err) {
            return _utils.throwError.call(this, err, cb);
          }
          const src = "data:" + mime + ";base64," + data.toString("base64");
          cb.call(this, null, src);
        });
        return this;
      }
      /**
       * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
       * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {string} a string representing the hash
       */
      hash(base, cb) {
        base = base || 64;
        if (typeof base === "function") {
          cb = base;
          base = 64;
        }
        if (typeof base !== "number") {
          return _utils.throwError.call(this, "base must be a number", cb);
        }
        if (base < 2 || base > 64) {
          return _utils.throwError.call(this, "base must be a number between 2 and 64", cb);
        }
        let hash = this.pHash();
        hash = (0, _anyBase.default)(_anyBase.default.BIN, alphabet.slice(0, base))(hash);
        while (hash.length < maxHashLength[base]) {
          hash = "0" + hash;
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, hash);
        }
        return hash;
      }
      /**
       * Calculates the perceptual hash
       * @returns {number} the perceptual hash
       */
      pHash() {
        const pHash = new _phash.default();
        return pHash.getHash(this);
      }
      /**
       * Calculates the hamming distance of the current image and a hash based on their perceptual hash
       * @param {hash} compareHash hash to compare to
       * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
       */
      distanceFromHash(compareHash) {
        const pHash = new _phash.default();
        const currentHash = pHash.getHash(this);
        return pHash.distance(currentHash, compareHash);
      }
      /**
       * Converts the image to a buffer
       * @param {string} mime the mime type of the image buffer to be created
       * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
       * @returns {Jimp} this for chaining of methods
       */
      /**
       * Returns the offset of a pixel in the bitmap buffer
       * @param {number} x the x coordinate
       * @param {number} y the y coordinate
       * @param {number} edgeHandling (optional) define how to sum pixels from outside the border
       * @param {number} cb (optional) a callback for when complete
       * @returns {number} the index of the pixel or -1 if not found
       */
      getPixelIndex(x, y, edgeHandling, cb) {
        let xi;
        let yi;
        if (typeof edgeHandling === "function" && typeof cb === "undefined") {
          cb = edgeHandling;
          edgeHandling = null;
        }
        if (!edgeHandling) {
          edgeHandling = _Jimp.EDGE_EXTEND;
        }
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        }
        x = Math.round(x);
        y = Math.round(y);
        xi = x;
        yi = y;
        if (edgeHandling === _Jimp.EDGE_EXTEND) {
          if (x < 0)
            xi = 0;
          if (x >= this.bitmap.width)
            xi = this.bitmap.width - 1;
          if (y < 0)
            yi = 0;
          if (y >= this.bitmap.height)
            yi = this.bitmap.height - 1;
        }
        if (edgeHandling === _Jimp.EDGE_WRAP) {
          if (x < 0) {
            xi = this.bitmap.width + x;
          }
          if (x >= this.bitmap.width) {
            xi = x % this.bitmap.width;
          }
          if (y < 0) {
            yi = this.bitmap.height + y;
          }
          if (y >= this.bitmap.height) {
            yi = y % this.bitmap.height;
          }
        }
        let i2 = this.bitmap.width * yi + xi << 2;
        if (xi < 0 || xi >= this.bitmap.width) {
          i2 = -1;
        }
        if (yi < 0 || yi >= this.bitmap.height) {
          i2 = -1;
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, i2);
        }
        return i2;
      }
      /**
       * Returns the hex colour value of a pixel
       * @param {number} x the x coordinate
       * @param {number} y the y coordinate
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {number} the color of the pixel
       */
      getPixelColor(x, y, cb) {
        if (typeof x !== "number" || typeof y !== "number")
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        x = Math.round(x);
        y = Math.round(y);
        const idx = this.getPixelIndex(x, y);
        const hex = this.bitmap.data.readUInt32BE(idx);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, hex);
        }
        return hex;
      }
      /**
       * Returns the hex colour value of a pixel
       * @param {number} hex color to set
       * @param {number} x the x coordinate
       * @param {number} y the y coordinate
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {number} the index of the pixel or -1 if not found
       */
      setPixelColor(hex, x, y, cb) {
        if (typeof hex !== "number" || typeof x !== "number" || typeof y !== "number")
          return _utils.throwError.call(this, "hex, x and y must be numbers", cb);
        x = Math.round(x);
        y = Math.round(y);
        const idx = this.getPixelIndex(x, y);
        this.bitmap.data.writeUInt32BE(hex, idx);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
      /**
       * Determine if the image contains opaque pixels.
       * @return {boolean} hasAlpha whether the image contains opaque pixels
       */
      hasAlpha() {
        for (let yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
          for (let xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
            const idx = this.bitmap.width * yIndex + xIndex << 2;
            const alpha = this.bitmap.data[idx + 3];
            if (alpha !== 255) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Iterate scan through a region of the bitmap
       * @param {number} x the x coordinate to begin the scan at
       * @param {number} y the y coordinate to begin the scan at
       * @param w the width of the scan region
       * @param h the height of the scan region
       * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
       */
      scanIterator(x, y, w, h) {
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers");
        }
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers");
        }
        return (0, _utils.scanIterator)(this, x, y, w, h);
      }
    };
    function addConstants(constants3) {
      let jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp;
      Object.entries(constants3).forEach((_ref) => {
        let [name2, value2] = _ref;
        jimpInstance[name2] = value2;
      });
    }
    function addJimpMethods(methods) {
      let jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp;
      Object.entries(methods).forEach((_ref2) => {
        let [name2, value2] = _ref2;
        jimpInstance.prototype[name2] = value2;
      });
    }
    addConstants(constants2);
    addJimpMethods({
      composite: _composite.default
    });
    Jimp.__extraConstructors = [];
    Jimp.appendConstructorOption = function(name2, test, run) {
      Jimp.__extraConstructors.push({
        name: name2,
        test,
        run
      });
    };
    Jimp.read = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return new Promise((resolve5, reject2) => {
        new Jimp(...args, (err, image2) => {
          if (err)
            reject2(err);
          else
            resolve5(image2);
        });
      });
    };
    Jimp.create = Jimp.read;
    Jimp.rgbaToInt = function(r, g, b, a, cb) {
      if (typeof r !== "number" || typeof g !== "number" || typeof b !== "number" || typeof a !== "number") {
        return _utils.throwError.call(this, "r, g, b and a must be numbers", cb);
      }
      if (r < 0 || r > 255) {
        return _utils.throwError.call(this, "r must be between 0 and 255", cb);
      }
      if (g < 0 || g > 255) {
        _utils.throwError.call(this, "g must be between 0 and 255", cb);
      }
      if (b < 0 || b > 255) {
        return _utils.throwError.call(this, "b must be between 0 and 255", cb);
      }
      if (a < 0 || a > 255) {
        return _utils.throwError.call(this, "a must be between 0 and 255", cb);
      }
      r = Math.round(r);
      b = Math.round(b);
      g = Math.round(g);
      a = Math.round(a);
      const i2 = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, i2);
      }
      return i2;
    };
    Jimp.intToRGBA = function(i2, cb) {
      if (typeof i2 !== "number") {
        return _utils.throwError.call(this, "i must be a number", cb);
      }
      const rgba = {};
      rgba.r = Math.floor(i2 / Math.pow(256, 3));
      rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
      rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
      rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, rgba);
      }
      return rgba;
    };
    Jimp.cssColorToHex = function(cssColor) {
      cssColor = cssColor || 0;
      if (typeof cssColor === "number")
        return Number(cssColor);
      return parseInt((0, _tinycolor.default)(cssColor).toHex8(), 16);
    };
    Jimp.limit255 = function(n) {
      n = Math.max(n, 0);
      n = Math.min(n, 255);
      return n;
    };
    Jimp.diff = function(img1, img2) {
      let threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
      if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))
        return _utils.throwError.call(this, "img1 and img2 must be an Jimp images");
      const bmp1 = img1.bitmap;
      const bmp2 = img2.bitmap;
      if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
        if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
          img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);
        } else {
          img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);
        }
      }
      if (typeof threshold !== "number" || threshold < 0 || threshold > 1) {
        return _utils.throwError.call(this, "threshold must be a number between 0 and 1");
      }
      const diff = new Jimp(bmp1.width, bmp1.height, 4294967295);
      const numDiffPixels = (0, _pixelmatch.default)(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
        threshold
      });
      return {
        percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
        image: diff
      };
    };
    Jimp.distance = function(img1, img2) {
      const phash = new _phash.default();
      const hash1 = phash.getHash(img1);
      const hash2 = phash.getHash(img2);
      return phash.distance(hash1, hash2);
    };
    Jimp.compareHashes = function(hash1, hash2) {
      const phash = new _phash.default();
      return phash.distance(hash1, hash2);
    };
    Jimp.colorDiff = function(rgba1, rgba2) {
      const pow = (n) => Math.pow(n, 2);
      const {
        max: max2
      } = Math;
      const maxVal = 255 * 255 * 3;
      if (rgba1.a !== 0 && !rgba1.a) {
        rgba1.a = 255;
      }
      if (rgba2.a !== 0 && !rgba2.a) {
        rgba2.a = 255;
      }
      return (max2(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max2(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max2(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
    };
    function jimpEvMethod(methodName, evName, method) {
      const evNameBefore = "before-" + evName;
      const evNameAfter = evName.replace(/e$/, "") + "ed";
      Jimp.prototype[methodName] = function() {
        let wrappedCb;
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        const cb = args[method.length - 1];
        const jimpInstance = this;
        if (typeof cb === "function") {
          wrappedCb = function() {
            for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args2[_key5] = arguments[_key5];
            }
            const [err, data] = args2;
            if (err) {
              jimpInstance.emitError(methodName, err);
            } else {
              jimpInstance.emitMulti(methodName, evNameAfter, {
                [methodName]: data
              });
            }
            cb.apply(this, args2);
          };
          args[args.length - 1] = wrappedCb;
        } else {
          wrappedCb = false;
        }
        this.emitMulti(methodName, evNameBefore);
        let result;
        try {
          result = method.apply(this, args);
          if (!wrappedCb) {
            this.emitMulti(methodName, evNameAfter, {
              [methodName]: result
            });
          }
        } catch (error) {
          error.methodName = methodName;
          this.emitError(methodName, error);
        }
        return result;
      };
      Jimp.prototype[methodName + "Quiet"] = method;
    }
    jimpEvMethod("clone", "clone", function(cb) {
      const clone = new Jimp(this);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(clone, null, clone);
      }
      return clone;
    });
    function jimpEvChange(methodName, method) {
      jimpEvMethod(methodName, "change", method);
    }
    jimpEvChange("background", function(hex, cb) {
      if (typeof hex !== "number") {
        return _utils.throwError.call(this, "hex must be a hexadecimal rgba value", cb);
      }
      this._background = hex;
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    });
    jimpEvChange("scan", function(x, y, w, h, f, cb) {
      if (typeof x !== "number" || typeof y !== "number") {
        return _utils.throwError.call(this, "x and y must be numbers", cb);
      }
      if (typeof w !== "number" || typeof h !== "number") {
        return _utils.throwError.call(this, "w and h must be numbers", cb);
      }
      if (typeof f !== "function") {
        return _utils.throwError.call(this, "f must be a function", cb);
      }
      const result = (0, _utils.scan)(this, x, y, w, h, f);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, result);
      }
      return result;
    });
    if (process.env.ENVIRONMENT === "BROWSER") {
      let gl;
      if (typeof window !== "undefined" && typeof window === "object") {
        gl = window;
      }
      if (typeof self !== "undefined" && typeof self === "object") {
        gl = self;
      }
      gl.Jimp = Jimp;
      gl.Buffer = Buffer;
    }
    var _default = Jimp;
    exports2.default = _default;
  }
});

// node_modules/@jimp/custom/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@jimp/custom/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = configure;
    var _core = _interopRequireWildcard(require_dist2());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function configure(configuration) {
      let jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _core.default;
      const jimpConfig = {
        hasAlpha: {},
        encoders: {},
        decoders: {},
        class: {},
        constants: {}
      };
      function addToConfig(newConfig) {
        Object.entries(newConfig).forEach((_ref) => {
          let [key, value2] = _ref;
          jimpConfig[key] = {
            ...jimpConfig[key],
            ...value2
          };
        });
      }
      function addImageType(typeModule) {
        const type = typeModule();
        if (Array.isArray(type.mime)) {
          (0, _core.addType)(...type.mime);
        } else {
          Object.entries(type.mime).forEach((mimeType) => (0, _core.addType)(...mimeType));
        }
        delete type.mime;
        addToConfig(type);
      }
      function addPlugin(pluginModule) {
        const plugin = pluginModule(_core.jimpEvChange) || {};
        if (!plugin.class && !plugin.constants) {
          addToConfig({
            class: plugin
          });
        } else {
          addToConfig(plugin);
        }
      }
      if (configuration.types) {
        configuration.types.forEach(addImageType);
        jimpInstance.decoders = {
          ...jimpInstance.decoders,
          ...jimpConfig.decoders
        };
        jimpInstance.encoders = {
          ...jimpInstance.encoders,
          ...jimpConfig.encoders
        };
        jimpInstance.hasAlpha = {
          ...jimpInstance.hasAlpha,
          ...jimpConfig.hasAlpha
        };
      }
      if (configuration.plugins) {
        configuration.plugins.forEach(addPlugin);
      }
      (0, _core.addJimpMethods)(jimpConfig.class, jimpInstance);
      (0, _core.addConstants)(jimpConfig.constants, jimpInstance);
      return _core.default;
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/timm/lib/timm.js
var require_timm = __commonJS({
  "node_modules/timm/lib/timm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clone = clone;
    exports2.addLast = addLast;
    exports2.addFirst = addFirst;
    exports2.removeLast = removeLast;
    exports2.removeFirst = removeFirst;
    exports2.insert = insert;
    exports2.removeAt = removeAt;
    exports2.replaceAt = replaceAt;
    exports2.getIn = getIn;
    exports2.set = set;
    exports2.setIn = setIn;
    exports2.update = update;
    exports2.updateIn = updateIn;
    exports2.merge = merge;
    exports2.mergeDeep = mergeDeep;
    exports2.mergeIn = mergeIn;
    exports2.omit = omit;
    exports2.addDefaults = addDefaults;
    exports2.default = void 0;
    var INVALID_ARGS = "INVALID_ARGS";
    var IS_DEV = process.env.NODE_ENV !== "production";
    function throwStr(msg) {
      throw new Error(msg);
    }
    function getKeysAndSymbols(obj) {
      const keys = Object.keys(obj);
      if (Object.getOwnPropertySymbols) {
        return keys.concat(Object.getOwnPropertySymbols(obj));
      }
      return keys;
    }
    var hasOwnProperty = {}.hasOwnProperty;
    function clone(obj0) {
      if (Array.isArray(obj0))
        return obj0.slice();
      const obj = obj0;
      const keys = getKeysAndSymbols(obj);
      const out = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        out[key] = obj[key];
      }
      return out;
    }
    function isObject(o) {
      return o != null && typeof o === "object";
    }
    function addLast(array, val) {
      if (Array.isArray(val))
        return array.concat(val);
      return array.concat([val]);
    }
    function addFirst(array, val) {
      if (Array.isArray(val))
        return val.concat(array);
      return [val].concat(array);
    }
    function removeLast(array) {
      if (!array.length)
        return array;
      return array.slice(0, array.length - 1);
    }
    function removeFirst(array) {
      if (!array.length)
        return array;
      return array.slice(1);
    }
    function insert(array, idx, val) {
      return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));
    }
    function removeAt(array, idx) {
      if (idx >= array.length || idx < 0)
        return array;
      return array.slice(0, idx).concat(array.slice(idx + 1));
    }
    function replaceAt(array, idx, newItem) {
      if (array[idx] === newItem)
        return array;
      const len = array.length;
      const result = Array(len);
      for (let i2 = 0; i2 < len; i2++) {
        result[i2] = array[i2];
      }
      result[idx] = newItem;
      return result;
    }
    function getIn(obj, path4) {
      if (!Array.isArray(path4)) {
        throwStr(IS_DEV ? "A path array should be provided when calling getIn()" : INVALID_ARGS);
      }
      if (obj == null)
        return void 0;
      let ptr = obj;
      for (let i2 = 0; i2 < path4.length; i2++) {
        const key = path4[i2];
        ptr = ptr != null ? ptr[key] : void 0;
        if (ptr === void 0)
          return ptr;
      }
      return ptr;
    }
    function set(obj0, key, val) {
      let obj = obj0;
      if (obj == null)
        obj = typeof key === "number" ? [] : {};
      if (obj[key] === val)
        return obj;
      const obj2 = clone(obj);
      obj2[key] = val;
      return obj2;
    }
    function setIn(obj, path4, val) {
      if (!path4.length)
        return val;
      return doSetIn(obj, path4, val, 0);
    }
    function doSetIn(obj, path4, val, idx) {
      let newValue;
      const key = path4[idx];
      if (idx === path4.length - 1) {
        newValue = val;
      } else {
        const nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path4[idx + 1] === "number" ? [] : {};
        newValue = doSetIn(nestedObj, path4, val, idx + 1);
      }
      return set(obj, key, newValue);
    }
    function update(obj, key, fnUpdate) {
      const prevVal = obj == null ? void 0 : obj[key];
      const nextVal = fnUpdate(prevVal);
      return set(obj, key, nextVal);
    }
    function updateIn(obj, path4, fnUpdate) {
      const prevVal = getIn(obj, path4);
      const nextVal = fnUpdate(prevVal);
      return setIn(obj, path4, nextVal);
    }
    function merge(a, b, c, d, e, f, ...rest) {
      return rest.length ? doMerge.call(null, false, false, a, b, c, d, e, f, ...rest) : doMerge(false, false, a, b, c, d, e, f);
    }
    function mergeDeep(a, b, c, d, e, f, ...rest) {
      return rest.length ? doMerge.call(null, false, true, a, b, c, d, e, f, ...rest) : doMerge(false, true, a, b, c, d, e, f);
    }
    function mergeIn(a, path4, b, c, d, e, f, ...rest) {
      let prevVal = getIn(a, path4);
      if (prevVal == null)
        prevVal = {};
      let nextVal;
      if (rest.length) {
        nextVal = doMerge.call(null, false, false, prevVal, b, c, d, e, f, ...rest);
      } else {
        nextVal = doMerge(false, false, prevVal, b, c, d, e, f);
      }
      return setIn(a, path4, nextVal);
    }
    function omit(obj, attrs) {
      const omitList = Array.isArray(attrs) ? attrs : [attrs];
      let fDoSomething = false;
      for (let i2 = 0; i2 < omitList.length; i2++) {
        if (hasOwnProperty.call(obj, omitList[i2])) {
          fDoSomething = true;
          break;
        }
      }
      if (!fDoSomething)
        return obj;
      const out = {};
      const keys = getKeysAndSymbols(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (omitList.indexOf(key) >= 0)
          continue;
        out[key] = obj[key];
      }
      return out;
    }
    function addDefaults(a, b, c, d, e, f, ...rest) {
      return rest.length ? doMerge.call(null, true, false, a, b, c, d, e, f, ...rest) : doMerge(true, false, a, b, c, d, e, f);
    }
    function doMerge(fAddDefaults, fDeep, first, ...rest) {
      let out = first;
      if (!(out != null)) {
        throwStr(IS_DEV ? "At least one object should be provided to merge()" : INVALID_ARGS);
      }
      let fChanged = false;
      for (let idx = 0; idx < rest.length; idx++) {
        const obj = rest[idx];
        if (obj == null)
          continue;
        const keys = getKeysAndSymbols(obj);
        if (!keys.length)
          continue;
        for (let j = 0; j <= keys.length; j++) {
          const key = keys[j];
          if (fAddDefaults && out[key] !== void 0)
            continue;
          let nextVal = obj[key];
          if (fDeep && isObject(out[key]) && isObject(nextVal)) {
            nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);
          }
          if (nextVal === void 0 || nextVal === out[key])
            continue;
          if (!fChanged) {
            fChanged = true;
            out = clone(out);
          }
          out[key] = nextVal;
        }
      }
      return out;
    }
    var timm = {
      clone,
      addLast,
      addFirst,
      removeLast,
      removeFirst,
      insert,
      removeAt,
      replaceAt,
      getIn,
      set,
      setIn,
      update,
      updateIn,
      merge,
      mergeDeep,
      mergeIn,
      omit,
      addDefaults
    };
    var _default = timm;
    exports2.default = _default;
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa = btoa || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality2) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i2 = 0; i2 < 64; i2++) {
          var t = ffloor((YQT[i2] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i2]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i2 = 0; i2 < 256; i2++) {
          RGB_YUV_TABLE[i2] = 19595 * i2;
          RGB_YUV_TABLE[i2 + 256 >> 0] = 38470 * i2;
          RGB_YUV_TABLE[i2 + 512 >> 0] = 7471 * i2 + 32768;
          RGB_YUV_TABLE[i2 + 768 >> 0] = -11059 * i2;
          RGB_YUV_TABLE[i2 + 1024 >> 0] = -21709 * i2;
          RGB_YUV_TABLE[i2 + 1280 >> 0] = 32768 * i2 + 8421375;
          RGB_YUV_TABLE[i2 + 1536 >> 0] = -27439 * i2;
          RGB_YUV_TABLE[i2 + 1792 >> 0] = -5329 * i2;
        }
      }
      function writeBits(bs) {
        var value2 = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value2 & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value2) {
        byteout.push(value2);
      }
      function writeWord(value2) {
        writeByte(value2 >> 8 & 255);
        writeByte(value2 & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i2;
        var I8 = 8;
        var I64 = 64;
        for (i2 = 0; i2 < I8; ++i2) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i2 = 0; i2 < I8; ++i2) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i2 = 0; i2 < I64; ++i2) {
          fDCTQuant2 = data[i2] * fdtbl[i2];
          outputfDCTQuant[i2] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i2 = 0; i2 < exifBuffer.length; i2++) {
          writeByte(exifBuffer[i2]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i2 = 0; i2 < 64; i2++) {
          writeByte(YTable[i2]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i2 = 0; i2 < 16; i2++) {
          writeByte(std_dc_luminance_nrcodes[i2 + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeCOM(comments) {
        if (typeof comments === "undefined" || comments.constructor !== Array)
          return;
        comments.forEach((e) => {
          if (typeof e !== "string")
            return;
          writeWord(65534);
          var l = e.length;
          writeWord(l + 2);
          var i2;
          for (i2 = 0; i2 < l; i2++)
            writeByte(e.charCodeAt(i2));
        });
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i2 = 1;
        var lng;
        while (i2 <= end0pos) {
          var startpos = i2;
          for (; DU[i2] == 0 && i2 <= end0pos; ++i2) {
          }
          var nrzeroes = i2 - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i2];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i2++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i2 = 0; i2 < 256; i2++) {
          clt[i2] = sfcc(i2);
        }
      }
      this.encode = function(image2, quality3) {
        var time_start = (/* @__PURE__ */ new Date()).getTime();
        if (quality3)
          setQuality(quality3);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeCOM(image2.comments);
        writeAPP1(image2.exifBuffer);
        writeDQT();
        writeSOF0(image2.width, image2.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image2.data;
        var width = image2.width;
        var height = image2.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module2 === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
        byteout = [];
        var duration = (/* @__PURE__ */ new Date()).getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality3) {
        if (quality3 <= 0) {
          quality3 = 1;
        }
        if (quality3 > 100) {
          quality3 = 100;
        }
        if (currentQuality == quality3)
          return;
        var sf = 0;
        if (quality3 < 50) {
          sf = Math.floor(5e3 / quality3);
        } else {
          sf = Math.floor(200 - quality3 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality3;
      }
      function init() {
        var time_start = (/* @__PURE__ */ new Date()).getTime();
        if (!quality2)
          quality2 = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality2);
        var duration = (/* @__PURE__ */ new Date()).getTime() - time_start;
      }
      init();
    }
    if (typeof module2 !== "undefined") {
      module2.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i2, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i2 = 0; i2 < length; i2++) {
          for (j = 0; j < codeLengths[i2]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i2) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i2 + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i2, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i2 = 0; i2 < componentsLength; i2++)
            components[i2].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i2 = 0; i2 < componentsLength; i2++) {
                component = components[i2];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i3;
          for (i3 = 0; i3 < 64; i3++)
            p[i3] = zz[i3] * qt[i3];
          for (i3 = 0; i3 < 8; ++i3) {
            var row = 8 * i3;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i3 = 0; i3 < 8; ++i3) {
            var col = i3;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i3 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i3 = 0; i3 < 64; ++i3) {
            var sample2 = 128 + (p[i3] + 8 >> 4);
            dataOut[i3] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i2, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i2 = 0; i2 < 8; i2++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i2 = 0; i2 < 8; i2++)
                line[sample + i2] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path4) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path4, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value2 = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value2;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 1, maxV2 = 1;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i3 = 0; i3 < blocksPerColumnForMcu; i3++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i2, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i2 = 0; i2 < componentsCount; i2++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  if (h <= 0 || v <= 0) {
                    throw new Error("Invalid sampling factor, expected values above 0");
                  }
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i2 = 2; i2 < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i2 += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i2 = 0; i2 < selectorsCount; i2++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(
                  data,
                  offset,
                  frame,
                  components,
                  resetInterval,
                  spectralStart,
                  spectralEnd,
                  successiveApproximation >> 4,
                  successiveApproximation & 15,
                  this.opts
                );
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i2 = 0; i2 < frames.length; i2++) {
            var cp = frames[i2].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i2 = 0; i2 < frame.componentsOrder.length; i2++) {
            var component = frame.components[frame.componentsOrder[i2]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i2 = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i2++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i2++];
                  G = data[i2++];
                  B = data[i2++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i2++];
                  M = data[i2++];
                  Y = data[i2++];
                  K = data[i2++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module2 !== "undefined") {
      module2.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        // "undefined" means "Choose whether to transform colors based on the image’s color model."
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        // Don't decode more than 100 megapixels
        maxMemoryUsageInMB: 512
        // Don't decode if memory footprint is more than 512MB
      };
      var opts = { ...defaultOpts, ...userOpts };
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image2 = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image2["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        }
        if (err instanceof ReferenceError) {
          if (err.message === "Buffer is not defined") {
            throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
          }
        }
        throw err;
      }
      decoder.copyToImageData(image2, opts.formatAsRGBA);
      return image2;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode = require_encoder();
    var decode = require_decoder();
    module2.exports = {
      encode,
      decode
    };
  }
});

// node_modules/@jimp/jpeg/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@jimp/jpeg/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _jpegJs = _interopRequireDefault(require_jpeg_js());
    var _utils = require_dist();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MIME_TYPE = "image/jpeg";
    var _default = () => ({
      mime: {
        [MIME_TYPE]: ["jpeg", "jpg", "jpe"]
      },
      constants: {
        MIME_JPEG: MIME_TYPE
      },
      decoders: {
        [MIME_TYPE]: _jpegJs.default.decode
      },
      encoders: {
        [MIME_TYPE]: (image2) => _jpegJs.default.encode(image2.bitmap, image2._quality).data
      },
      class: {
        // The quality to be used when saving JPEG images
        _quality: 100,
        /**
         * Sets the quality of the image when saving as JPEG format (default is 100)
         * @param {number} n The quality to use 0-100
         * @param {function(Error, Jimp)} cb (optional) a callback for when complete
         * @returns {Jimp} this for chaining of methods
         */
        quality(n, cb) {
          if (typeof n !== "number") {
            return _utils.throwError.call(this, "n must be a number", cb);
          }
          if (n < 0 || n > 100) {
            return _utils.throwError.call(this, "n must be a number 0 - 100", cb);
          }
          this._quality = Math.round(n);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        // if length < 0 then at most this length
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(
        function() {
          this._process();
          if (this._paused && this._reads && this._reads.length > 0) {
            this._paused = false;
            this.emit("drain");
          }
        }.bind(this)
      );
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read.length);
      while (pos < read.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        // pass 1 - 1px
        x: [0],
        y: [0]
      },
      {
        // pass 2 - 1px
        x: [4],
        y: [0]
      },
      {
        // pass 3 - 2px
        x: [0, 4],
        y: [4]
      },
      {
        // pass 4 - 4px
        x: [2, 6],
        y: [0, 4]
      },
      {
        // pass 5 - 8px
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        // pass 6 - 16px
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        // pass 7 - 32px
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i2 = 0; i2 < imagePasses.length; i2++) {
        let pass = imagePasses[i2];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i2 });
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        let outerXLeftOver = x % imagePasses[pass].x.length;
        let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i2 = 0; i2 < passes.length; i2++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i2].width, bpp, depth),
            height: passes[i2].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(
        this._images[this._imageIndex].byteWidth + 1,
        this._reverseFilterLine.bind(this)
      );
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f3Up = lastLine ? lastLine[x] : 0;
        let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f4Up = lastLine ? lastLine[x] : 0;
        let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      // eslint-disable-line camelcase
      TYPE_gAMA: 1732332865,
      // eslint-disable-line camelcase
      // color-type bits
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      // e.g. grayscale and alpha
      // color-type combinations
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i2 = 0; i2 < 256; i2++) {
        let currentCrc = i2;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i2] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i2 = 0; i2 < data.length; i2++) {
        this._crc = crcTable[(this._crc ^ data[i2]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i2 = 0; i2 < buf.length; i2++) {
        crc = crcTable[(crc ^ buf[i2]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants2 = require_constants2();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants2.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants2.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants2.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants2.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants2.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants2.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants2.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants2.PNG_SIGNATURE;
      for (let i2 = 0; i2 < signature.length; i2++) {
        if (data[i2] !== signature[i2]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name2 = "";
      for (let i2 = 4; i2 < 8; i2++) {
        name2 += String.fromCharCode(data[i2]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants2.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name2));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name2));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants2.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants2.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants2.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants2.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i2 = 0; i2 < entries; i2++) {
        this._palette.push([data[i2 * 3], data[i2 * 3 + 1], data[i2 * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i2 = 0; i2 < data.length; i2++) {
          this._palette[i2][3] = data[i2];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants2.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants2.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants2.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants2.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      // 0 - dummy entry
      function() {
      },
      // 1 - L
      // 0: 0, 1: 0, 2: 0, 3: 0xff
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      // 2 - LA
      // 0: 0, 1: 0, 2: 0, 3: 1
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      // 3 - RGB
      // 0: 0, 1: 1, 2: 2, 3: 0xff
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      // 4 - RGBA
      // 0: 0, 1: 1, 2: 2, 3: 3
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      // 0 - dummy entry
      function() {
      },
      // 1 - L
      // 0: 0, 1: 0, 2: 0, 3: 0xff
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      // 2 - LA
      // 0: 0, 1: 0, 2: 0, 3: 1
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      // 3 - RGB
      // 0: 0, 1: 1, 2: 2, 3: 0xff
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      // 4 - RGBA
      // 0: 0, 1: 1, 2: 2, 3: 3
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i2 = 0;
      function split() {
        if (i2 === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i2];
        i2++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i2];
            i2++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i2 !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image2, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image2.width;
      let imageHeight = image2.height;
      let imagePass = image2.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image2, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image2.width;
      let imageHeight = image2.height;
      let imagePass = image2.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(
            images[imageIndex],
            pxData,
            getPxPos,
            bpp,
            data,
            rawPos
          );
        } else {
          mapImageCustomBit(
            images[imageIndex],
            pxData,
            getPxPos,
            bpp,
            bits,
            maxBit
          );
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette2) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let color = palette2[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = color[i2];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i2 = 0; i2 < 4; i2++) {
              outdata[pxPos + i2] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let i2 = 0; i2 < 4; i2++) {
            outdata[pxPos + i2] = Math.floor(
              indata[pxPos + i2] * maxOutSample / maxInSample + 0.5
            );
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData, skipRescale = false) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette2 = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette2);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8 && !skipRescale) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var zlib = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser2();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
          this._inflate = zlib.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk2) {
            if (!leftToInflate) {
              return;
            }
            if (chunk2.length > leftToInflate) {
              chunk2 = chunk2.slice(0, leftToInflate);
            }
            leftToInflate -= chunk2.length;
            filterWrite(chunk2);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette2) {
      this._bitmapInfo.palette = palette2;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(
          bitmapData,
          this._bitmapInfo,
          this._options.skipRescale
        );
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants2 = require_constants2();
    module2.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants2.COLORTYPE_COLOR_ALPHA, constants2.COLORTYPE_ALPHA].indexOf(
        options.colorType
      ) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(
            0,
            256,
            true
            /* littleEndian */
          );
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants2.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants2.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants2.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants2.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants2.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants2.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error(
              "input color type:" + options.inputColorType + " is not supported at present"
            );
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(
              Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),
              maxValue
            );
            green = Math.min(
              Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),
              maxValue
            );
            blue = Math.min(
              Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),
              maxValue
            );
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants2.COLORTYPE_COLOR_ALPHA:
            case constants2.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants2.COLORTYPE_ALPHA:
            case constants2.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i2 = pxPos; i2 < length; i2++) {
        sum += Math.abs(pxData[i2]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x = pxPos; x < length; x++) {
        let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        let val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min2 = Infinity;
          for (let i2 = 0; i2 < filterTypes.length; i2++) {
            let sum = filterSums[filterTypes[i2]](pxData, pxPos, byteWidth, bpp);
            if (sum < min2) {
              sel = filterTypes[i2];
              min2 = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants2 = require_constants2();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants2.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants2.COLORTYPE_COLOR_ALPHA;
      if ([
        constants2.COLORTYPE_GRAYSCALE,
        constants2.COLORTYPE_COLOR,
        constants2.COLORTYPE_COLOR_ALPHA,
        constants2.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error(
          "option color type:" + options.colorType + " is not supported at present"
        );
      }
      if ([
        constants2.COLORTYPE_GRAYSCALE,
        constants2.COLORTYPE_COLOR,
        constants2.COLORTYPE_COLOR_ALPHA,
        constants2.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error(
          "option input color type:" + options.inputColorType + " is not supported at present"
        );
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error(
          "option bit depth:" + options.bitDepth + " is not supported at present"
        );
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(
        CrcStream.crc32(buf.slice(4, buf.length - 4)),
        buf.length - 4
      );
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants2.GAMMA_DIVISION), 0);
      return this._packChunk(constants2.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants2.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants2.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants2.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var constants2 = require_constants2();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants2.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on(
        "data",
        function(compressedData) {
          this.emit("data", this._packer.packIDAT(compressedData));
        }.bind(this)
      );
      this._deflate.on(
        "end",
        function() {
          this.emit("data", this._packer.packIEND());
          this.emit("end");
        }.bind(this)
      );
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports2, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
        opts.chunkSize = zlib.Z_MIN_CHUNK;
      }
      zlib.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk2, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib.Inflate._processChunk.call(this, chunk2, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk2 && chunk2.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error;
      this.on("error", function(err) {
        error = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(
          flushFlag,
          chunk2,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError(
          "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes"
        );
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports2 = inflateSync;
    exports2.Inflate = Inflate;
    exports2.createInflate = createInflate;
    exports2.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        // if length < 0 then at most this length
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        throw new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        throw new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports2.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser2();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error(
          "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
        );
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette2) {
        metaData.palette = palette2;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(
        bitmapData,
        metaData,
        options.skipRescale
      );
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var constants2 = require_constants2();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error(
          "To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"
        );
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants2.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(
        metaData.data,
        metaData.width,
        metaData.height
      );
      let compressedData = zlib.deflateSync(
        filteredData,
        packer.getDeflateOptions()
      );
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports2.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports2.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports2.PNG = function(options) {
      Stream.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on(
        "parsed",
        function(data) {
          this.data = data;
          this.emit("parsed", data);
        }.bind(this)
      );
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(
        function() {
          this._packer.pack(this.data, this.width, this.height, this.gamma);
        }.bind(this)
      );
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(
          dst.data,
          (deltaY + y) * dst.width + deltaX << 2,
          (srcY + y) * src.width + srcX << 2,
          (srcY + y) * src.width + srcX + width << 2
        );
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x = 0; x < src.width; x++) {
            let idx = src.width * y + x << 2;
            for (let i2 = 0; i2 < 3; i2++) {
              let sample = src.data[idx + i2] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i2] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/@jimp/png/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@jimp/png/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _pngjs = require_png();
    var _utils = require_dist();
    var MIME_TYPE = "image/png";
    var PNG_FILTER_AUTO = -1;
    var PNG_FILTER_NONE = 0;
    var PNG_FILTER_SUB = 1;
    var PNG_FILTER_UP = 2;
    var PNG_FILTER_AVERAGE = 3;
    var PNG_FILTER_PATH = 4;
    var _default = () => ({
      mime: {
        [MIME_TYPE]: ["png"]
      },
      constants: {
        MIME_PNG: MIME_TYPE,
        PNG_FILTER_AUTO,
        PNG_FILTER_NONE,
        PNG_FILTER_SUB,
        PNG_FILTER_UP,
        PNG_FILTER_AVERAGE,
        PNG_FILTER_PATH
      },
      hasAlpha: {
        [MIME_TYPE]: true
      },
      decoders: {
        [MIME_TYPE]: _pngjs.PNG.sync.read
      },
      encoders: {
        [MIME_TYPE](data) {
          const png = new _pngjs.PNG({
            width: data.bitmap.width,
            height: data.bitmap.height
          });
          png.data = data.bitmap.data;
          return _pngjs.PNG.sync.write(png, {
            deflateLevel: data._deflateLevel,
            deflateStrategy: data._deflateStrategy,
            filterType: data._filterType,
            colorType: typeof data._colorType === "number" ? data._colorType : data._rgba ? 6 : 2,
            inputHasAlpha: data._rgba
          });
        }
      },
      class: {
        _deflateLevel: 9,
        _deflateStrategy: 3,
        _filterType: PNG_FILTER_AUTO,
        _colorType: null,
        /**
         * Sets the deflate level used when saving as PNG format (default is 9)
         * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.
         * @param {function(Error, Jimp)} cb (optional) a callback for when complete
         * @returns {Jimp} this for chaining of methods
         */
        deflateLevel(l, cb) {
          if (typeof l !== "number") {
            return _utils.throwError.call(this, "l must be a number", cb);
          }
          if (l < 0 || l > 9) {
            return _utils.throwError.call(this, "l must be a number 0 - 9", cb);
          }
          this._deflateLevel = Math.round(l);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        /**
         * Sets the deflate strategy used when saving as PNG format (default is 3)
         * @param {number} s Deflate strategy to use 0-3.
         * @param {function(Error, Jimp)} cb (optional) a callback for when complete
         * @returns {Jimp} this for chaining of methods
         */
        deflateStrategy(s, cb) {
          if (typeof s !== "number") {
            return _utils.throwError.call(this, "s must be a number", cb);
          }
          if (s < 0 || s > 3) {
            return _utils.throwError.call(this, "s must be a number 0 - 3", cb);
          }
          this._deflateStrategy = Math.round(s);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        /**
         * Sets the filter type used when saving as PNG format (default is automatic filters)
         * @param {number} f The quality to use -1-4.
         * @param {function(Error, Jimp)} cb (optional) a callback for when complete
         * @returns {Jimp} this for chaining of methods
         */
        filterType(f, cb) {
          if (typeof f !== "number") {
            return _utils.throwError.call(this, "n must be a number", cb);
          }
          if (f < -1 || f > 4) {
            return _utils.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb);
          }
          this._filterType = Math.round(f);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        },
        /**
         * Sets the color type used when saving as PNG format
         * @param {number} s color type to use 0, 2, 4, 6.
         * @param {function(Error, Jimp)} cb (optional) a callback for when complete
         * @returns {Jimp} this for chaining of methods
         */
        colorType(s, cb) {
          if (typeof s !== "number") {
            return _utils.throwError.call(this, "s must be a number", cb);
          }
          if (s !== 0 && s !== 2 && s !== 4 && s !== 6) {
            return _utils.throwError.call(this, "s must be a number 0, 2, 4, 6.", cb);
          }
          this._colorType = Math.round(s);
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/bmp-js/lib/encoder.js
var require_encoder2 = __commonJS({
  "node_modules/bmp-js/lib/encoder.js"(exports2, module2) {
    function BmpEncoder(imgData) {
      this.buffer = imgData.data;
      this.width = imgData.width;
      this.height = imgData.height;
      this.extraBytes = this.width % 4;
      this.rgbSize = this.height * (3 * this.width + this.extraBytes);
      this.headerInfoSize = 40;
      this.data = [];
      this.flag = "BM";
      this.reserved = 0;
      this.offset = 54;
      this.fileSize = this.rgbSize + this.offset;
      this.planes = 1;
      this.bitPP = 24;
      this.compress = 0;
      this.hr = 0;
      this.vr = 0;
      this.colors = 0;
      this.importantColors = 0;
    }
    BmpEncoder.prototype.encode = function() {
      var tempBuffer = new Buffer(this.offset + this.rgbSize);
      this.pos = 0;
      tempBuffer.write(this.flag, this.pos, 2);
      this.pos += 2;
      tempBuffer.writeUInt32LE(this.fileSize, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.reserved, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.offset, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.width, this.pos);
      this.pos += 4;
      tempBuffer.writeInt32LE(-this.height, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt16LE(this.planes, this.pos);
      this.pos += 2;
      tempBuffer.writeUInt16LE(this.bitPP, this.pos);
      this.pos += 2;
      tempBuffer.writeUInt32LE(this.compress, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.rgbSize, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.hr, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.vr, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.colors, this.pos);
      this.pos += 4;
      tempBuffer.writeUInt32LE(this.importantColors, this.pos);
      this.pos += 4;
      var i2 = 0;
      var rowBytes = 3 * this.width + this.extraBytes;
      for (var y = 0; y < this.height; y++) {
        for (var x = 0; x < this.width; x++) {
          var p = this.pos + y * rowBytes + x * 3;
          i2++;
          tempBuffer[p] = this.buffer[i2++];
          tempBuffer[p + 1] = this.buffer[i2++];
          tempBuffer[p + 2] = this.buffer[i2++];
        }
        if (this.extraBytes > 0) {
          var fillOffset = this.pos + y * rowBytes + this.width * 3;
          tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
        }
      }
      return tempBuffer;
    };
    module2.exports = function(imgData, quality2) {
      if (typeof quality2 === "undefined")
        quality2 = 100;
      var encoder = new BmpEncoder(imgData);
      var data = encoder.encode();
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    };
  }
});

// node_modules/bmp-js/lib/decoder.js
var require_decoder2 = __commonJS({
  "node_modules/bmp-js/lib/decoder.js"(exports2, module2) {
    function BmpDecoder(buffer, is_with_alpha) {
      this.pos = 0;
      this.buffer = buffer;
      this.is_with_alpha = !!is_with_alpha;
      this.bottom_up = true;
      this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
      if (this.flag != "BM")
        throw new Error("Invalid BMP File");
      this.parseHeader();
      this.parseRGBA();
    }
    BmpDecoder.prototype.parseHeader = function() {
      this.fileSize = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.reserved = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.offset = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.headerSize = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.width = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.height = this.buffer.readInt32LE(this.pos);
      this.pos += 4;
      this.planes = this.buffer.readUInt16LE(this.pos);
      this.pos += 2;
      this.bitPP = this.buffer.readUInt16LE(this.pos);
      this.pos += 2;
      this.compress = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.rawSize = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.hr = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.vr = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.colors = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      this.importantColors = this.buffer.readUInt32LE(this.pos);
      this.pos += 4;
      if (this.bitPP === 16 && this.is_with_alpha) {
        this.bitPP = 15;
      }
      if (this.bitPP < 15) {
        var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
        this.palette = new Array(len);
        for (var i2 = 0; i2 < len; i2++) {
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var quad = this.buffer.readUInt8(this.pos++);
          this.palette[i2] = {
            red,
            green,
            blue,
            quad
          };
        }
      }
      if (this.height < 0) {
        this.height *= -1;
        this.bottom_up = false;
      }
    };
    BmpDecoder.prototype.parseRGBA = function() {
      var bitn = "bit" + this.bitPP;
      var len = this.width * this.height * 4;
      this.data = new Buffer(len);
      this[bitn]();
    };
    BmpDecoder.prototype.bit1 = function() {
      var xlen = Math.ceil(this.width / 8);
      var mode = xlen % 4;
      var y = this.height >= 0 ? this.height - 1 : -this.height;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < xlen; x++) {
          var b = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 8 * 4;
          for (var i2 = 0; i2 < 8; i2++) {
            if (x * 8 + i2 < this.width) {
              var rgb = this.palette[b >> 7 - i2 & 1];
              this.data[location + i2 * 4] = 0;
              this.data[location + i2 * 4 + 1] = rgb.blue;
              this.data[location + i2 * 4 + 2] = rgb.green;
              this.data[location + i2 * 4 + 3] = rgb.red;
            } else {
              break;
            }
          }
        }
        if (mode != 0) {
          this.pos += 4 - mode;
        }
      }
    };
    BmpDecoder.prototype.bit4 = function() {
      if (this.compress == 2) {
        let setPixelData2 = function(rgbIndex) {
          var rgb2 = this.palette[rgbIndex];
          this.data[location] = 0;
          this.data[location + 1] = rgb2.blue;
          this.data[location + 2] = rgb2.green;
          this.data[location + 3] = rgb2.red;
          location += 4;
        };
        var setPixelData = setPixelData2;
        this.data.fill(255);
        var location = 0;
        var lines = this.bottom_up ? this.height - 1 : 0;
        var low_nibble = false;
        while (location < this.data.length) {
          var a = this.buffer.readUInt8(this.pos++);
          var b = this.buffer.readUInt8(this.pos++);
          if (a == 0) {
            if (b == 0) {
              if (this.bottom_up) {
                lines--;
              } else {
                lines++;
              }
              location = lines * this.width * 4;
              low_nibble = false;
              continue;
            } else if (b == 1) {
              break;
            } else if (b == 2) {
              var x = this.buffer.readUInt8(this.pos++);
              var y = this.buffer.readUInt8(this.pos++);
              if (this.bottom_up) {
                lines -= y;
              } else {
                lines += y;
              }
              location += y * this.width * 4 + x * 4;
            } else {
              var c = this.buffer.readUInt8(this.pos++);
              for (var i2 = 0; i2 < b; i2++) {
                if (low_nibble) {
                  setPixelData2.call(this, c & 15);
                } else {
                  setPixelData2.call(this, (c & 240) >> 4);
                }
                if (i2 & 1 && i2 + 1 < b) {
                  c = this.buffer.readUInt8(this.pos++);
                }
                low_nibble = !low_nibble;
              }
              if ((b + 1 >> 1 & 1) == 1) {
                this.pos++;
              }
            }
          } else {
            for (var i2 = 0; i2 < a; i2++) {
              if (low_nibble) {
                setPixelData2.call(this, b & 15);
              } else {
                setPixelData2.call(this, (b & 240) >> 4);
              }
              low_nibble = !low_nibble;
            }
          }
        }
      } else {
        var xlen = Math.ceil(this.width / 2);
        var mode = xlen % 4;
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < xlen; x++) {
            var b = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 2 * 4;
            var before = b >> 4;
            var after = b & 15;
            var rgb = this.palette[before];
            this.data[location] = 0;
            this.data[location + 1] = rgb.blue;
            this.data[location + 2] = rgb.green;
            this.data[location + 3] = rgb.red;
            if (x * 2 + 1 >= this.width)
              break;
            rgb = this.palette[after];
            this.data[location + 4] = 0;
            this.data[location + 4 + 1] = rgb.blue;
            this.data[location + 4 + 2] = rgb.green;
            this.data[location + 4 + 3] = rgb.red;
          }
          if (mode != 0) {
            this.pos += 4 - mode;
          }
        }
      }
    };
    BmpDecoder.prototype.bit8 = function() {
      if (this.compress == 1) {
        let setPixelData2 = function(rgbIndex) {
          var rgb2 = this.palette[rgbIndex];
          this.data[location] = 0;
          this.data[location + 1] = rgb2.blue;
          this.data[location + 2] = rgb2.green;
          this.data[location + 3] = rgb2.red;
          location += 4;
        };
        var setPixelData = setPixelData2;
        this.data.fill(255);
        var location = 0;
        var lines = this.bottom_up ? this.height - 1 : 0;
        while (location < this.data.length) {
          var a = this.buffer.readUInt8(this.pos++);
          var b = this.buffer.readUInt8(this.pos++);
          if (a == 0) {
            if (b == 0) {
              if (this.bottom_up) {
                lines--;
              } else {
                lines++;
              }
              location = lines * this.width * 4;
              continue;
            } else if (b == 1) {
              break;
            } else if (b == 2) {
              var x = this.buffer.readUInt8(this.pos++);
              var y = this.buffer.readUInt8(this.pos++);
              if (this.bottom_up) {
                lines -= y;
              } else {
                lines += y;
              }
              location += y * this.width * 4 + x * 4;
            } else {
              for (var i2 = 0; i2 < b; i2++) {
                var c = this.buffer.readUInt8(this.pos++);
                setPixelData2.call(this, c);
              }
              if (b & true) {
                this.pos++;
              }
            }
          } else {
            for (var i2 = 0; i2 < a; i2++) {
              setPixelData2.call(this, b);
            }
          }
        }
      } else {
        var mode = this.width % 4;
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
            var b = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 4;
            if (b < this.palette.length) {
              var rgb = this.palette[b];
              this.data[location] = 0;
              this.data[location + 1] = rgb.blue;
              this.data[location + 2] = rgb.green;
              this.data[location + 3] = rgb.red;
            } else {
              this.data[location] = 0;
              this.data[location + 1] = 255;
              this.data[location + 2] = 255;
              this.data[location + 3] = 255;
            }
          }
          if (mode != 0) {
            this.pos += 4 - mode;
          }
        }
      }
    };
    BmpDecoder.prototype.bit15 = function() {
      var dif_w = this.width % 3;
      var _11111 = parseInt("11111", 2), _1_5 = _11111;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var B = this.buffer.readUInt16LE(this.pos);
          this.pos += 2;
          var blue = (B & _1_5) / _1_5 * 255 | 0;
          var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
          var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
          var alpha = B >> 15 ? 255 : 0;
          var location = line * this.width * 4 + x * 4;
          this.data[location] = alpha;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
        this.pos += dif_w;
      }
    };
    BmpDecoder.prototype.bit16 = function() {
      var dif_w = this.width % 2 * 2;
      this.maskRed = 31744;
      this.maskGreen = 992;
      this.maskBlue = 31;
      this.mask0 = 0;
      if (this.compress == 3) {
        this.maskRed = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskGreen = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskBlue = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.mask0 = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
      }
      var ns = [0, 0, 0];
      for (var i2 = 0; i2 < 16; i2++) {
        if (this.maskRed >> i2 & 1)
          ns[0]++;
        if (this.maskGreen >> i2 & 1)
          ns[1]++;
        if (this.maskBlue >> i2 & 1)
          ns[2]++;
      }
      ns[1] += ns[0];
      ns[2] += ns[1];
      ns[0] = 8 - ns[0];
      ns[1] -= 8;
      ns[2] -= 8;
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var B = this.buffer.readUInt16LE(this.pos);
          this.pos += 2;
          var blue = (B & this.maskBlue) << ns[0];
          var green = (B & this.maskGreen) >> ns[1];
          var red = (B & this.maskRed) >> ns[2];
          var location = line * this.width * 4 + x * 4;
          this.data[location] = 0;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
        this.pos += dif_w;
      }
    };
    BmpDecoder.prototype.bit24 = function() {
      for (var y = this.height - 1; y >= 0; y--) {
        var line = this.bottom_up ? y : this.height - 1 - y;
        for (var x = 0; x < this.width; x++) {
          var blue = this.buffer.readUInt8(this.pos++);
          var green = this.buffer.readUInt8(this.pos++);
          var red = this.buffer.readUInt8(this.pos++);
          var location = line * this.width * 4 + x * 4;
          this.data[location] = 0;
          this.data[location + 1] = blue;
          this.data[location + 2] = green;
          this.data[location + 3] = red;
        }
        this.pos += this.width % 4;
      }
    };
    BmpDecoder.prototype.bit32 = function() {
      if (this.compress == 3) {
        this.maskRed = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskGreen = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.maskBlue = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        this.mask0 = this.buffer.readUInt32LE(this.pos);
        this.pos += 4;
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
            var alpha = this.buffer.readUInt8(this.pos++);
            var blue = this.buffer.readUInt8(this.pos++);
            var green = this.buffer.readUInt8(this.pos++);
            var red = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 4;
            this.data[location] = alpha;
            this.data[location + 1] = blue;
            this.data[location + 2] = green;
            this.data[location + 3] = red;
          }
        }
      } else {
        for (var y = this.height - 1; y >= 0; y--) {
          var line = this.bottom_up ? y : this.height - 1 - y;
          for (var x = 0; x < this.width; x++) {
            var blue = this.buffer.readUInt8(this.pos++);
            var green = this.buffer.readUInt8(this.pos++);
            var red = this.buffer.readUInt8(this.pos++);
            var alpha = this.buffer.readUInt8(this.pos++);
            var location = line * this.width * 4 + x * 4;
            this.data[location] = alpha;
            this.data[location + 1] = blue;
            this.data[location + 2] = green;
            this.data[location + 3] = red;
          }
        }
      }
    };
    BmpDecoder.prototype.getData = function() {
      return this.data;
    };
    module2.exports = function(bmpData) {
      var decoder = new BmpDecoder(bmpData);
      return decoder;
    };
  }
});

// node_modules/bmp-js/index.js
var require_bmp_js = __commonJS({
  "node_modules/bmp-js/index.js"(exports2, module2) {
    var encode = require_encoder2();
    var decode = require_decoder2();
    module2.exports = {
      encode,
      decode
    };
  }
});

// node_modules/@jimp/bmp/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@jimp/bmp/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _bmpJs = _interopRequireDefault(require_bmp_js());
    var _utils = require_dist();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MIME_TYPE = "image/bmp";
    var MIME_TYPE_SECOND = "image/x-ms-bmp";
    function toAGBR(image2) {
      return (0, _utils.scan)(image2, 0, 0, image2.bitmap.width, image2.bitmap.height, function(x, y, index) {
        const red = this.bitmap.data[index + 0];
        const green = this.bitmap.data[index + 1];
        const blue = this.bitmap.data[index + 2];
        const alpha = this.bitmap.data[index + 3];
        this.bitmap.data[index + 0] = alpha;
        this.bitmap.data[index + 1] = blue;
        this.bitmap.data[index + 2] = green;
        this.bitmap.data[index + 3] = red;
      }).bitmap;
    }
    function fromAGBR(bitmap) {
      return (0, _utils.scan)({
        bitmap
      }, 0, 0, bitmap.width, bitmap.height, function(x, y, index) {
        const alpha = this.bitmap.data[index + 0];
        const blue = this.bitmap.data[index + 1];
        const green = this.bitmap.data[index + 2];
        const red = this.bitmap.data[index + 3];
        this.bitmap.data[index + 0] = red;
        this.bitmap.data[index + 1] = green;
        this.bitmap.data[index + 2] = blue;
        this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 255;
      }).bitmap;
    }
    var decode = (data) => fromAGBR(_bmpJs.default.decode(data));
    var encode = (image2) => _bmpJs.default.encode(toAGBR(image2)).data;
    var _default = () => ({
      mime: {
        [MIME_TYPE]: ["bmp"]
      },
      constants: {
        MIME_BMP: MIME_TYPE,
        MIME_X_MS_BMP: MIME_TYPE_SECOND
      },
      decoders: {
        [MIME_TYPE]: decode,
        [MIME_TYPE_SECOND]: decode
      },
      encoders: {
        [MIME_TYPE]: encode,
        [MIME_TYPE_SECOND]: encode
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i2, l, len, pos, chunk2, result;
        len = 0;
        for (i2 = 0, l = chunks.length; i2 < l; i2++) {
          len += chunks[i2].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i2 = 0, l = chunks.length; i2 < l; i2++) {
          chunk2 = chunks[i2];
          result.set(chunk2, pos);
          pos += chunk2.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i2 = 0; i2 < len; i2++) {
          dest[dest_offs + i2] = src[src_offs + i2];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var utils2 = require_common2();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value2, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value2 << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value2 >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value2 << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var utils2 = require_common2();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils2.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils2.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils2.Buf16(MAX_BITS + 1);
      this.heap = new utils2.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils2.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils2.Buf8(s.w_size * 2);
      s.head = new utils2.Buf16(s.hash_size);
      s.prev = new utils2.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils2.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils2.Buf8(s.w_size);
        utils2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    var utils2 = require_common2();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils2.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils2.Buf8(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils2.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    }
    exports2.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports2.binstring2buf = function(str) {
      var buf = new utils2.Buf8(str.length);
      for (var i2 = 0, len = buf.length; i2 < len; i2++) {
        buf[i2] = str.charCodeAt(i2);
      }
      return buf;
    };
    exports2.buf2string = function(buf, max2) {
      var i2, out, c, c_len;
      var len = max2 || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils2 = require_common2();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils2.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils2.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils2.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var utils2 = require_common2();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils2.Buf16(MAXBITS + 1);
      var offs = new utils2.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root > max2) {
        root = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var utils2 = require_common2();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils2.Buf16(320);
      this.work = new utils2.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils2.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils2.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils2.Buf32(512);
        distfix = new utils2.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils2.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils2.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils2.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils2.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils2.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils2.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils2.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants3 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils2 = require_common2();
    var strings = require_strings();
    var c = require_constants3();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils2.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils2.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var assign = require_common2().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants2 = require_constants3();
    var pako = {};
    assign(pako, deflate, inflate, constants2);
    module2.exports = pako;
  }
});

// node_modules/utif2/UTIF.js
var require_UTIF = __commonJS({
  "node_modules/utif2/UTIF.js"(exports2, module2) {
    (function() {
      var UTIF = {};
      if (typeof module2 == "object") {
        module2.exports = UTIF;
      } else {
        self.UTIF = UTIF;
      }
      var pako = typeof require === "function" ? require_pako() : self.pako;
      function log() {
        if (typeof process == "undefined" || process.env.NODE_ENV == "development")
          console.log.apply(console, arguments);
      }
      (function(UTIF2, pako2) {
        (function() {
          "use strict";
          var W = function a1() {
            function W2(p) {
              this.message = "JPEG error: " + p;
            }
            W2.prototype = new Error();
            W2.prototype.name = "JpegError";
            W2.constructor = W2;
            return W2;
          }(), ak = function ag() {
            var p = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t = 4017, ac = 799, ah = 3406, ao = 2276, ar = 1567, ai = 3784, s = 5793, ad = 2896;
            function ak2(Q) {
              if (Q == null)
                Q = {};
              if (Q.w == null)
                Q.w = -1;
              this.V = Q.n;
              this.N = Q.w;
            }
            function a5(Q, h) {
              var f = 0, G = [], n, E, a = 16, F;
              while (a > 0 && !Q[a - 1]) {
                a--;
              }
              G.push({ children: [], index: 0 });
              var C = G[0];
              for (n = 0; n < a; n++) {
                for (E = 0; E < Q[n]; E++) {
                  C = G.pop();
                  C.children[C.index] = h[f];
                  while (C.index > 0) {
                    C = G.pop();
                  }
                  C.index++;
                  G.push(C);
                  while (G.length <= n) {
                    G.push(F = { children: [], index: 0 });
                    C.children[C.index] = F.children;
                    C = F;
                  }
                  f++;
                }
                if (n + 1 < a) {
                  G.push(F = { children: [], index: 0 });
                  C.children[C.index] = F.children;
                  C = F;
                }
              }
              return G[0].children;
            }
            function a2(Q, h, f) {
              return 64 * ((Q.P + 1) * h + f);
            }
            function a7(Q, h, f, G, n, E, a, C, F, d) {
              if (d == null)
                d = false;
              var T = f.m, U = f.Z, z = h, J = 0, V = 0, r = 0, D = 0, a8, q = 0, X, O, _, N, e, K, x = 0, k, g, R, c;
              function Y() {
                if (V > 0) {
                  V--;
                  return J >> V & 1;
                }
                J = Q[h++];
                if (J === 255) {
                  var I = Q[h++];
                  if (I) {
                    if (I === 220 && d) {
                      h += 2;
                      var l = Z(Q, h);
                      h += 2;
                      if (l > 0 && l !== f.s) {
                        throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", l);
                      }
                    } else if (I === 217) {
                      if (d) {
                        var M = q * 8;
                        if (M > 0 && M < f.s / 10) {
                          throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", M);
                        }
                      }
                      throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                    }
                    throw new W("unexpected marker");
                  }
                }
                V = 7;
                return J >>> 7;
              }
              function u(I) {
                var l = I;
                while (true) {
                  l = l[Y()];
                  switch (typeof l) {
                    case "number":
                      return l;
                    case "object":
                      continue;
                  }
                  throw new W("invalid huffman sequence");
                }
              }
              function m(I) {
                var e2 = 0;
                while (I > 0) {
                  e2 = e2 << 1 | Y();
                  I--;
                }
                return e2;
              }
              function j(I) {
                if (I === 1) {
                  return Y() === 1 ? 1 : -1;
                }
                var e2 = m(I);
                if (e2 >= 1 << I - 1) {
                  return e2;
                }
                return e2 + (-1 << I) + 1;
              }
              function v(X2, I) {
                var l = u(X2.J), M = l === 0 ? 0 : j(l), N2 = 1;
                X2.D[I] = X2.Q += M;
                while (N2 < 64) {
                  var S = u(X2.i), i2 = S & 15, A = S >> 4;
                  if (i2 === 0) {
                    if (A < 15) {
                      break;
                    }
                    N2 += 16;
                    continue;
                  }
                  N2 += A;
                  var o = p[N2];
                  X2.D[I + o] = j(i2);
                  N2++;
                }
              }
              function $2(X2, I) {
                var l = u(X2.J), M = l === 0 ? 0 : j(l) << F;
                X2.D[I] = X2.Q += M;
              }
              function b(X2, I) {
                X2.D[I] |= Y() << F;
              }
              function P(X2, I) {
                if (r > 0) {
                  r--;
                  return;
                }
                var N2 = E, l = a;
                while (N2 <= l) {
                  var M = u(X2.i), S = M & 15, i2 = M >> 4;
                  if (S === 0) {
                    if (i2 < 15) {
                      r = m(i2) + (1 << i2) - 1;
                      break;
                    }
                    N2 += 16;
                    continue;
                  }
                  N2 += i2;
                  var A = p[N2];
                  X2.D[I + A] = j(S) * (1 << F);
                  N2++;
                }
              }
              function a4(X2, I) {
                var N2 = E, l = a, M = 0, S, i2;
                while (N2 <= l) {
                  var A = I + p[N2], o = X2.D[A] < 0 ? -1 : 1;
                  switch (D) {
                    case 0:
                      i2 = u(X2.i);
                      S = i2 & 15;
                      M = i2 >> 4;
                      if (S === 0) {
                        if (M < 15) {
                          r = m(M) + (1 << M);
                          D = 4;
                        } else {
                          M = 16;
                          D = 1;
                        }
                      } else {
                        if (S !== 1) {
                          throw new W("invalid ACn encoding");
                        }
                        a8 = j(S);
                        D = M ? 2 : 3;
                      }
                      continue;
                    case 1:
                    case 2:
                      if (X2.D[A]) {
                        X2.D[A] += o * (Y() << F);
                      } else {
                        M--;
                        if (M === 0) {
                          D = D === 2 ? 3 : 0;
                        }
                      }
                      break;
                    case 3:
                      if (X2.D[A]) {
                        X2.D[A] += o * (Y() << F);
                      } else {
                        X2.D[A] = a8 << F;
                        D = 0;
                      }
                      break;
                    case 4:
                      if (X2.D[A]) {
                        X2.D[A] += o * (Y() << F);
                      }
                      break;
                  }
                  N2++;
                }
                if (D === 4) {
                  r--;
                  if (r === 0) {
                    D = 0;
                  }
                }
              }
              function H(X2, I, x2, l, M) {
                var S = x2 / T | 0, i2 = x2 % T;
                q = S * X2.A + l;
                var A = i2 * X2.h + M, o = a2(X2, q, A);
                I(X2, o);
              }
              function w(X2, I, x2) {
                q = x2 / X2.P | 0;
                var l = x2 % X2.P, M = a2(X2, q, l);
                I(X2, M);
              }
              var y = G.length;
              if (U) {
                if (E === 0) {
                  K = C === 0 ? $2 : b;
                } else {
                  K = C === 0 ? P : a4;
                }
              } else {
                K = v;
              }
              if (y === 1) {
                g = G[0].P * G[0].c;
              } else {
                g = T * f.R;
              }
              while (x <= g) {
                var L = n ? Math.min(g - x, n) : g;
                if (L > 0) {
                  for (O = 0; O < y; O++) {
                    G[O].Q = 0;
                  }
                  r = 0;
                  if (y === 1) {
                    X = G[0];
                    for (e = 0; e < L; e++) {
                      w(X, K, x);
                      x++;
                    }
                  } else {
                    for (e = 0; e < L; e++) {
                      for (O = 0; O < y; O++) {
                        X = G[O];
                        R = X.h;
                        c = X.A;
                        for (_ = 0; _ < c; _++) {
                          for (N = 0; N < R; N++) {
                            H(X, K, x, _, N);
                          }
                        }
                      }
                      x++;
                    }
                  }
                }
                V = 0;
                k = an(Q, h);
                if (!k) {
                  break;
                }
                if (k.u) {
                  var a6 = L > 0 ? "unexpected" : "excessive";
                  h = k.offset;
                }
                if (k.M >= 65488 && k.M <= 65495) {
                  h += 2;
                } else {
                  break;
                }
              }
              return h - z;
            }
            function al(Q, h, f) {
              var G = Q.$, n = Q.D, E, a, C, F, d, T, U, z, J, V, Y, u, m, j, v, $2, b;
              if (!G) {
                throw new W("missing required Quantization Table.");
              }
              for (var r = 0; r < 64; r += 8) {
                J = n[h + r];
                V = n[h + r + 1];
                Y = n[h + r + 2];
                u = n[h + r + 3];
                m = n[h + r + 4];
                j = n[h + r + 5];
                v = n[h + r + 6];
                $2 = n[h + r + 7];
                J *= G[r];
                if ((V | Y | u | m | j | v | $2) === 0) {
                  b = s * J + 512 >> 10;
                  f[r] = b;
                  f[r + 1] = b;
                  f[r + 2] = b;
                  f[r + 3] = b;
                  f[r + 4] = b;
                  f[r + 5] = b;
                  f[r + 6] = b;
                  f[r + 7] = b;
                  continue;
                }
                V *= G[r + 1];
                Y *= G[r + 2];
                u *= G[r + 3];
                m *= G[r + 4];
                j *= G[r + 5];
                v *= G[r + 6];
                $2 *= G[r + 7];
                E = s * J + 128 >> 8;
                a = s * m + 128 >> 8;
                C = Y;
                F = v;
                d = ad * (V - $2) + 128 >> 8;
                z = ad * (V + $2) + 128 >> 8;
                T = u << 4;
                U = j << 4;
                E = E + a + 1 >> 1;
                a = E - a;
                b = C * ai + F * ar + 128 >> 8;
                C = C * ar - F * ai + 128 >> 8;
                F = b;
                d = d + U + 1 >> 1;
                U = d - U;
                z = z + T + 1 >> 1;
                T = z - T;
                E = E + F + 1 >> 1;
                F = E - F;
                a = a + C + 1 >> 1;
                C = a - C;
                b = d * ao + z * ah + 2048 >> 12;
                d = d * ah - z * ao + 2048 >> 12;
                z = b;
                b = T * ac + U * t + 2048 >> 12;
                T = T * t - U * ac + 2048 >> 12;
                U = b;
                f[r] = E + z;
                f[r + 7] = E - z;
                f[r + 1] = a + U;
                f[r + 6] = a - U;
                f[r + 2] = C + T;
                f[r + 5] = C - T;
                f[r + 3] = F + d;
                f[r + 4] = F - d;
              }
              for (var P = 0; P < 8; ++P) {
                J = f[P];
                V = f[P + 8];
                Y = f[P + 16];
                u = f[P + 24];
                m = f[P + 32];
                j = f[P + 40];
                v = f[P + 48];
                $2 = f[P + 56];
                if ((V | Y | u | m | j | v | $2) === 0) {
                  b = s * J + 8192 >> 14;
                  if (b < -2040) {
                    b = 0;
                  } else if (b >= 2024) {
                    b = 255;
                  } else {
                    b = b + 2056 >> 4;
                  }
                  n[h + P] = b;
                  n[h + P + 8] = b;
                  n[h + P + 16] = b;
                  n[h + P + 24] = b;
                  n[h + P + 32] = b;
                  n[h + P + 40] = b;
                  n[h + P + 48] = b;
                  n[h + P + 56] = b;
                  continue;
                }
                E = s * J + 2048 >> 12;
                a = s * m + 2048 >> 12;
                C = Y;
                F = v;
                d = ad * (V - $2) + 2048 >> 12;
                z = ad * (V + $2) + 2048 >> 12;
                T = u;
                U = j;
                E = (E + a + 1 >> 1) + 4112;
                a = E - a;
                b = C * ai + F * ar + 2048 >> 12;
                C = C * ar - F * ai + 2048 >> 12;
                F = b;
                d = d + U + 1 >> 1;
                U = d - U;
                z = z + T + 1 >> 1;
                T = z - T;
                E = E + F + 1 >> 1;
                F = E - F;
                a = a + C + 1 >> 1;
                C = a - C;
                b = d * ao + z * ah + 2048 >> 12;
                d = d * ah - z * ao + 2048 >> 12;
                z = b;
                b = T * ac + U * t + 2048 >> 12;
                T = T * t - U * ac + 2048 >> 12;
                U = b;
                J = E + z;
                $2 = E - z;
                V = a + U;
                v = a - U;
                Y = C + T;
                j = C - T;
                u = F + d;
                m = F - d;
                if (J < 16) {
                  J = 0;
                } else if (J >= 4080) {
                  J = 255;
                } else {
                  J >>= 4;
                }
                if (V < 16) {
                  V = 0;
                } else if (V >= 4080) {
                  V = 255;
                } else {
                  V >>= 4;
                }
                if (Y < 16) {
                  Y = 0;
                } else if (Y >= 4080) {
                  Y = 255;
                } else {
                  Y >>= 4;
                }
                if (u < 16) {
                  u = 0;
                } else if (u >= 4080) {
                  u = 255;
                } else {
                  u >>= 4;
                }
                if (m < 16) {
                  m = 0;
                } else if (m >= 4080) {
                  m = 255;
                } else {
                  m >>= 4;
                }
                if (j < 16) {
                  j = 0;
                } else if (j >= 4080) {
                  j = 255;
                } else {
                  j >>= 4;
                }
                if (v < 16) {
                  v = 0;
                } else if (v >= 4080) {
                  v = 255;
                } else {
                  v >>= 4;
                }
                if ($2 < 16) {
                  $2 = 0;
                } else if ($2 >= 4080) {
                  $2 = 255;
                } else {
                  $2 >>= 4;
                }
                n[h + P] = J;
                n[h + P + 8] = V;
                n[h + P + 16] = Y;
                n[h + P + 24] = u;
                n[h + P + 32] = m;
                n[h + P + 40] = j;
                n[h + P + 48] = v;
                n[h + P + 56] = $2;
              }
            }
            function a0(Q, h) {
              var f = h.P, G = h.c, n = new Int16Array(64);
              for (var E = 0; E < G; E++) {
                for (var a = 0; a < f; a++) {
                  var C = a2(h, E, a);
                  al(h, C, n);
                }
              }
              return h.D;
            }
            function an(Q, h, f) {
              if (f == null)
                f = h;
              var G = Q.length - 1, n = f < h ? f : h;
              if (h >= G) {
                return null;
              }
              var E = Z(Q, h);
              if (E >= 65472 && E <= 65534) {
                return { u: null, M: E, offset: h };
              }
              var a = Z(Q, n);
              while (!(a >= 65472 && a <= 65534)) {
                if (++n >= G) {
                  return null;
                }
                a = Z(Q, n);
              }
              return { u: E.toString(16), M: a, offset: n };
            }
            ak2.prototype = { parse(Q, h) {
              if (h == null)
                h = {};
              var f = h.F, E = 0, a = null, C = null, F, d, T = 0;
              function G() {
                var o = Z(Q, E);
                E += 2;
                var B = E + o - 2, V2 = an(Q, B, E);
                if (V2 && V2.u) {
                  B = V2.offset;
                }
                var ab = Q.subarray(E, B);
                E += ab.length;
                return ab;
              }
              function n(F2) {
                var o = Math.ceil(F2.o / 8 / F2.X), B = Math.ceil(F2.s / 8 / F2.B);
                for (var Y2 = 0; Y2 < F2.W.length; Y2++) {
                  R = F2.W[Y2];
                  var ab = Math.ceil(Math.ceil(F2.o / 8) * R.h / F2.X), af = Math.ceil(Math.ceil(F2.s / 8) * R.A / F2.B), ap = o * R.h, aq = B * R.A, ae = 64 * aq * (ap + 1);
                  R.D = new Int16Array(ae);
                  R.P = ab;
                  R.c = af;
                }
                F2.m = o;
                F2.R = B;
              }
              var U = [], z = [], J = [], V = Z(Q, E);
              E += 2;
              if (V !== 65496) {
                throw new W("SOI not found");
              }
              V = Z(Q, E);
              E += 2;
              markerLoop:
                while (V !== 65497) {
                  var Y, u, m;
                  switch (V) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      var j = G();
                      if (V === 65504) {
                        if (j[0] === 74 && j[1] === 70 && j[2] === 73 && j[3] === 70 && j[4] === 0) {
                          a = { version: { d: j[5], T: j[6] }, K: j[7], j: j[8] << 8 | j[9], H: j[10] << 8 | j[11], S: j[12], I: j[13], C: j.subarray(14, 14 + 3 * j[12] * j[13]) };
                        }
                      }
                      if (V === 65518) {
                        if (j[0] === 65 && j[1] === 100 && j[2] === 111 && j[3] === 98 && j[4] === 101) {
                          C = { version: j[5] << 8 | j[6], k: j[7] << 8 | j[8], q: j[9] << 8 | j[10], a: j[11] };
                        }
                      }
                      break;
                    case 65499:
                      var v = Z(Q, E), b;
                      E += 2;
                      var $2 = v + E - 2;
                      while (E < $2) {
                        var r = Q[E++], P = new Uint16Array(64);
                        if (r >> 4 === 0) {
                          for (u = 0; u < 64; u++) {
                            b = p[u];
                            P[b] = Q[E++];
                          }
                        } else if (r >> 4 === 1) {
                          for (u = 0; u < 64; u++) {
                            b = p[u];
                            P[b] = Z(Q, E);
                            E += 2;
                          }
                        } else {
                          throw new W("DQT - invalid table spec");
                        }
                        U[r & 15] = P;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (F) {
                        throw new W("Only single frame JPEGs supported");
                      }
                      E += 2;
                      F = {};
                      F.G = V === 65473;
                      F.Z = V === 65474;
                      F.precision = Q[E++];
                      var D = Z(Q, E), a4, q = 0, H = 0;
                      E += 2;
                      F.s = f || D;
                      F.o = Z(Q, E);
                      E += 2;
                      F.W = [];
                      F._ = {};
                      var a8 = Q[E++];
                      for (Y = 0; Y < a8; Y++) {
                        a4 = Q[E];
                        var w = Q[E + 1] >> 4, y = Q[E + 1] & 15;
                        if (q < w) {
                          q = w;
                        }
                        if (H < y) {
                          H = y;
                        }
                        var X = Q[E + 2];
                        m = F.W.push({ h: w, A: y, L: X, $: null });
                        F._[a4] = m - 1;
                        E += 3;
                      }
                      F.X = q;
                      F.B = H;
                      n(F);
                      break;
                    case 65476:
                      var O = Z(Q, E);
                      E += 2;
                      for (Y = 2; Y < O; ) {
                        var _ = Q[E++], N = new Uint8Array(16), e = 0;
                        for (u = 0; u < 16; u++, E++) {
                          e += N[u] = Q[E];
                        }
                        var K = new Uint8Array(e);
                        for (u = 0; u < e; u++, E++) {
                          K[u] = Q[E];
                        }
                        Y += 17 + e;
                        (_ >> 4 === 0 ? J : z)[_ & 15] = a5(N, K);
                      }
                      break;
                    case 65501:
                      E += 2;
                      d = Z(Q, E);
                      E += 2;
                      break;
                    case 65498:
                      var x = ++T === 1 && !f, R;
                      E += 2;
                      var k = Q[E++], g = [];
                      for (Y = 0; Y < k; Y++) {
                        var c = Q[E++], L = F._[c];
                        R = F.W[L];
                        R.index = c;
                        var a6 = Q[E++];
                        R.J = J[a6 >> 4];
                        R.i = z[a6 & 15];
                        g.push(R);
                      }
                      var I = Q[E++], l = Q[E++], M = Q[E++];
                      try {
                        var S = a7(Q, E, F, g, d, I, l, M >> 4, M & 15, x);
                        E += S;
                      } catch (ex) {
                        if (ex instanceof DNLMarkerError) {
                          return this.parse(Q, { F: ex.s });
                        } else if (ex instanceof EOIMarkerError) {
                          break markerLoop;
                        }
                        throw ex;
                      }
                      break;
                    case 65500:
                      E += 4;
                      break;
                    case 65535:
                      if (Q[E] !== 255) {
                        E--;
                      }
                      break;
                    default:
                      var i2 = an(Q, E - 2, E - 3);
                      if (i2 && i2.u) {
                        E = i2.offset;
                        break;
                      }
                      if (E >= Q.length - 1) {
                        break markerLoop;
                      }
                      throw new W("JpegImage.parse - unknown marker: " + V.toString(16));
                  }
                  V = Z(Q, E);
                  E += 2;
                }
              this.width = F.o;
              this.height = F.s;
              this.g = a;
              this.b = C;
              this.W = [];
              for (Y = 0; Y < F.W.length; Y++) {
                R = F.W[Y];
                var A = U[R.L];
                if (A) {
                  R.$ = A;
                }
                this.W.push({ index: R.index, e: a0(F, R), l: R.h / F.X, t: R.A / F.B, P: R.P, c: R.c });
              }
              this.p = this.W.length;
              return void 0;
            }, Y(Q, h, f) {
              if (f == null)
                f = false;
              var G = this.width / Q, n = this.height / h, E, a, C, F, d, T, U, z, J, V, Y = 0, u, m = this.W.length, j = Q * h * m, v = new Uint8ClampedArray(j), $2 = new Uint32Array(Q), b = 4294967288, r;
              for (U = 0; U < m; U++) {
                E = this.W[U];
                a = E.l * G;
                C = E.t * n;
                Y = U;
                u = E.e;
                F = E.P + 1 << 3;
                if (a !== r) {
                  for (d = 0; d < Q; d++) {
                    z = 0 | d * a;
                    $2[d] = (z & b) << 3 | z & 7;
                  }
                  r = a;
                }
                for (T = 0; T < h; T++) {
                  z = 0 | T * C;
                  V = F * (z & b) | (z & 7) << 3;
                  for (d = 0; d < Q; d++) {
                    v[Y] = u[V + $2[d]];
                    Y += m;
                  }
                }
              }
              var P = this.V;
              if (!f && m === 4 && !P) {
                P = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);
              }
              if (P) {
                for (U = 0; U < j; ) {
                  for (z = 0, J = 0; z < m; z++, U++, J += 2) {
                    v[U] = (v[U] * P[J] >> 8) + P[J + 1];
                  }
                }
              }
              return v;
            }, get f() {
              if (this.b) {
                return !!this.b.a;
              }
              if (this.p === 3) {
                if (this.N === 0) {
                  return false;
                } else if (this.W[0].index === 82 && this.W[1].index === 71 && this.W[2].index === 66) {
                  return false;
                }
                return true;
              }
              if (this.N === 1) {
                return true;
              }
              return false;
            }, z: function aj(Q) {
              var h, f, G;
              for (var n = 0, E = Q.length; n < E; n += 3) {
                h = Q[n];
                f = Q[n + 1];
                G = Q[n + 2];
                Q[n] = h - 179.456 + 1.402 * G;
                Q[n + 1] = h + 135.459 - 0.344 * f - 0.714 * G;
                Q[n + 2] = h - 226.816 + 1.772 * f;
              }
              return Q;
            }, O: function aa(Q) {
              var h, f, G, n, E = 0;
              for (var a = 0, C = Q.length; a < C; a += 4) {
                h = Q[a];
                f = Q[a + 1];
                G = Q[a + 2];
                n = Q[a + 3];
                Q[E++] = -122.67195406894 + f * (-660635669420364e-19 * f + 437130475926232e-18 * G - 54080610064599e-18 * h + 48449797120281e-17 * n - 0.154362151871126) + G * (-957964378445773e-18 * G + 817076911346625e-18 * h - 0.00477271405408747 * n + 1.53380253221734) + h * (961250184130688e-18 * h - 0.00266257332283933 * n + 0.48357088451265) + n * (-336197177618394e-18 * n + 0.484791561490776);
                Q[E++] = 107.268039397724 + f * (219927104525741e-19 * f - 640992018297945e-18 * G + 659397001245577e-18 * h + 426105652938837e-18 * n - 0.176491792462875) + G * (-778269941513683e-18 * G + 0.00130872261408275 * h + 770482631801132e-18 * n - 0.151051492775562) + h * (0.00126935368114843 * h - 0.00265090189010898 * n + 0.25802910206845) + n * (-318913117588328e-18 * n - 0.213742400323665);
                Q[E++] = -20.810012546947 + f * (-570115196973677e-18 * f - 263409051004589e-19 * G + 0.0020741088115012 * h - 0.00288260236853442 * n + 0.814272968359295) + G * (-153496057440975e-19 * G - 132689043961446e-18 * h + 560833691242812e-18 * n - 0.195152027534049) + h * (0.00174418132927582 * h - 0.00255243321439347 * n + 0.116935020465145) + n * (-343531996510555e-18 * n + 0.24165260232407);
              }
              return Q.subarray(0, E);
            }, r: function a3(Q) {
              var h, f, G;
              for (var n = 0, E = Q.length; n < E; n += 4) {
                h = Q[n];
                f = Q[n + 1];
                G = Q[n + 2];
                Q[n] = 434.456 - h - 1.402 * G;
                Q[n + 1] = 119.541 - h + 0.344 * f + 0.714 * G;
                Q[n + 2] = 481.816 - h - 1.772 * f;
              }
              return Q;
            }, U: function as(Q) {
              var h, f, G, n, E = 0;
              for (var a = 0, C = Q.length; a < C; a += 4) {
                h = Q[a];
                f = Q[a + 1];
                G = Q[a + 2];
                n = Q[a + 3];
                Q[E++] = 255 + h * (-6747147073602441e-20 * h + 8379262121013727e-19 * f + 2894718188643294e-19 * G + 0.003264231057537806 * n - 1.1185611867203937) + f * (26374107616089405e-21 * f - 8626949158638572e-20 * G - 2748769067499491e-19 * n - 0.02155688794978967) + G * (-3878099212869363e-20 * G - 3267808279485286e-19 * n + 0.0686742238595345) - n * (3361971776183937e-19 * n + 0.7430659151342254);
                Q[E++] = 255 + h * (13596372813588848e-20 * h + 924537132573585e-18 * f + 10567359618683593e-20 * G + 4791864687436512e-19 * n - 0.3109689587515875) + f * (-23545346108370344e-20 * f + 2702845253534714e-19 * G + 0.0020200308977307156 * n - 0.7488052167015494) + G * (6834815998235662e-20 * G + 15168452363460973e-20 * n - 0.09751927774728933) - n * (3189131175883281e-19 * n + 0.7364883807733168);
                Q[E++] = 255 + h * (13598650411385307e-21 * h + 12423956175490851e-20 * f + 4751985097583589e-19 * G - 36729317476630422e-22 * n - 0.05562186980264034) + f * (16141380598724676e-20 * f + 9692239130725186e-19 * G + 7782692450036253e-19 * n - 0.44015232367526463) + G * (5068882914068769e-22 * G + 0.0017778369011375071 * n - 0.7591454649749609) - n * (3435319965105553e-19 * n + 0.7063770186160144);
              }
              return Q.subarray(0, E);
            }, getData: function(Q) {
              var h = Q.width, f = Q.height, G = Q.forceRGB, n = Q.isSourcePDF;
              if (this.p > 4) {
                throw new W("Unsupported color mode");
              }
              var E = this.Y(h, f, n);
              if (this.p === 1 && G) {
                var a = E.length, C = new Uint8ClampedArray(a * 3), F = 0;
                for (var d = 0; d < a; d++) {
                  var T = E[d];
                  C[F++] = T;
                  C[F++] = T;
                  C[F++] = T;
                }
                return C;
              } else if (this.p === 3 && this.f) {
                return this.z(E);
              } else if (this.p === 4) {
                if (this.f) {
                  if (G) {
                    return this.O(E);
                  }
                  return this.r(E);
                } else if (G) {
                  return this.U(E);
                }
              }
              return E;
            } };
            return ak2;
          }();
          function a9(p, t) {
            return p[t] << 24 >> 24;
          }
          function Z(p, t) {
            return p[t] << 8 | p[t + 1];
          }
          function am(p, t) {
            return (p[t] << 24 | p[t + 1] << 16 | p[t + 2] << 8 | p[t + 3]) >>> 0;
          }
          UTIF2.JpegDecoder = ak;
        })();
        UTIF2.encodeImage = function(rgba, w, h, metadata) {
          var idf = {
            "t256": [w],
            "t257": [h],
            "t258": [8, 8, 8, 8],
            "t259": [1],
            "t262": [2],
            "t273": [1e3],
            // strips offset
            "t277": [4],
            "t278": [h],
            /* rows per strip */
            "t279": [w * h * 4],
            // strip byte counts
            "t282": [[72, 1]],
            "t283": [[72, 1]],
            "t284": [1],
            "t286": [[0, 1]],
            "t287": [[0, 1]],
            "t296": [1],
            "t305": ["Photopea (UTIF.js)"],
            "t338": [1]
          };
          if (metadata)
            for (var i2 in metadata)
              idf[i2] = metadata[i2];
          var prfx = new Uint8Array(UTIF2.encode([idf]));
          var img = new Uint8Array(rgba);
          var data = new Uint8Array(1e3 + w * h * 4);
          for (var i2 = 0; i2 < prfx.length; i2++)
            data[i2] = prfx[i2];
          for (var i2 = 0; i2 < img.length; i2++)
            data[1e3 + i2] = img[i2];
          return data.buffer;
        };
        UTIF2.encode = function(ifds) {
          var LE = false;
          var data = new Uint8Array(2e4), offset = 4, bin = LE ? UTIF2._binLE : UTIF2._binBE;
          data[0] = data[1] = LE ? 73 : 77;
          bin.writeUshort(data, 2, 42);
          var ifdo = 8;
          bin.writeUint(data, offset, ifdo);
          offset += 4;
          for (var i2 = 0; i2 < ifds.length; i2++) {
            var noffs = UTIF2._writeIFD(bin, UTIF2._types.basic, data, ifdo, ifds[i2]);
            ifdo = noffs[1];
            if (i2 < ifds.length - 1) {
              if ((ifdo & 3) != 0)
                ifdo += 4 - (ifdo & 3);
              bin.writeUint(data, noffs[0], ifdo);
            }
          }
          return data.slice(0, ifdo).buffer;
        };
        UTIF2.decode = function(buff, prm) {
          if (prm == null)
            prm = { parseMN: true, debug: false };
          var data = new Uint8Array(buff), offset = 0;
          var id = UTIF2._binBE.readASCII(data, offset, 2);
          offset += 2;
          var bin = id == "II" ? UTIF2._binLE : UTIF2._binBE;
          var num = bin.readUshort(data, offset);
          offset += 2;
          var ifdo = bin.readUint(data, offset);
          offset += 4;
          var ifds = [];
          while (true) {
            var cnt = bin.readUshort(data, ifdo), typ = bin.readUshort(data, ifdo + 4);
            if (cnt != 0) {
              if (typ < 1 || 13 < typ) {
                log("error in TIFF");
                break;
              }
            }
            ;
            UTIF2._readIFD(bin, data, ifdo, ifds, 0, prm);
            ifdo = bin.readUint(data, ifdo + 2 + cnt * 12);
            if (ifdo == 0)
              break;
          }
          return ifds;
        };
        UTIF2.decodeImage = function(buff, img, ifds) {
          if (img.data)
            return;
          var data = new Uint8Array(buff);
          var id = UTIF2._binBE.readASCII(data, 0, 2);
          if (img["t256"] == null)
            return;
          img.isLE = id == "II";
          img.width = img["t256"][0];
          img.height = img["t257"][0];
          var cmpr = img["t259"] ? img["t259"][0] : 1;
          var fo = img["t266"] ? img["t266"][0] : 1;
          if (img["t284"] && img["t284"][0] == 2)
            log("PlanarConfiguration 2 should not be used!");
          if (cmpr == 7 && img["t258"] && img["t258"].length > 3)
            img["t258"] = img["t258"].slice(0, 3);
          var spp = img["t277"] ? img["t277"][0] : 1;
          var bps = img["t258"] ? img["t258"][0] : 1;
          var bipp = bps * spp;
          if (cmpr == 1 && img["t279"] != null && img["t278"] && img["t262"][0] == 32803) {
            bipp = Math.round(img["t279"][0] * 8 / (img.width * img["t278"][0]));
          }
          if (img["t50885"] && img["t50885"][0] == 4)
            bipp = img["t258"][0] * 3;
          var bipl = Math.ceil(img.width * bipp / 8) * 8;
          var soff = img["t273"];
          if (soff == null || img["t322"])
            soff = img["t324"];
          var bcnt = img["t279"];
          if (cmpr == 1 && soff.length == 1)
            bcnt = [img.height * (bipl >>> 3)];
          if (bcnt == null || img["t322"])
            bcnt = img["t325"];
          var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
          if (img["t322"] != null) {
            var tw = img["t322"][0], th = img["t323"][0];
            var tx = Math.floor((img.width + tw - 1) / tw);
            var ty = Math.floor((img.height + th - 1) / th);
            var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
            console.log("====", tx, ty);
            for (var y = 0; y < ty; y++)
              for (var x = 0; x < tx; x++) {
                var i2 = y * tx + x;
                tbuff.fill(0);
                UTIF2.decode._decompress(img, ifds, data, soff[i2], bcnt[i2], cmpr, tbuff, 0, fo, tw, th);
                if (cmpr == 6)
                  bytes = tbuff;
                else
                  UTIF2._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);
              }
            bilen = bytes.length * 8;
          } else {
            if (soff == null)
              return;
            var rps = img["t278"] ? img["t278"][0] : img.height;
            rps = Math.min(rps, img.height);
            for (var i2 = 0; i2 < soff.length; i2++) {
              UTIF2.decode._decompress(img, ifds, data, soff[i2], bcnt[i2], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo, img.width, rps);
              bilen += bipl * rps;
            }
            bilen = Math.min(bilen, bytes.length * 8);
          }
          img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
        };
        UTIF2.decode._decompress = function(img, ifds, data, off, len, cmpr, tgt, toff, fo, w, h) {
          if (img["t271"] && img["t271"][0] == "Panasonic" && img["t45"] && img["t45"][0] == 6)
            cmpr = 34316;
          if (false) {
          } else if (cmpr == 1)
            for (var j = 0; j < len; j++)
              tgt[toff + j] = data[off + j];
          else if (cmpr == 2)
            UTIF2.decode._decodeG2(data, off, len, tgt, toff, w, fo);
          else if (cmpr == 3)
            UTIF2.decode._decodeG3(data, off, len, tgt, toff, w, fo, img["t292"] ? (img["t292"][0] & 1) == 1 : false);
          else if (cmpr == 4)
            UTIF2.decode._decodeG4(data, off, len, tgt, toff, w, fo);
          else if (cmpr == 5)
            UTIF2.decode._decodeLZW(data, off, len, tgt, toff, 8);
          else if (cmpr == 6)
            UTIF2.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
          else if (cmpr == 7 || cmpr == 34892)
            UTIF2.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
          else if (cmpr == 8 || cmpr == 32946) {
            var src = new Uint8Array(data.buffer, off + 2, len - 6);
            var bin = pako2["inflateRaw"](src);
            if (toff + bin.length <= tgt.length)
              tgt.set(bin, toff);
          } else if (cmpr == 9)
            UTIF2.decode._decodeVC5(data, off, len, tgt, toff, img["t33422"]);
          else if (cmpr == 32767)
            UTIF2.decode._decodeARW(img, data, off, len, tgt, toff);
          else if (cmpr == 32773)
            UTIF2.decode._decodePackBits(data, off, len, tgt, toff);
          else if (cmpr == 32809)
            UTIF2.decode._decodeThunder(data, off, len, tgt, toff);
          else if (cmpr == 34316)
            UTIF2.decode._decodePanasonic(img, data, off, len, tgt, toff);
          else if (cmpr == 34713)
            UTIF2.decode._decodeNikon(img, ifds, data, off, len, tgt, toff);
          else if (cmpr == 34676)
            UTIF2.decode._decodeLogLuv32(img, data, off, len, tgt, toff);
          else
            log("Unknown compression", cmpr);
          var bps = img["t258"] ? Math.min(32, img["t258"][0]) : 1;
          var noc = img["t277"] ? img["t277"][0] : 1, bpp = bps * noc >>> 3, bpl = Math.ceil(bps * noc * w / 8);
          if (bps == 16 && !img.isLE && img["t33422"] == null)
            for (var y = 0; y < h; y++) {
              var roff = toff + y * bpl;
              for (var x = 1; x < bpl; x += 2) {
                var t = tgt[roff + x];
                tgt[roff + x] = tgt[roff + x - 1];
                tgt[roff + x - 1] = t;
              }
            }
          if (img["t317"] && img["t317"][0] == 2) {
            for (var y = 0; y < h; y++) {
              var ntoff = toff + y * bpl;
              if (bps == 16)
                for (var j = bpp; j < bpl; j += 2) {
                  var nv = (tgt[ntoff + j + 1] << 8 | tgt[ntoff + j]) + (tgt[ntoff + j - bpp + 1] << 8 | tgt[ntoff + j - bpp]);
                  tgt[ntoff + j] = nv & 255;
                  tgt[ntoff + j + 1] = nv >>> 8 & 255;
                }
              else if (noc == 3)
                for (var j = 3; j < bpl; j += 3) {
                  tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
                  tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
                  tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
                }
              else
                for (var j = bpp; j < bpl; j++)
                  tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - bpp] & 255;
            }
          }
        };
        UTIF2.decode._decodePanasonic = function(img, data, off, len, tgt, toff) {
          var img_buffer = data.buffer;
          var rawWidth = img["t2"][0];
          var rawHeight = img["t3"][0];
          var bitsPerSample = img["t10"][0];
          var RW2_Format = img["t45"][0];
          var bidx = 0;
          var imageIndex = 0;
          var vpos = 0;
          var byte = 0;
          var arr_a, arr_b;
          var bytes = RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16);
          var i2, j, sh, pred = [0, 0], nonz = [0, 0], isOdd, idx = 0, pixel_base;
          var row, col, crow;
          var buffer = new Uint8Array(16384);
          var result = new Uint16Array(tgt.buffer);
          function getDataRaw(bits) {
            if (vpos == 0) {
              var arr_a2 = new Uint8Array(img_buffer, off + imageIndex + 8184, 16384 - 8184);
              var arr_b2 = new Uint8Array(img_buffer, off + imageIndex, 8184);
              buffer.set(arr_a2);
              buffer.set(arr_b2, arr_a2.length);
              imageIndex += 16384;
            }
            if (RW2_Format == 5) {
              for (i2 = 0; i2 < 16; i2++) {
                bytes[i2] = buffer[vpos++];
                vpos &= 16383;
              }
            } else {
              vpos = vpos - bits & 131071;
              byte = vpos >> 3 ^ 16368;
              return (buffer[byte] | buffer[byte + 1] << 8) >> (vpos & 7) & ~(-1 << bits);
            }
          }
          function getBufferDataRW6(i3) {
            return buffer[vpos + 15 - i3];
          }
          function readPageRW6() {
            bytes[0] = getBufferDataRW6(0) << 6 | getBufferDataRW6(1) >> 2;
            bytes[1] = ((getBufferDataRW6(1) & 3) << 12 | getBufferDataRW6(2) << 4 | getBufferDataRW6(3) >> 4) & 16383;
            bytes[2] = getBufferDataRW6(3) >> 2 & 3;
            bytes[3] = (getBufferDataRW6(3) & 3) << 8 | getBufferDataRW6(4);
            bytes[4] = getBufferDataRW6(5) << 2 | getBufferDataRW6(6) >> 6;
            bytes[5] = (getBufferDataRW6(6) & 63) << 4 | getBufferDataRW6(7) >> 4;
            bytes[6] = getBufferDataRW6(7) >> 2 & 3;
            bytes[7] = (getBufferDataRW6(7) & 3) << 8 | getBufferDataRW6(8);
            bytes[8] = getBufferDataRW6(9) << 2 & 1020 | getBufferDataRW6(10) >> 6;
            bytes[9] = (getBufferDataRW6(10) << 4 | getBufferDataRW6(11) >> 4) & 1023;
            bytes[10] = getBufferDataRW6(11) >> 2 & 3;
            bytes[11] = (getBufferDataRW6(11) & 3) << 8 | getBufferDataRW6(12);
            bytes[12] = (getBufferDataRW6(13) << 2 & 1020 | getBufferDataRW6(14) >> 6) & 1023;
            bytes[13] = (getBufferDataRW6(14) << 4 | getBufferDataRW6(15) >> 4) & 1023;
            vpos += 16;
            byte = 0;
          }
          function readPageRw6_bps12() {
            bytes[0] = getBufferDataRW6(0) << 4 | getBufferDataRW6(1) >> 4;
            bytes[1] = ((getBufferDataRW6(1) & 15) << 8 | getBufferDataRW6(2)) & 4095;
            bytes[2] = getBufferDataRW6(3) >> 6 & 3;
            bytes[3] = (getBufferDataRW6(3) & 63) << 2 | getBufferDataRW6(4) >> 6;
            bytes[4] = (getBufferDataRW6(4) & 63) << 2 | getBufferDataRW6(5) >> 6;
            bytes[5] = (getBufferDataRW6(5) & 63) << 2 | getBufferDataRW6(6) >> 6;
            bytes[6] = getBufferDataRW6(6) >> 4 & 3;
            bytes[7] = (getBufferDataRW6(6) & 15) << 4 | getBufferDataRW6(7) >> 4;
            bytes[8] = (getBufferDataRW6(7) & 15) << 4 | getBufferDataRW6(8) >> 4;
            bytes[9] = (getBufferDataRW6(8) & 15) << 4 | getBufferDataRW6(9) >> 4;
            bytes[10] = getBufferDataRW6(9) >> 2 & 3;
            bytes[11] = (getBufferDataRW6(9) & 3) << 6 | getBufferDataRW6(10) >> 2;
            bytes[12] = (getBufferDataRW6(10) & 3) << 6 | getBufferDataRW6(11) >> 2;
            bytes[13] = (getBufferDataRW6(11) & 3) << 6 | getBufferDataRW6(12) >> 2;
            bytes[14] = getBufferDataRW6(12) & 3;
            bytes[15] = getBufferDataRW6(13);
            bytes[16] = getBufferDataRW6(14);
            bytes[17] = getBufferDataRW6(15);
            vpos += 16;
            byte = 0;
          }
          function resetPredNonzeros() {
            pred[0] = 0;
            pred[1] = 0;
            nonz[0] = 0;
            nonz[1] = 0;
          }
          if (RW2_Format == 7) {
            throw RW2_Format;
          } else if (RW2_Format == 6) {
            var is12bit = bitsPerSample == 12, readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6, pixelsPerBlock = is12bit ? 14 : 11, pixelbase0 = is12bit ? 128 : 512, pixelbase_compare = is12bit ? 2048 : 8192, spix_compare = is12bit ? 16383 : 65535, pixel_mask = is12bit ? 4095 : 16383, blocksperrow = rawWidth / pixelsPerBlock, rowbytes = blocksperrow * 16, bufferSize = is12bit ? 18 : 14;
            for (row = 0; row < rawHeight - 15; row += 16) {
              var rowstoread = Math.min(16, rawHeight - row);
              var readlen = rowbytes * rowstoread;
              buffer = new Uint8Array(img_buffer, off + bidx, readlen);
              vpos = 0;
              bidx += readlen;
              for (crow = 0, col = 0; crow < rowstoread; crow++, col = 0) {
                idx = (row + crow) * rawWidth;
                for (var rblock = 0; rblock < blocksperrow; rblock++) {
                  readPageRw6Fn();
                  resetPredNonzeros();
                  sh = 0;
                  pixel_base = 0;
                  for (i2 = 0; i2 < pixelsPerBlock; i2++) {
                    isOdd = i2 & 1;
                    if (i2 % 3 == 2) {
                      var base = byte < bufferSize ? bytes[byte++] : 0;
                      if (base == 3)
                        base = 4;
                      pixel_base = pixelbase0 << base;
                      sh = 1 << base;
                    }
                    var epixel = byte < bufferSize ? bytes[byte++] : 0;
                    if (pred[isOdd]) {
                      epixel *= sh;
                      if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base)
                        epixel += nonz[isOdd] - pixel_base;
                      nonz[isOdd] = epixel;
                    } else {
                      pred[isOdd] = epixel;
                      if (epixel)
                        nonz[isOdd] = epixel;
                      else
                        epixel = nonz[isOdd];
                    }
                    result[idx + col++] = epixel - 15 <= spix_compare ? epixel - 15 & spix_compare : epixel + 2147483633 >> 31 & pixel_mask;
                  }
                }
              }
            }
          } else if (RW2_Format == 5) {
            var blockSize = bitsPerSample == 12 ? 10 : 9;
            for (row = 0; row < rawHeight; row++) {
              for (col = 0; col < rawWidth; col += blockSize) {
                getDataRaw(0);
                if (bitsPerSample == 12) {
                  result[idx++] = ((bytes[1] & 15) << 8) + bytes[0];
                  result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);
                  result[idx++] = ((bytes[4] & 15) << 8) + bytes[3];
                  result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);
                  result[idx++] = ((bytes[7] & 15) << 8) + bytes[6];
                  result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);
                  result[idx++] = ((bytes[10] & 15) << 8) + bytes[9];
                  result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);
                  result[idx++] = ((bytes[13] & 15) << 8) + bytes[12];
                  result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);
                } else if (bitsPerSample == 14) {
                  result[idx++] = bytes[0] + ((bytes[1] & 63) << 8);
                  result[idx++] = (bytes[1] >> 6) + 4 * bytes[2] + ((bytes[3] & 15) << 10);
                  result[idx++] = (bytes[3] >> 4) + 16 * bytes[4] + ((bytes[5] & 3) << 12);
                  result[idx++] = ((bytes[5] & 252) >> 2) + (bytes[6] << 6);
                  result[idx++] = bytes[7] + ((bytes[8] & 63) << 8);
                  result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 15) << 10);
                  result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);
                  result[idx++] = ((bytes[12] & 252) >> 2) + (bytes[13] << 6);
                  result[idx++] = bytes[14] + ((bytes[15] & 63) << 8);
                }
              }
            }
          } else if (RW2_Format == 4) {
            for (row = 0; row < rawHeight; row++) {
              for (col = 0; col < rawWidth; col++) {
                i2 = col % 14;
                isOdd = i2 & 1;
                if (i2 == 0)
                  resetPredNonzeros();
                if (i2 % 3 == 2)
                  sh = 4 >> 3 - getDataRaw(2);
                if (nonz[isOdd]) {
                  j = getDataRaw(8);
                  if (j != 0) {
                    pred[isOdd] -= 128 << sh;
                    if (pred[isOdd] < 0 || sh == 4)
                      pred[isOdd] &= ~(-1 << sh);
                    pred[isOdd] += j << sh;
                  }
                } else {
                  nonz[isOdd] = getDataRaw(8);
                  if (nonz[isOdd] || i2 > 11)
                    pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);
                }
                result[idx++] = pred[col & 1];
              }
            }
          } else
            throw RW2_Format;
        };
        UTIF2.decode._decodeVC5 = function() {
          var x = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], o, C, k, P = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1], V = 24576, ar = 16384, H = 8192, az = ar | H;
          function d(t) {
            var E = t[1], h = t[0][E >>> 3] >>> 7 - (E & 7) & 1;
            t[1]++;
            return h;
          }
          function ag(t, E) {
            if (o == null) {
              o = {};
              for (var h = 0; h < x.length; h += 4)
                o[x[h + 1]] = x.slice(h, h + 4);
            }
            var L = d(t), g = o[L];
            while (g == null) {
              L = L << 1 | d(t);
              g = o[L];
            }
            var n = g[3];
            if (n != 0)
              n = d(t) == 0 ? n : -n;
            E[0] = g[2];
            E[1] = n;
          }
          function m(t, E) {
            for (var h = 0; h < E; h++) {
              if ((t & 1) == 1)
                t++;
              t = t >>> 1;
            }
            return t;
          }
          function A(t, E) {
            return t >> E;
          }
          function O(t, E, h, L, g, n) {
            E[h] = A(A(11 * t[g] - 4 * t[g + n] + t[g + n + n] + 4, 3) + t[L], 1);
            E[h + n] = A(A(5 * t[g] + 4 * t[g + n] - t[g + n + n] + 4, 3) - t[L], 1);
          }
          function J(t, E, h, L, g, n) {
            var W = t[g - n] - t[g + n], j = t[g], $2 = t[L];
            E[h] = A(A(W + 4, 3) + j + $2, 1);
            E[h + n] = A(A(-W + 4, 3) + j - $2, 1);
          }
          function y(t, E, h, L, g, n) {
            E[h] = A(A(5 * t[g] + 4 * t[g - n] - t[g - n - n] + 4, 3) + t[L], 1);
            E[h + n] = A(A(11 * t[g] - 4 * t[g - n] + t[g - n - n] + 4, 3) - t[L], 1);
          }
          function q(t) {
            t = t < 0 ? 0 : t > 4095 ? 4095 : t;
            t = k[t] >>> 2;
            return t;
          }
          function av(t, E, h, L, g, n) {
            L = new Uint16Array(L.buffer);
            var W = Date.now(), j = UTIF2._binBE, $2 = E + h, r, u, X, I, ax, a3, R, ai, aa, ap, ah, ae, aD, al, i2, aE, T, B;
            E += 4;
            var a5 = n[0] == 1;
            while (E < $2) {
              var S = j.readShort(t, E), s = j.readUshort(t, E + 2);
              E += 4;
              if (S == 12)
                r = s;
              else if (S == 20)
                u = s;
              else if (S == 21)
                X = s;
              else if (S == 48)
                I = s;
              else if (S == 53)
                ax = s;
              else if (S == 35)
                a3 = s;
              else if (S == 62)
                R = s;
              else if (S == 101)
                ai = s;
              else if (S == 109)
                aa = s;
              else if (S == 84)
                ap = s;
              else if (S == 106)
                ah = s;
              else if (S == 107)
                ae = s;
              else if (S == 108)
                aD = s;
              else if (S == 102)
                al = s;
              else if (S == 104)
                i2 = s;
              else if (S == 105)
                aE = s;
              else {
                var F = S < 0 ? -S : S, D = F & 65280, _ = 0;
                if (F & az) {
                  if (F & H) {
                    _ = s & 65535;
                    _ += (F & 255) << 16;
                  } else {
                    _ = s & 65535;
                  }
                }
                if ((F & V) == V) {
                  if (T == null) {
                    T = [];
                    for (var M = 0; M < 4; M++)
                      T[M] = new Int16Array((u >>> 1) * (X >>> 1));
                    B = new Int16Array((u >>> 1) * (X >>> 1));
                    C = new Int16Array(1024);
                    for (var M = 0; M < 1024; M++) {
                      var aG = M - 512, p = Math.abs(aG), r = Math.floor(768 * p * p * p / (255 * 255 * 255)) + p;
                      C[M] = Math.sign(aG) * r;
                    }
                    k = new Uint16Array(4096);
                    var aA = (1 << 16) - 1;
                    for (var M = 0; M < 4096; M++) {
                      var at = M, a1 = aA * (Math.pow(113, at / 4095) - 1) / 112;
                      k[M] = Math.min(a1, aA);
                    }
                  }
                  var w = T[R], v = m(u, 1 + P[I]), N = m(X, 1 + P[I]);
                  if (I == 0) {
                    for (var b = 0; b < N; b++)
                      for (var G = 0; G < v; G++) {
                        var c = E + (b * v + G) * 2;
                        w[b * (u >>> 1) + G] = t[c] << 8 | t[c + 1];
                      }
                  } else {
                    var a7 = [t, E * 8], a4 = [], ay = 0, aw = v * N, f = [0, 0], Q = 0, s = 0;
                    while (ay < aw) {
                      ag(a7, f);
                      Q = f[0];
                      s = f[1];
                      while (Q > 0) {
                        a4[ay++] = s;
                        Q--;
                      }
                    }
                    var l = (I - 1) % 3, aF = l != 1 ? v : 0, a2 = l != 0 ? N : 0;
                    for (var b = 0; b < N; b++) {
                      var af = (b + a2) * (u >>> 1) + aF, au = b * v;
                      for (var G = 0; G < v; G++)
                        w[af + G] = C[a4[au + G] + 512] * ax;
                    }
                    if (l == 2) {
                      var i2 = u >>> 1, an = v * 2, a9 = N * 2;
                      for (var b = 0; b < N; b++) {
                        for (var G = 0; G < an; G++) {
                          var M = b * 2 * i2 + G, a = b * i2 + G, e = N * i2 + a;
                          if (b == 0)
                            O(w, B, M, e, a, i2);
                          else if (b == N - 1)
                            y(w, B, M, e, a, i2);
                          else
                            J(w, B, M, e, a, i2);
                        }
                      }
                      var Z = w;
                      w = B;
                      B = Z;
                      for (var b = 0; b < a9; b++) {
                        for (var G = 0; G < v; G++) {
                          var M = b * i2 + 2 * G, a = b * i2 + G, e = v + a;
                          if (G == 0)
                            O(w, B, M, e, a, 1);
                          else if (G == v - 1)
                            y(w, B, M, e, a, 1);
                          else
                            J(w, B, M, e, a, 1);
                        }
                      }
                      var Z = w;
                      w = B;
                      B = Z;
                      var aC = [], aB = 2 - ~~((I - 1) / 3);
                      for (var K = 0; K < 3; K++)
                        aC[K] = aa >> 14 - K * 2 & 3;
                      var a6 = aC[aB];
                      if (a6 != 0)
                        for (var b = 0; b < a9; b++)
                          for (var G = 0; G < an; G++) {
                            var M = b * i2 + G;
                            w[M] = w[M] << a6;
                          }
                    }
                  }
                  if (I == 9 && R == 3) {
                    var a8 = T[0], ab = T[1], aq = T[2], as = T[3];
                    for (var b = 0; b < X; b += 2)
                      for (var G = 0; G < u; G += 2) {
                        var U = b * u + G, c = (b >>> 1) * (u >>> 1) + (G >>> 1), z = a8[c], ao = ab[c] - 2048, ak = aq[c] - 2048, ad = as[c] - 2048, aj = (ao << 1) + z, a0 = (ak << 1) + z, aH = z + ad, am = z - ad;
                        if (a5) {
                          L[U] = q(aH);
                          L[U + 1] = q(a0);
                          L[U + u] = q(aj);
                          L[U + u + 1] = q(am);
                        } else {
                          L[U] = q(aj);
                          L[U + 1] = q(aH);
                          L[U + u] = q(am);
                          L[U + u + 1] = q(a0);
                        }
                      }
                  }
                  E += _ * 4;
                } else if (F == 16388) {
                  E += _ * 4;
                } else if (D == 8192 || D == 8448 || D == 9216) {
                } else
                  throw F.toString(16);
              }
            }
            console.log(Date.now() - W);
          }
          return av;
        }();
        UTIF2.decode._decodeLogLuv32 = function(img, data, off, len, tgt, toff) {
          var w = img.width, qw = w * 4;
          var io = 0, out = new Uint8Array(qw);
          while (io < len) {
            var oo = 0;
            while (oo < qw) {
              var c = data[off + io];
              io++;
              if (c < 128) {
                for (var j = 0; j < c; j++)
                  out[oo + j] = data[off + io + j];
                oo += c;
                io += c;
              } else {
                c = c - 126;
                for (var j = 0; j < c; j++)
                  out[oo + j] = data[off + io];
                oo += c;
                io++;
              }
            }
            for (var x = 0; x < w; x++) {
              tgt[toff + 0] = out[x];
              tgt[toff + 1] = out[x + w];
              tgt[toff + 2] = out[x + w * 2];
              tgt[toff + 4] = out[x + w * 3];
              toff += 6;
            }
          }
        };
        UTIF2.decode._ljpeg_diff = function(data, prm, huff) {
          var getbithuff = UTIF2.decode._getbithuff;
          var len, diff;
          len = getbithuff(data, prm, huff[0], huff);
          diff = getbithuff(data, prm, len, 0);
          if ((diff & 1 << len - 1) == 0)
            diff -= (1 << len) - 1;
          return diff;
        };
        UTIF2.decode._decodeARW = function(img, inp, off, src_length, tgt, toff) {
          var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
          var bin = img.isLE ? UTIF2._binLE : UTIF2._binBE;
          var arw2 = raw_width * height == src_length || raw_width * height * 1.5 == src_length;
          if (!arw2) {
            height += 8;
            var prm = [off, 0, 0, 0];
            var huff = new Uint16Array(32770);
            var tab = [
              3857,
              3856,
              3599,
              3342,
              3085,
              2828,
              2571,
              2314,
              2057,
              1800,
              1543,
              1286,
              1029,
              772,
              771,
              768,
              514,
              513
            ];
            var i2, c, n, col, row, sum = 0;
            var ljpeg_diff = UTIF2.decode._ljpeg_diff;
            huff[0] = 15;
            for (n = i2 = 0; i2 < 18; i2++) {
              var lim = 32768 >>> (tab[i2] >>> 8);
              for (var c = 0; c < lim; c++)
                huff[++n] = tab[i2];
            }
            for (col = raw_width; col--; )
              for (row = 0; row < height + 1; row += 2) {
                if (row == height)
                  row = 1;
                sum += ljpeg_diff(inp, prm, huff);
                if (row < height) {
                  var clr = sum & 4095;
                  UTIF2.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
                }
              }
            return;
          }
          if (raw_width * height * 1.5 == src_length) {
            for (var i2 = 0; i2 < src_length; i2 += 3) {
              var b0 = inp[off + i2 + 0], b1 = inp[off + i2 + 1], b2 = inp[off + i2 + 2];
              tgt[toff + i2] = b1 << 4 | b0 >>> 4;
              tgt[toff + i2 + 1] = b0 << 4 | b2 >>> 4;
              tgt[toff + i2 + 2] = b2 << 4 | b1 >>> 4;
            }
            return;
          }
          var pix = new Uint16Array(16);
          var row, col, val, max2, min2, imax, imin, sh, bit, i2, dp;
          var data = new Uint8Array(raw_width + 1);
          for (row = 0; row < height; row++) {
            for (var j = 0; j < raw_width; j++)
              data[j] = inp[off++];
            for (dp = 0, col = 0; col < raw_width - 30; dp += 16) {
              max2 = 2047 & (val = bin.readUint(data, dp));
              min2 = 2047 & val >>> 11;
              imax = 15 & val >>> 22;
              imin = 15 & val >>> 26;
              for (sh = 0; sh < 4 && 128 << sh <= max2 - min2; sh++)
                ;
              for (bit = 30, i2 = 0; i2 < 16; i2++)
                if (i2 == imax)
                  pix[i2] = max2;
                else if (i2 == imin)
                  pix[i2] = min2;
                else {
                  pix[i2] = ((bin.readUshort(data, dp + (bit >> 3)) >>> (bit & 7) & 127) << sh) + min2;
                  if (pix[i2] > 2047)
                    pix[i2] = 2047;
                  bit += 7;
                }
              for (i2 = 0; i2 < 16; i2++, col += 2) {
                var clr = pix[i2] << 1;
                UTIF2.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);
              }
              col -= col & 1 ? 1 : 31;
            }
          }
        };
        UTIF2.decode._decodeNikon = function(img, imgs, data, off, src_length, tgt, toff) {
          var nikon_tree = [
            [
              0,
              0,
              1,
              5,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              /* 12-bit lossy */
              5,
              4,
              3,
              6,
              2,
              7,
              1,
              0,
              8,
              9,
              11,
              10,
              12
            ],
            [
              0,
              0,
              1,
              5,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              /* 12-bit lossy after split */
              57,
              90,
              56,
              39,
              22,
              5,
              4,
              3,
              2,
              1,
              0,
              11,
              12,
              12
            ],
            [
              0,
              0,
              1,
              4,
              2,
              3,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              /* 12-bit lossless */
              5,
              4,
              6,
              3,
              7,
              2,
              8,
              1,
              9,
              0,
              10,
              11,
              12
            ],
            [
              0,
              0,
              1,
              4,
              3,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              /* 14-bit lossy */
              5,
              6,
              4,
              7,
              8,
              3,
              9,
              2,
              1,
              0,
              10,
              11,
              12,
              13,
              14
            ],
            [
              0,
              0,
              1,
              5,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              /* 14-bit lossy after split */
              8,
              92,
              75,
              58,
              41,
              7,
              6,
              5,
              4,
              3,
              2,
              1,
              0,
              13,
              14
            ],
            [
              0,
              0,
              1,
              4,
              2,
              2,
              3,
              1,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              /* 14-bit lossless */
              7,
              6,
              8,
              5,
              9,
              4,
              10,
              3,
              11,
              12,
              2,
              0,
              1,
              13,
              14
            ]
          ];
          var raw_width = img["t256"][0], height = img["t257"][0], tiff_bps = img["t258"][0];
          var tree = 0, split = 0;
          var make_decoder = UTIF2.decode._make_decoder;
          var getbithuff = UTIF2.decode._getbithuff;
          var mn = imgs[0].exifIFD.makerNote, md = mn["t150"] ? mn["t150"] : mn["t140"], mdo = 0;
          var ver0 = md[mdo++], ver1 = md[mdo++];
          if (ver0 == 73 || ver1 == 88)
            mdo += 2110;
          if (ver0 == 70)
            tree = 2;
          if (tiff_bps == 14)
            tree += 3;
          var vpred = [[0, 0], [0, 0]], bin = img.isLE ? UTIF2._binLE : UTIF2._binBE;
          for (var i2 = 0; i2 < 2; i2++)
            for (var j = 0; j < 2; j++) {
              vpred[i2][j] = bin.readShort(md, mdo);
              mdo += 2;
            }
          var max2 = 1 << tiff_bps & 32767, step = 0;
          var csize = bin.readShort(md, mdo);
          mdo += 2;
          if (csize > 1)
            step = Math.floor(max2 / (csize - 1));
          if (ver0 == 68 && ver1 == 32 && step > 0)
            split = bin.readShort(md, 562);
          var i2;
          var row, col;
          var len, shl, diff;
          var min_v = 0;
          var hpred = [0, 0];
          var huff = make_decoder(nikon_tree[tree]);
          var prm = [off, 0, 0, 0];
          for (min_v = row = 0; row < height; row++) {
            if (split && row == split) {
              huff = make_decoder(nikon_tree[tree + 1]);
            }
            for (col = 0; col < raw_width; col++) {
              i2 = getbithuff(data, prm, huff[0], huff);
              len = i2 & 15;
              shl = i2 >>> 4;
              diff = (getbithuff(data, prm, len - shl, 0) << 1) + 1 << shl >>> 1;
              if ((diff & 1 << len - 1) == 0)
                diff -= (1 << len) - (shl == 0 ? 1 : 0);
              if (col < 2)
                hpred[col] = vpred[row & 1][col] += diff;
              else
                hpred[col & 1] += diff;
              var clr = Math.min(Math.max(hpred[col & 1], 0), (1 << tiff_bps) - 1);
              var bti = (row * raw_width + col) * tiff_bps;
              UTIF2.decode._putsF(tgt, bti, clr << 16 - tiff_bps);
            }
          }
        };
        UTIF2.decode._putsF = function(dt, pos, val) {
          val = val << 8 - (pos & 7);
          var o = pos >>> 3;
          dt[o] |= val >>> 16;
          dt[o + 1] |= val >>> 8;
          dt[o + 2] |= val;
        };
        UTIF2.decode._getbithuff = function(data, prm, nbits, huff) {
          var zero_after_ff = 0;
          var get_byte = UTIF2.decode._get_byte;
          var c;
          var off = prm[0], bitbuf = prm[1], vbits = prm[2], reset = prm[3];
          if (nbits == 0 || vbits < 0)
            return 0;
          while (!reset && vbits < nbits && (c = data[off++]) != -1 && !(reset = zero_after_ff && c == 255 && data[off++])) {
            bitbuf = (bitbuf << 8) + c;
            vbits += 8;
          }
          c = bitbuf << 32 - vbits >>> 32 - nbits;
          if (huff) {
            vbits -= huff[c + 1] >>> 8;
            c = huff[c + 1] & 255;
          } else
            vbits -= nbits;
          if (vbits < 0)
            throw "e";
          prm[0] = off;
          prm[1] = bitbuf;
          prm[2] = vbits;
          prm[3] = reset;
          return c;
        };
        UTIF2.decode._make_decoder = function(source) {
          var max2, len, h, i2, j;
          var huff = [];
          for (max2 = 16; max2 != 0 && !source[max2]; max2--)
            ;
          var si = 17;
          huff[0] = max2;
          for (h = len = 1; len <= max2; len++)
            for (i2 = 0; i2 < source[len]; i2++, ++si)
              for (j = 0; j < 1 << max2 - len; j++)
                if (h <= 1 << max2)
                  huff[h++] = len << 8 | source[si];
          return huff;
        };
        UTIF2.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
          len = Math.min(len, data.length - off);
          var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
          if (tables) {
            var SOI = 216, EOI2 = 217, boff = 0;
            for (var i2 = 0; i2 < tlen - 1; i2++) {
              if (tables[i2] == 255 && tables[i2 + 1] == EOI2)
                break;
              buff[boff++] = tables[i2];
            }
            var byte1 = data[off], byte2 = data[off + 1];
            if (byte1 != 255 || byte2 != SOI) {
              buff[boff++] = byte1;
              buff[boff++] = byte2;
            }
            for (var i2 = 2; i2 < len; i2++)
              buff[boff++] = data[off + i2];
          } else
            for (var i2 = 0; i2 < len; i2++)
              buff[i2] = data[off + i2];
          if (img["t262"][0] == 32803 || img["t259"][0] == 7 && img["t262"][0] == 34892) {
            var bps = img["t258"][0];
            var out = UTIF2.LosslessJpegDecode(buff), olen = out.length;
            if (false) {
            } else if (bps == 16) {
              if (img.isLE)
                for (var i2 = 0; i2 < olen; i2++) {
                  tgt[toff + (i2 << 1)] = out[i2] & 255;
                  tgt[toff + (i2 << 1) + 1] = out[i2] >>> 8;
                }
              else
                for (var i2 = 0; i2 < olen; i2++) {
                  tgt[toff + (i2 << 1)] = out[i2] >>> 8;
                  tgt[toff + (i2 << 1) + 1] = out[i2] & 255;
                }
            } else if (bps == 14 || bps == 12 || bps == 10) {
              var rst = 16 - bps;
              for (var i2 = 0; i2 < olen; i2++)
                UTIF2.decode._putsF(tgt, i2 * bps, out[i2] << rst);
            } else if (bps == 8) {
              for (var i2 = 0; i2 < olen; i2++)
                tgt[toff + i2] = out[i2];
            } else
              throw new Error("unsupported bit depth " + bps);
          } else {
            var parser = new UTIF2.JpegDecoder();
            parser.parse(buff);
            var decoded = parser.getData({ "width": parser.width, "height": parser.height, "forceRGB": true, "isSourcePDF": false });
            for (var i2 = 0; i2 < decoded.length; i2++)
              tgt[toff + i2] = decoded[i2];
          }
          if (img["t262"][0] == 6)
            img["t262"][0] = 2;
        };
        UTIF2.decode._decodeOldJPEGInit = function(img, data, off, len) {
          var SOI = 216, EOI2 = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
          var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i2, j, k;
          var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
          var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
          var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
          var ycbcrss = img["t530"], ssx = 0, ssy = 0;
          var spp = img["t277"] ? img["t277"][0] : 1;
          var jpgresint = img["t515"];
          if (soffTag) {
            soff = soffTag[0];
            isTiled = soffTag.length > 1;
          }
          if (!isTiled) {
            if (data[off] == 255 && data[off + 1] == SOI)
              return { jpegOffset: off };
            if (jpgIchgFmt != null) {
              if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI)
                joff = off + jifoff;
              else
                log("JPEGInterchangeFormat does not point to SOI");
              if (jpgIchgFmtLen == null)
                log("JPEGInterchangeFormatLength field is missing");
              else if (jifoff >= soff || jifoff + jiflen <= soff)
                log("JPEGInterchangeFormatLength field value is invalid");
              if (joff != null)
                return { jpegOffset: joff };
            }
          }
          if (ycbcrss != null) {
            ssx = ycbcrss[0];
            ssy = ycbcrss[1];
          }
          if (jpgIchgFmt != null) {
            if (jpgIchgFmtLen != null)
              if (jiflen >= 2 && jifoff + jiflen <= soff) {
                if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI)
                  tables = new Uint8Array(jiflen - 2);
                else
                  tables = new Uint8Array(jiflen);
                for (i2 = 0; i2 < tables.length; i2++)
                  tables[i2] = data[off + jifoff + i2];
                log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
              } else
                log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
          }
          if (tables == null) {
            var ooff = 0, out = [];
            out[ooff++] = 255;
            out[ooff++] = SOI;
            var qtables = img["t519"];
            if (qtables == null)
              throw new Error("JPEGQTables tag is missing");
            for (i2 = 0; i2 < qtables.length; i2++) {
              out[ooff++] = 255;
              out[ooff++] = DQT;
              out[ooff++] = 0;
              out[ooff++] = 67;
              out[ooff++] = i2;
              for (j = 0; j < 64; j++)
                out[ooff++] = data[off + qtables[i2] + j];
            }
            for (k = 0; k < 2; k++) {
              var htables = img[k == 0 ? "t520" : "t521"];
              if (htables == null)
                throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
              for (i2 = 0; i2 < htables.length; i2++) {
                out[ooff++] = 255;
                out[ooff++] = DHT;
                var nc = 19;
                for (j = 0; j < 16; j++)
                  nc += data[off + htables[i2] + j];
                out[ooff++] = nc >>> 8;
                out[ooff++] = nc & 255;
                out[ooff++] = i2 | k << 4;
                for (j = 0; j < 16; j++)
                  out[ooff++] = data[off + htables[i2] + j];
                for (j = 0; j < nc; j++)
                  out[ooff++] = data[off + htables[i2] + 16 + j];
              }
            }
            out[ooff++] = 255;
            out[ooff++] = SOF0;
            out[ooff++] = 0;
            out[ooff++] = 8 + 3 * spp;
            out[ooff++] = 8;
            out[ooff++] = img.height >>> 8 & 255;
            out[ooff++] = img.height & 255;
            out[ooff++] = img.width >>> 8 & 255;
            out[ooff++] = img.width & 255;
            out[ooff++] = spp;
            if (spp == 1) {
              out[ooff++] = 1;
              out[ooff++] = 17;
              out[ooff++] = 0;
            } else
              for (i2 = 0; i2 < 3; i2++) {
                out[ooff++] = i2 + 1;
                out[ooff++] = i2 != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
                out[ooff++] = i2;
              }
            if (jpgresint != null && jpgresint[0] != 0) {
              out[ooff++] = 255;
              out[ooff++] = DRI;
              out[ooff++] = 0;
              out[ooff++] = 4;
              out[ooff++] = jpgresint[0] >>> 8 & 255;
              out[ooff++] = jpgresint[0] & 255;
            }
            tables = new Uint8Array(out);
          }
          var sofpos = -1;
          i2 = 0;
          while (i2 < tables.length - 1) {
            if (tables[i2] == 255 && tables[i2 + 1] == SOF0) {
              sofpos = i2;
              break;
            }
            i2++;
          }
          if (sofpos == -1) {
            var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
            tmptab.set(tables);
            var tmpoff = tables.length;
            sofpos = tables.length;
            tables = tmptab;
            tables[tmpoff++] = 255;
            tables[tmpoff++] = SOF0;
            tables[tmpoff++] = 0;
            tables[tmpoff++] = 8 + 3 * spp;
            tables[tmpoff++] = 8;
            tables[tmpoff++] = img.height >>> 8 & 255;
            tables[tmpoff++] = img.height & 255;
            tables[tmpoff++] = img.width >>> 8 & 255;
            tables[tmpoff++] = img.width & 255;
            tables[tmpoff++] = spp;
            if (spp == 1) {
              tables[tmpoff++] = 1;
              tables[tmpoff++] = 17;
              tables[tmpoff++] = 0;
            } else
              for (i2 = 0; i2 < 3; i2++) {
                tables[tmpoff++] = i2 + 1;
                tables[tmpoff++] = i2 != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
                tables[tmpoff++] = i2;
              }
          }
          if (data[soff] == 255 && data[soff + 1] == SOS2) {
            var soslen = data[soff + 2] << 8 | data[soff + 3];
            sosMarker2 = new Uint8Array(soslen + 2);
            sosMarker2[0] = data[soff];
            sosMarker2[1] = data[soff + 1];
            sosMarker2[2] = data[soff + 2];
            sosMarker2[3] = data[soff + 3];
            for (i2 = 0; i2 < soslen - 2; i2++)
              sosMarker2[i2 + 4] = data[soff + i2 + 4];
          } else {
            sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
            var sosoff = 0;
            sosMarker2[sosoff++] = 255;
            sosMarker2[sosoff++] = SOS2;
            sosMarker2[sosoff++] = 0;
            sosMarker2[sosoff++] = 6 + 2 * spp;
            sosMarker2[sosoff++] = spp;
            if (spp == 1) {
              sosMarker2[sosoff++] = 1;
              sosMarker2[sosoff++] = 0;
            } else
              for (i2 = 0; i2 < 3; i2++) {
                sosMarker2[sosoff++] = i2 + 1;
                sosMarker2[sosoff++] = i2 << 4 | i2;
              }
            sosMarker2[sosoff++] = 0;
            sosMarker2[sosoff++] = 63;
            sosMarker2[sosoff++] = 0;
          }
          return { jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos };
        };
        UTIF2.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
          var i2, dlen, tlen, buff, buffoff;
          var jpegData = UTIF2.decode._decodeOldJPEGInit(img, data, off, len);
          if (jpegData.jpegOffset != null) {
            dlen = off + len - jpegData.jpegOffset;
            buff = new Uint8Array(dlen);
            for (i2 = 0; i2 < dlen; i2++)
              buff[i2] = data[jpegData.jpegOffset + i2];
          } else {
            tlen = jpegData.tables.length;
            buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
            buff.set(jpegData.tables);
            buffoff = tlen;
            buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
            buff[jpegData.sofPosition + 6] = img.height & 255;
            buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
            buff[jpegData.sofPosition + 8] = img.width & 255;
            if (data[off] != 255 || data[off + 1] != SOS) {
              buff.set(jpegData.sosMarker, buffoff);
              buffoff += sosMarker.length;
            }
            for (i2 = 0; i2 < len; i2++)
              buff[buffoff++] = data[off + i2];
            buff[buffoff++] = 255;
            buff[buffoff++] = EOI;
          }
          var parser = new UTIF2.JpegDecoder();
          parser.parse(buff);
          var decoded = parser.getData({ "width": parser.width, "height": parser.height, "forceRGB": true, "isSourcePDF": false });
          for (var i2 = 0; i2 < decoded.length; i2++)
            tgt[toff + i2] = decoded[i2];
          if (img["t262"] && img["t262"][0] == 6)
            img["t262"][0] = 2;
        };
        UTIF2.decode._decodePackBits = function(data, off, len, tgt, toff) {
          var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
          while (off < lim) {
            var n = sa[off];
            off++;
            if (n >= 0 && n < 128)
              for (var i2 = 0; i2 < n + 1; i2++) {
                ta[toff] = sa[off];
                toff++;
                off++;
              }
            if (n >= -127 && n < 0) {
              for (var i2 = 0; i2 < -n + 1; i2++) {
                ta[toff] = sa[off];
                toff++;
              }
              off++;
            }
          }
          return toff;
        };
        UTIF2.decode._decodeThunder = function(data, off, len, tgt, toff) {
          var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
          var lim = off + len, qoff = toff * 2, px2 = 0;
          while (off < lim) {
            var b = data[off], msk = b >>> 6, n = b & 63;
            off++;
            if (msk == 3) {
              px2 = n & 15;
              tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
              qoff++;
            }
            if (msk == 0)
              for (var i2 = 0; i2 < n; i2++) {
                tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
                qoff++;
              }
            if (msk == 2)
              for (var i2 = 0; i2 < 2; i2++) {
                var d = n >>> 3 * (1 - i2) & 7;
                if (d != 4) {
                  px2 += d3[d];
                  tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
                  qoff++;
                }
              }
            if (msk == 1)
              for (var i2 = 0; i2 < 3; i2++) {
                var d = n >>> 2 * (2 - i2) & 3;
                if (d != 2) {
                  px2 += d2[d];
                  tgt[qoff >>> 1] |= px2 << 4 * (1 - qoff & 1);
                  qoff++;
                }
              }
          }
        };
        UTIF2.decode._dmap = { "1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 };
        UTIF2.decode._lens = function() {
          var addKeys = function(lens, arr, i0, inc) {
            for (var i2 = 0; i2 < arr.length; i2++)
              lens[arr[i2]] = i0 + i2 * inc;
          };
          var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
          var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
          var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
          var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101";
          var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
          termW = termW.split(",");
          termB = termB.split(",");
          makeW = makeW.split(",");
          makeB = makeB.split(",");
          makeA = makeA.split(",");
          var lensW = {}, lensB = {};
          addKeys(lensW, termW, 0, 1);
          addKeys(lensW, makeW, 64, 64);
          addKeys(lensW, makeA, 1792, 64);
          addKeys(lensB, termB, 0, 1);
          addKeys(lensB, makeB, 64, 64);
          addKeys(lensB, makeA, 1792, 64);
          return [lensW, lensB];
        }();
        UTIF2.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
          var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
          var line = [], pline = [];
          for (var i2 = 0; i2 < w; i2++)
            pline.push(0);
          pline = U._makeDiff(pline);
          var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
          var y = 0, mode = "", toRead = 0;
          var bipl = Math.ceil(w / 8) * 8;
          while (boff >>> 3 < off + slen) {
            b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
            var bit = 0;
            if (fo == 1)
              bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
            if (fo == 2)
              bit = data[boff >>> 3] >>> (boff & 7) & 1;
            boff++;
            wrd += bit;
            if (mode == "H") {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  a0 += len;
                  clr = 1 - clr;
                  len = 0;
                  toRead--;
                  if (toRead == 0)
                    mode = "";
                }
              }
            } else {
              if (wrd == "0001") {
                wrd = "";
                U._addNtimes(line, b2 - a0, clr);
                a0 = b2;
              }
              if (wrd == "001") {
                wrd = "";
                mode = "H";
                toRead = 2;
              }
              if (U._dmap[wrd] != null) {
                a1 = b1 + U._dmap[wrd];
                U._addNtimes(line, a1 - a0, clr);
                a0 = a1;
                wrd = "";
                clr = 1 - clr;
              }
            }
            if (line.length == w && mode == "") {
              U._writeBits(line, tgt, toff * 8 + y * bipl);
              clr = 0;
              y++;
              a0 = 0;
              pline = U._makeDiff(line);
              line = [];
            }
          }
        };
        UTIF2.decode._findDiff = function(line, x, clr) {
          for (var i2 = 0; i2 < line.length; i2 += 2)
            if (line[i2] >= x && line[i2 + 1] == clr)
              return line[i2];
        };
        UTIF2.decode._makeDiff = function(line) {
          var out = [];
          if (line[0] == 1)
            out.push(0, 1);
          for (var i2 = 1; i2 < line.length; i2++)
            if (line[i2 - 1] != line[i2])
              out.push(i2, line[i2]);
          out.push(line.length, 0, line.length, 1);
          return out;
        };
        UTIF2.decode._decodeG2 = function(data, off, slen, tgt, toff, w, fo) {
          var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
          var line = [];
          var clr = 0;
          var y = 0;
          var bipl = Math.ceil(w / 8) * 8;
          while (boff >>> 3 < off + slen) {
            var bit = 0;
            if (fo == 1)
              bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
            if (fo == 2)
              bit = data[boff >>> 3] >>> (boff & 7) & 1;
            boff++;
            wrd += bit;
            len = U._lens[clr][wrd];
            if (len != null) {
              U._addNtimes(line, len, clr);
              wrd = "";
              if (len < 64)
                clr = 1 - clr;
              if (line.length == w) {
                U._writeBits(line, tgt, toff * 8 + y * bipl);
                line = [];
                y++;
                clr = 0;
                if ((boff & 7) != 0)
                  boff += 8 - (boff & 7);
                if (len >= 64)
                  boff += 8;
              }
            }
          }
        };
        UTIF2.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo, twoDim) {
          var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
          var line = [], pline = [];
          for (var i2 = 0; i2 < w; i2++)
            line.push(0);
          var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
          var y = -1, mode = "", toRead = 0, is1D = true;
          var bipl = Math.ceil(w / 8) * 8;
          while (boff >>> 3 < off + slen) {
            b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
            var bit = 0;
            if (fo == 1)
              bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
            if (fo == 2)
              bit = data[boff >>> 3] >>> (boff & 7) & 1;
            boff++;
            wrd += bit;
            if (is1D) {
              if (U._lens[clr][wrd] != null) {
                var dl = U._lens[clr][wrd];
                wrd = "";
                len += dl;
                if (dl < 64) {
                  U._addNtimes(line, len, clr);
                  clr = 1 - clr;
                  len = 0;
                }
              }
            } else {
              if (mode == "H") {
                if (U._lens[clr][wrd] != null) {
                  var dl = U._lens[clr][wrd];
                  wrd = "";
                  len += dl;
                  if (dl < 64) {
                    U._addNtimes(line, len, clr);
                    a0 += len;
                    clr = 1 - clr;
                    len = 0;
                    toRead--;
                    if (toRead == 0)
                      mode = "";
                  }
                }
              } else {
                if (wrd == "0001") {
                  wrd = "";
                  U._addNtimes(line, b2 - a0, clr);
                  a0 = b2;
                }
                if (wrd == "001") {
                  wrd = "";
                  mode = "H";
                  toRead = 2;
                }
                if (U._dmap[wrd] != null) {
                  a1 = b1 + U._dmap[wrd];
                  U._addNtimes(line, a1 - a0, clr);
                  a0 = a1;
                  wrd = "";
                  clr = 1 - clr;
                }
              }
            }
            if (wrd.endsWith("000000000001")) {
              if (y >= 0)
                U._writeBits(line, tgt, toff * 8 + y * bipl);
              if (twoDim) {
                if (fo == 1)
                  is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
                if (fo == 2)
                  is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;
                boff++;
              }
              wrd = "";
              clr = 0;
              y++;
              a0 = 0;
              pline = U._makeDiff(line);
              line = [];
            }
          }
          if (line.length == w)
            U._writeBits(line, tgt, toff * 8 + y * bipl);
        };
        UTIF2.decode._addNtimes = function(arr, n, val) {
          for (var i2 = 0; i2 < n; i2++)
            arr.push(val);
        };
        UTIF2.decode._writeBits = function(bits, tgt, boff) {
          for (var i2 = 0; i2 < bits.length; i2++)
            tgt[boff + i2 >>> 3] |= bits[i2] << 7 - (boff + i2 & 7);
        };
        UTIF2.decode._decodeLZW = UTIF2.decode._decodeLZW = function() {
          var e, U, Z, u, K = 0, V = 0, g = 0, N = 0, O = function() {
            var S = e >>> 3, A = U[S] << 16 | U[S + 1] << 8 | U[S + 2], j = A >>> 24 - (e & 7) - V & (1 << V) - 1;
            e += V;
            return j;
          }, h = new Uint32Array(4096 * 4), w = 0, m = function(S) {
            if (S == w)
              return;
            w = S;
            g = 1 << S;
            N = g + 1;
            for (var A = 0; A < N + 1; A++) {
              h[4 * A] = h[4 * A + 3] = A;
              h[4 * A + 1] = 65535;
              h[4 * A + 2] = 1;
            }
          }, i2 = function(S) {
            V = S + 1;
            K = N + 1;
          }, D = function(S) {
            var A = S << 2, j = h[A + 2], a = u + j - 1;
            while (A != 65535) {
              Z[a--] = h[A];
              A = h[A + 1];
            }
            u += j;
          }, L = function(S, A) {
            var j = K << 2, a = S << 2;
            h[j] = h[(A << 2) + 3];
            h[j + 1] = a;
            h[j + 2] = h[a + 2] + 1;
            h[j + 3] = h[a + 3];
            K++;
            if (K + 1 == 1 << V && V != 12)
              V++;
          }, T = function(S, A, j, a, n, q) {
            e = A << 3;
            U = S;
            Z = a;
            u = n;
            var B = A + j << 3, _ = 0, t = 0;
            m(q);
            i2(q);
            while (e < B && (_ = O()) != N) {
              if (_ == g) {
                i2(q);
                _ = O();
                if (_ == N)
                  break;
                D(_);
              } else {
                if (_ < K) {
                  D(_);
                  L(t, _);
                } else {
                  L(t, t);
                  D(K - 1);
                }
              }
              t = _;
            }
            return u;
          };
          return T;
        }();
        UTIF2.tags = {};
        UTIF2._types = function() {
          var main = new Array(250);
          main.fill(0);
          main = main.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
          var rest = { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 };
          return {
            basic: {
              main,
              rest
            },
            gps: {
              main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9],
              rest: { 18: 2, 29: 2 }
            }
          };
        }();
        UTIF2._readIFD = function(bin, data, offset, ifds, depth, prm) {
          var cnt = bin.readUshort(data, offset);
          offset += 2;
          var ifd = {};
          if (prm.debug)
            log("   ".repeat(depth), ifds.length - 1, ">>>----------------");
          for (var i2 = 0; i2 < cnt; i2++) {
            var tag = bin.readUshort(data, offset);
            offset += 2;
            var type = bin.readUshort(data, offset);
            offset += 2;
            var num = bin.readUint(data, offset);
            offset += 4;
            var voff = bin.readUint(data, offset);
            offset += 4;
            var arr = [];
            if (type == 1 || type == 7) {
              var no = num < 5 ? offset - 4 : voff;
              if (no + num > data.buffer.byteLength)
                num = data.buffer.byteLength - no;
              arr = new Uint8Array(data.buffer, no, num);
            }
            if (type == 2) {
              var o0 = num < 5 ? offset - 4 : voff, c = data[o0], len = Math.max(0, Math.min(num - 1, data.length - o0));
              if (c < 128 || len == 0)
                arr.push(bin.readASCII(data, o0, len));
              else
                arr = new Uint8Array(data.buffer, o0, len);
            }
            if (type == 3) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
            }
            if (type == 4 || type == 13) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
            }
            if (type == 5 || type == 10) {
              var ri = type == 5 ? bin.readUint : bin.readInt;
              for (var j = 0; j < num; j++)
                arr.push([ri(data, voff + j * 8), ri(data, voff + j * 8 + 4)]);
            }
            if (type == 8) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
            }
            if (type == 9) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
            }
            if (type == 11) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readFloat(data, voff + j * 4));
            }
            if (type == 12) {
              for (var j = 0; j < num; j++)
                arr.push(bin.readDouble(data, voff + j * 8));
            }
            if (num != 0 && arr.length == 0) {
              log(tag, "unknown TIFF tag type: ", type, "num:", num);
              if (i2 == 0)
                return;
              continue;
            }
            if (prm.debug)
              log("   ".repeat(depth), tag, type, UTIF2.tags[tag], arr);
            ifd["t" + tag] = arr;
            if (tag == 330 && ifd["t272"] && ifd["t272"][0] == "DSLR-A100") {
            } else if (tag == 330 || tag == 34665 || tag == 34853 || tag == 50740 && bin.readUshort(data, bin.readUint(arr, 0)) < 300 || tag == 61440) {
              var oarr = tag == 50740 ? [bin.readUint(arr, 0)] : arr;
              var subfd = [];
              for (var j = 0; j < oarr.length; j++)
                UTIF2._readIFD(bin, data, oarr[j], subfd, depth + 1, prm);
              if (tag == 330)
                ifd.subIFD = subfd;
              if (tag == 34665)
                ifd.exifIFD = subfd[0];
              if (tag == 34853)
                ifd.gpsiIFD = subfd[0];
              if (tag == 50740)
                ifd.dngPrvt = subfd[0];
              if (tag == 61440)
                ifd.fujiIFD = subfd[0];
            }
            if (tag == 37500 && prm.parseMN) {
              var mn = arr;
              if (bin.readASCII(mn, 0, 5) == "Nikon")
                ifd.makerNote = UTIF2["decode"](mn.slice(10).buffer)[0];
              else if (bin.readASCII(mn, 0, 5) == "OLYMP" || bin.readASCII(mn, 0, 9) == "OM SYSTEM") {
                var inds = [8208, 8224, 8240, 8256, 8272];
                var subsub = [];
                UTIF2._readIFD(bin, mn, mn[1] == 77 ? 16 : mn[5] == 85 ? 12 : 8, subsub, depth + 1, prm);
                var obj = ifd.makerNote = subsub.pop();
                for (var j = 0; j < inds.length; j++) {
                  var k = "t" + inds[j];
                  if (obj[k] == null)
                    continue;
                  UTIF2._readIFD(bin, mn, obj[k][0], subsub, depth + 1, prm);
                  obj[k] = subsub.pop();
                }
                if (obj["t12288"]) {
                  UTIF2._readIFD(bin, obj["t12288"], 0, subsub, depth + 1, prm);
                  obj["t12288"] = subsub.pop();
                }
              } else if (bin.readUshort(data, voff) < 300 && bin.readUshort(data, voff + 4) <= 12) {
                var subsub = [];
                UTIF2._readIFD(bin, data, voff, subsub, depth + 1, prm);
                ifd.makerNote = subsub[0];
              }
            }
          }
          ifds.push(ifd);
          if (prm.debug)
            log("   ".repeat(depth), "<<<---------------");
          return offset;
        };
        UTIF2._writeIFD = function(bin, types, data, offset, ifd) {
          var keys = Object.keys(ifd), knum = keys.length;
          if (ifd["exifIFD"])
            knum--;
          if (ifd["gpsiIFD"])
            knum--;
          bin.writeUshort(data, offset, knum);
          offset += 2;
          var eoff = offset + knum * 12 + 4;
          for (var ki = 0; ki < keys.length; ki++) {
            var key = keys[ki];
            if (key == "t34665" || key == "t34853")
              continue;
            if (key == "exifIFD")
              key = "t34665";
            if (key == "gpsiIFD")
              key = "t34853";
            var tag = parseInt(key.slice(1)), type = types.main[tag];
            if (type == null)
              type = types.rest[tag];
            if (type == null || type == 0)
              throw new Error("unknown type of tag: " + tag);
            var val = ifd[key];
            if (tag == 34665) {
              var outp = UTIF2._writeIFD(bin, types, data, eoff, ifd["exifIFD"]);
              val = [eoff];
              eoff = outp[1];
            }
            if (tag == 34853) {
              var outp = UTIF2._writeIFD(bin, UTIF2._types.gps, data, eoff, ifd["gpsiIFD"]);
              val = [eoff];
              eoff = outp[1];
            }
            if (type == 2)
              val = val[0] + "\0";
            var num = val.length;
            bin.writeUshort(data, offset, tag);
            offset += 2;
            bin.writeUshort(data, offset, type);
            offset += 2;
            bin.writeUint(data, offset, num);
            offset += 4;
            var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num;
            var toff = offset;
            if (dlen > 4) {
              bin.writeUint(data, offset, eoff);
              toff = eoff;
            }
            if (type == 1 || type == 7) {
              for (var i2 = 0; i2 < num; i2++)
                data[toff + i2] = val[i2];
            } else if (type == 2) {
              bin.writeASCII(data, toff, val);
            } else if (type == 3) {
              for (var i2 = 0; i2 < num; i2++)
                bin.writeUshort(data, toff + 2 * i2, val[i2]);
            } else if (type == 4) {
              for (var i2 = 0; i2 < num; i2++)
                bin.writeUint(data, toff + 4 * i2, val[i2]);
            } else if (type == 5 || type == 10) {
              var wr = type == 5 ? bin.writeUint : bin.writeInt;
              for (var i2 = 0; i2 < num; i2++) {
                var v = val[i2], nu = v[0], de = v[1];
                if (nu == null)
                  throw "e";
                wr(data, toff + 8 * i2, nu);
                wr(data, toff + 8 * i2 + 4, de);
              }
            } else if (type == 9) {
              for (var i2 = 0; i2 < num; i2++)
                bin.writeInt(data, toff + 4 * i2, val[i2]);
            } else if (type == 12) {
              for (var i2 = 0; i2 < num; i2++)
                bin.writeDouble(data, toff + 8 * i2, val[i2]);
            } else
              throw type;
            if (dlen > 4) {
              dlen += dlen & 1;
              eoff += dlen;
            }
            offset += 4;
          }
          return [offset, eoff];
        };
        UTIF2.toRGBA8 = function(out, scl) {
          function gamma(x2) {
            return x2 < 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055;
          }
          var w = out.width, h = out.height, area = w * h, qarea = area * 4, data = out.data;
          var img = new Uint8Array(area * 4);
          var intp = out["t262"] ? out["t262"][0] : 2, bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1;
          if (out["t262"] == null && bps == 1)
            intp = 0;
          var smpls = out["t277"] ? out["t277"][0] : out["t258"] ? out["t258"].length : [1, 1, 3, 1, 1, 4, 3][intp];
          var sfmt = out["t339"] ? out["t339"][0] : null;
          if (intp == 1 && bps == 32 && sfmt != 3)
            throw "e";
          var bpl = Math.ceil(smpls * bps * w / 8);
          if (false) {
          } else if (intp == 0) {
            scl = 1 / 256;
            for (var y = 0; y < h; y++) {
              var off = y * bpl, io = y * w;
              if (bps == 1)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, px2 = data[off + (i2 >> 3)] >> 7 - (i2 & 7) & 1;
                  img[qi] = img[qi + 1] = img[qi + 2] = (1 - px2) * 255;
                  img[qi + 3] = 255;
                }
              if (bps == 4)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, px2 = data[off + (i2 >> 1)] >> 4 - 4 * (i2 & 1) & 15;
                  img[qi] = img[qi + 1] = img[qi + 2] = (15 - px2) * 17;
                  img[qi + 3] = 255;
                }
              if (bps == 8)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, px2 = data[off + i2];
                  img[qi] = img[qi + 1] = img[qi + 2] = 255 - px2;
                  img[qi + 3] = 255;
                }
              if (bps == 16)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, o = off + 2 * i2, px2 = data[o + 1] << 8 | data[o];
                  img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, 255 - ~~(px2 * scl));
                  img[qi + 3] = 255;
                }
            }
          } else if (intp == 1) {
            if (scl == null)
              scl = 1 / 256;
            var f32 = (data.length & 3) == 0 ? new Float32Array(data.buffer) : null;
            for (var y = 0; y < h; y++) {
              var off = y * bpl, io = y * w;
              if (bps == 1)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, px2 = data[off + (i2 >> 3)] >> 7 - (i2 & 7) & 1;
                  img[qi] = img[qi + 1] = img[qi + 2] = px2 * 255;
                  img[qi + 3] = 255;
                }
              if (bps == 2)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, px2 = data[off + (i2 >> 2)] >> 6 - 2 * (i2 & 3) & 3;
                  img[qi] = img[qi + 1] = img[qi + 2] = px2 * 85;
                  img[qi + 3] = 255;
                }
              if (bps == 8)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, px2 = data[off + i2 * smpls];
                  img[qi] = img[qi + 1] = img[qi + 2] = px2;
                  img[qi + 3] = 255;
                }
              if (bps == 16)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, o = off + 2 * i2, px2 = data[o + 1] << 8 | data[o];
                  img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, ~~(px2 * scl));
                  img[qi + 3] = 255;
                }
              if (bps == 32)
                for (var i2 = 0; i2 < w; i2++) {
                  var qi = io + i2 << 2, o = (off >>> 2) + i2, px2 = f32[o];
                  img[qi] = img[qi + 1] = img[qi + 2] = ~~(0.5 + 255 * px2);
                  img[qi + 3] = 255;
                }
            }
          } else if (intp == 2) {
            if (bps == 8) {
              if (smpls == 1)
                for (var i2 = 0; i2 < area; i2++) {
                  img[4 * i2] = img[4 * i2 + 1] = img[4 * i2 + 2] = data[i2];
                  img[4 * i2 + 3] = 255;
                }
              if (smpls == 3)
                for (var i2 = 0; i2 < area; i2++) {
                  var qi = i2 << 2, ti = i2 * 3;
                  img[qi] = data[ti];
                  img[qi + 1] = data[ti + 1];
                  img[qi + 2] = data[ti + 2];
                  img[qi + 3] = 255;
                }
              if (smpls >= 4)
                for (var i2 = 0; i2 < area; i2++) {
                  var qi = i2 << 2, ti = i2 * smpls;
                  img[qi] = data[ti];
                  img[qi + 1] = data[ti + 1];
                  img[qi + 2] = data[ti + 2];
                  img[qi + 3] = data[ti + 3];
                }
            } else if (bps == 16) {
              if (smpls == 4)
                for (var i2 = 0; i2 < area; i2++) {
                  var qi = i2 << 2, ti = i2 * 8 + 1;
                  img[qi] = data[ti];
                  img[qi + 1] = data[ti + 2];
                  img[qi + 2] = data[ti + 4];
                  img[qi + 3] = data[ti + 6];
                }
              if (smpls == 3)
                for (var i2 = 0; i2 < area; i2++) {
                  var qi = i2 << 2, ti = i2 * 6 + 1;
                  img[qi] = data[ti];
                  img[qi + 1] = data[ti + 2];
                  img[qi + 2] = data[ti + 4];
                  img[qi + 3] = 255;
                }
            } else if (bps == 32) {
              var ndt = new Float32Array(data.buffer);
              var min2 = 0;
              for (var i2 = 0; i2 < ndt.length; i2++)
                min2 = Math.min(min2, ndt[i2]);
              if (min2 < 0)
                for (var i2 = 0; i2 < data.length; i2 += 4) {
                  var t = data[i2];
                  data[i2] = data[i2 + 3];
                  data[i2 + 3] = t;
                  t = data[i2 + 1];
                  data[i2 + 1] = data[i2 + 2];
                  data[i2 + 2] = t;
                }
              var pmap = [];
              for (var i2 = 0; i2 < 65536; i2++)
                pmap.push(gamma(i2 / 65535));
              for (var i2 = 0; i2 < ndt.length; i2++) {
                var cv = Math.max(0, Math.min(1, ndt[i2]));
                ndt[i2] = pmap[~~(0.5 + cv * 65535)];
              }
              if (smpls == 3)
                for (var i2 = 0; i2 < area; i2++) {
                  var qi = i2 << 2, ti = i2 * 3;
                  img[qi] = ~~(0.5 + ndt[ti] * 255);
                  img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
                  img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
                  img[qi + 3] = 255;
                }
              else if (smpls == 4)
                for (var i2 = 0; i2 < area; i2++) {
                  var qi = i2 << 2, ti = i2 * 4;
                  img[qi] = ~~(0.5 + ndt[ti] * 255);
                  img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);
                  img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);
                  img[qi + 3] = ~~(0.5 + ndt[ti + 3] * 255);
                }
              else
                throw smpls;
            } else
              throw bps;
          } else if (intp == 3) {
            var map = out["t320"];
            var cn = 1 << bps;
            var nexta = bps == 8 && smpls > 1 && out["t338"] && out["t338"][0] != 0;
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var i2 = y * w + x;
                var qi = i2 << 2, mi = 0;
                var dof = y * bpl;
                if (false) {
                } else if (bps == 1)
                  mi = data[dof + (x >>> 3)] >>> 7 - (x & 7) & 1;
                else if (bps == 2)
                  mi = data[dof + (x >>> 2)] >>> 6 - 2 * (x & 3) & 3;
                else if (bps == 4)
                  mi = data[dof + (x >>> 1)] >>> 4 - 4 * (x & 1) & 15;
                else if (bps == 8)
                  mi = data[dof + x * smpls];
                else
                  throw bps;
                img[qi] = map[mi] >> 8;
                img[qi + 1] = map[cn + mi] >> 8;
                img[qi + 2] = map[cn + cn + mi] >> 8;
                img[qi + 3] = nexta ? data[dof + x * smpls + 1] : 255;
              }
          } else if (intp == 5) {
            var gotAlpha = smpls > 4 ? 1 : 0;
            for (var i2 = 0; i2 < area; i2++) {
              var qi = i2 << 2, si = i2 * smpls;
              if (window.UDOC) {
                var C = data[si], M = data[si + 1], Y = data[si + 2], K = data[si + 3];
                var c = UDOC.C.cmykToRgb([C * (1 / 255), M * (1 / 255), Y * (1 / 255), K * (1 / 255)]);
                img[qi] = ~~(0.5 + 255 * c[0]);
                img[qi + 1] = ~~(0.5 + 255 * c[1]);
                img[qi + 2] = ~~(0.5 + 255 * c[2]);
              } else {
                var C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
                img[qi] = ~~(C * K + 0.5);
                img[qi + 1] = ~~(M * K + 0.5);
                img[qi + 2] = ~~(Y * K + 0.5);
              }
              img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
            }
          } else if (intp == 6 && out["t278"]) {
            var rps = out["t278"][0];
            for (var y = 0; y < h; y += rps) {
              var i2 = y * w, len = rps * w;
              for (var j = 0; j < len; j++) {
                var qi = 4 * (i2 + j), si = 3 * i2 + 4 * (j >>> 1);
                var Y = data[si + (j & 1)], Cb = data[si + 2] - 128, Cr = data[si + 3] - 128;
                var r = Y + ((Cr >> 2) + (Cr >> 3) + (Cr >> 5));
                var g = Y - ((Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ((Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5));
                var b = Y + (Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6));
                img[qi] = Math.max(0, Math.min(255, r));
                img[qi + 1] = Math.max(0, Math.min(255, g));
                img[qi + 2] = Math.max(0, Math.min(255, b));
                img[qi + 3] = 255;
              }
            }
          } else if (intp == 32845) {
            for (var y = 0; y < h; y++)
              for (var x = 0; x < w; x++) {
                var si = (y * w + x) * 6, qi = (y * w + x) * 4;
                var L = data[si + 1] << 8 | data[si];
                var L = Math.pow(2, (L + 0.5) / 256 - 64);
                var u = (data[si + 3] + 0.5) / 410;
                var v = (data[si + 5] + 0.5) / 410;
                var sX = 9 * u / (6 * u - 16 * v + 12);
                var sY = 4 * v / (6 * u - 16 * v + 12);
                var bY = L;
                var X = sX * bY / sY, Y = bY, Z = (1 - sX - sY) * bY / sY;
                var r = 2.69 * X - 1.276 * Y - 0.414 * Z;
                var g = -1.022 * X + 1.978 * Y + 0.044 * Z;
                var b = 0.061 * X - 0.224 * Y + 1.163 * Z;
                img[qi] = gamma(Math.min(r, 1)) * 255;
                img[qi + 1] = gamma(Math.min(g, 1)) * 255;
                img[qi + 2] = gamma(Math.min(b, 1)) * 255;
                img[qi + 3] = 255;
              }
          } else
            log("Unknown Photometric interpretation: " + intp);
          return img;
        };
        UTIF2.replaceIMG = function(imgs) {
          if (imgs == null)
            imgs = document.getElementsByTagName("img");
          var sufs = ["tif", "tiff", "dng", "cr2", "nef"];
          for (var i2 = 0; i2 < imgs.length; i2++) {
            var img = imgs[i2], src = img.getAttribute("src");
            if (src == null)
              continue;
            var suff = src.split(".").pop().toLowerCase();
            if (sufs.indexOf(suff) == -1)
              continue;
            var xhr = new XMLHttpRequest();
            UTIF2._xhrs.push(xhr);
            UTIF2._imgs.push(img);
            xhr.open("GET", src);
            xhr.responseType = "arraybuffer";
            xhr.onload = UTIF2._imgLoaded;
            xhr.send();
          }
        };
        UTIF2._xhrs = [];
        UTIF2._imgs = [];
        UTIF2._imgLoaded = function(e) {
          var ind = UTIF2._xhrs.indexOf(e.target), img = UTIF2._imgs[ind];
          UTIF2._xhrs.splice(ind, 1);
          UTIF2._imgs.splice(ind, 1);
          img.setAttribute("src", UTIF2.bufferToURI(e.target.response));
        };
        UTIF2.bufferToURI = function(buff) {
          var ifds = UTIF2.decode(buff);
          var vsns = ifds, ma = 0, page = vsns[0];
          if (ifds[0].subIFD)
            vsns = vsns.concat(ifds[0].subIFD);
          for (var i2 = 0; i2 < vsns.length; i2++) {
            var img = vsns[i2];
            if (img["t258"] == null || img["t258"].length < 3)
              continue;
            var ar = img["t256"] * img["t257"];
            if (ar > ma) {
              ma = ar;
              page = img;
            }
          }
          UTIF2.decodeImage(buff, page, ifds);
          var rgba = UTIF2.toRGBA8(page), w = page.width, h = page.height;
          var cnv = document.createElement("canvas");
          cnv.width = w;
          cnv.height = h;
          var ctx = cnv.getContext("2d");
          var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer), w, h);
          ctx.putImageData(imgd, 0, 0);
          return cnv.toDataURL();
        };
        UTIF2._binBE = {
          nextZero: function(data, o) {
            while (data[o] != 0)
              o++;
            return o;
          },
          readUshort: function(buff, p) {
            return buff[p] << 8 | buff[p + 1];
          },
          readShort: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 1];
            a[1] = buff[p + 0];
            return UTIF2._binBE.i16[0];
          },
          readInt: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 3];
            a[1] = buff[p + 2];
            a[2] = buff[p + 1];
            a[3] = buff[p + 0];
            return UTIF2._binBE.i32[0];
          },
          readUint: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 3];
            a[1] = buff[p + 2];
            a[2] = buff[p + 1];
            a[3] = buff[p + 0];
            return UTIF2._binBE.ui32[0];
          },
          readASCII: function(buff, p, l) {
            var s = "";
            for (var i2 = 0; i2 < l; i2++)
              s += String.fromCharCode(buff[p + i2]);
            return s;
          },
          readFloat: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i2 = 0; i2 < 4; i2++)
              a[i2] = buff[p + 3 - i2];
            return UTIF2._binBE.fl32[0];
          },
          readDouble: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i2 = 0; i2 < 8; i2++)
              a[i2] = buff[p + 7 - i2];
            return UTIF2._binBE.fl64[0];
          },
          writeUshort: function(buff, p, n) {
            buff[p] = n >> 8 & 255;
            buff[p + 1] = n & 255;
          },
          writeInt: function(buff, p, n) {
            var a = UTIF2._binBE.ui8;
            UTIF2._binBE.i32[0] = n;
            buff[p + 3] = a[0];
            buff[p + 2] = a[1];
            buff[p + 1] = a[2];
            buff[p + 0] = a[3];
          },
          writeUint: function(buff, p, n) {
            buff[p] = n >> 24 & 255;
            buff[p + 1] = n >> 16 & 255;
            buff[p + 2] = n >> 8 & 255;
            buff[p + 3] = n >> 0 & 255;
          },
          writeASCII: function(buff, p, s) {
            for (var i2 = 0; i2 < s.length; i2++)
              buff[p + i2] = s.charCodeAt(i2);
          },
          writeDouble: function(buff, p, n) {
            UTIF2._binBE.fl64[0] = n;
            for (var i2 = 0; i2 < 8; i2++)
              buff[p + i2] = UTIF2._binBE.ui8[7 - i2];
          }
        };
        UTIF2._binBE.ui8 = new Uint8Array(8);
        UTIF2._binBE.i16 = new Int16Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.i32 = new Int32Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.ui32 = new Uint32Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.fl32 = new Float32Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binBE.fl64 = new Float64Array(UTIF2._binBE.ui8.buffer);
        UTIF2._binLE = {
          nextZero: UTIF2._binBE.nextZero,
          readUshort: function(buff, p) {
            return buff[p + 1] << 8 | buff[p];
          },
          readShort: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 0];
            a[1] = buff[p + 1];
            return UTIF2._binBE.i16[0];
          },
          readInt: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 0];
            a[1] = buff[p + 1];
            a[2] = buff[p + 2];
            a[3] = buff[p + 3];
            return UTIF2._binBE.i32[0];
          },
          readUint: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            a[0] = buff[p + 0];
            a[1] = buff[p + 1];
            a[2] = buff[p + 2];
            a[3] = buff[p + 3];
            return UTIF2._binBE.ui32[0];
          },
          readASCII: UTIF2._binBE.readASCII,
          readFloat: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i2 = 0; i2 < 4; i2++)
              a[i2] = buff[p + i2];
            return UTIF2._binBE.fl32[0];
          },
          readDouble: function(buff, p) {
            var a = UTIF2._binBE.ui8;
            for (var i2 = 0; i2 < 8; i2++)
              a[i2] = buff[p + i2];
            return UTIF2._binBE.fl64[0];
          },
          writeUshort: function(buff, p, n) {
            buff[p] = n & 255;
            buff[p + 1] = n >> 8 & 255;
          },
          writeInt: function(buff, p, n) {
            var a = UTIF2._binBE.ui8;
            UTIF2._binBE.i32[0] = n;
            buff[p + 0] = a[0];
            buff[p + 1] = a[1];
            buff[p + 2] = a[2];
            buff[p + 3] = a[3];
          },
          writeUint: function(buff, p, n) {
            buff[p] = n >>> 0 & 255;
            buff[p + 1] = n >>> 8 & 255;
            buff[p + 2] = n >>> 16 & 255;
            buff[p + 3] = n >>> 24 & 255;
          },
          writeASCII: UTIF2._binBE.writeASCII
        };
        UTIF2._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
          var xlim = Math.min(tw, w - xoff);
          var ylim = Math.min(th, h - yoff);
          for (var y = 0; y < ylim; y++) {
            var tof = (yoff + y) * w + xoff;
            var sof = y * tw;
            for (var x = 0; x < xlim; x++)
              b[tof + x] = tb[sof + x];
          }
        };
        UTIF2.LosslessJpegDecode = function() {
          var b, O;
          function l() {
            return b[O++];
          }
          function m() {
            return b[O++] << 8 | b[O++];
          }
          function a0(h) {
            var V = l(), I = [0, 0, 0, 255], f = [], G = 8;
            for (var w = 0; w < 16; w++)
              f[w] = l();
            for (var w = 0; w < 16; w++) {
              for (var x = 0; x < f[w]; x++) {
                var T = z(I, 0, w + 1, 1);
                I[T + 3] = l();
              }
            }
            var E = new Uint8Array(1 << G);
            h[V] = [new Uint8Array(I), E];
            for (var w = 0; w < 1 << G; w++) {
              var s = G, _ = w, Y = 0, F = 0;
              while (I[Y + 3] == 255 && s != 0) {
                F = _ >> --s & 1;
                Y = I[Y + F];
              }
              E[w] = Y;
            }
          }
          function z(h, V, I, f) {
            if (h[V + 3] != 255)
              return 0;
            if (I == 0)
              return V;
            for (var w = 0; w < 2; w++) {
              if (h[V + w] == 0) {
                h[V + w] = h.length;
                h.push(0, 0, f, 255);
              }
              var x = z(h, h[V + w], I - 1, f + 1);
              if (x != 0)
                return x;
            }
            return 0;
          }
          function i2(h) {
            var V = h.b, I = h.f;
            while (V < 25 && h.a < h.d) {
              var f = h.data[h.a++];
              if (f == 255 && !h.c)
                h.a++;
              I = I << 8 | f;
              V += 8;
            }
            if (V < 0)
              throw "e";
            h.b = V;
            h.f = I;
          }
          function H(h, V) {
            if (V.b < h)
              i2(V);
            return V.f >> (V.b -= h) & 65535 >> 16 - h;
          }
          function g(h, V) {
            var I = h[0], f = 0, w = 255, x = 0;
            if (V.b < 16)
              i2(V);
            var T = V.f >> V.b - 8 & 255;
            f = h[1][T];
            w = I[f + 3];
            V.b -= I[f + 2];
            while (w == 255) {
              x = V.f >> --V.b & 1;
              f = I[f + x];
              w = I[f + 3];
            }
            return w;
          }
          function P(h, V) {
            if (h < 32768 >> 16 - V)
              h += -(1 << V) + 1;
            return h;
          }
          function a2(h, V) {
            var I = g(h, V);
            if (I == 0)
              return 0;
            if (I == 16)
              return -32768;
            var f = H(I, V);
            return P(f, I);
          }
          function X(h, V, I, f, w, x) {
            var T = 0;
            for (var G = 0; G < x; G++) {
              var s = G * V;
              for (var _ = 0; _ < V; _ += w) {
                T++;
                for (var Y = 0; Y < w; Y++)
                  h[s + _ + Y] = a2(f[Y], I);
              }
              if (I.e != 0 && T % I.e == 0 && G != 0) {
                var F = I.a, t = I.data;
                while (t[F] != 255 || !(208 <= t[F + 1] && t[F + 1] <= 215))
                  F--;
                I.a = F + 2;
                I.f = 0;
                I.b = 0;
              }
            }
          }
          function o(h, V) {
            return P(H(h, V), h);
          }
          function a1(h, V, I, f, w) {
            var x = b.length - O;
            for (var T = 0; T < x; T += 4) {
              var G = b[O + T];
              b[O + T] = b[O + T + 3];
              b[O + T + 3] = G;
              var G = b[O + T + 1];
              b[O + T + 1] = b[O + T + 2];
              b[O + T + 2] = G;
            }
            for (var E = 0; E < w; E++) {
              var s = 32768, _ = 32768;
              for (var Y = 0; Y < V; Y += 2) {
                var F = g(f, I), t = g(f, I);
                if (F != 0)
                  s += o(F, I);
                if (t != 0)
                  _ += o(t, I);
                h[E * V + Y] = s & 65535;
                h[E * V + Y + 1] = _ & 65535;
              }
            }
          }
          function C(h) {
            b = h;
            O = 0;
            if (m() != 65496)
              throw "e";
            var V = [], I = 0, f = 0, w = 0, x = [], T = [], G = [], E = 0, s = 0, _ = 0;
            while (true) {
              var Y = m();
              if (Y == 65535) {
                O--;
                continue;
              }
              var F = m();
              if (Y == 65475) {
                f = l();
                s = m();
                _ = m();
                E = l();
                for (var t = 0; t < E; t++) {
                  var a = l(), J = l(), r = l();
                  if (r != 0)
                    throw "e";
                  V[a] = [t, J >> 4, J & 15];
                }
              } else if (Y == 65476) {
                var a3 = O + F - 2;
                while (O < a3)
                  a0(T);
              } else if (Y == 65498) {
                O++;
                for (var t = 0; t < E; t++) {
                  var a5 = l(), v = V[a5];
                  G[v[0]] = T[l() >>> 4];
                  x[v[0]] = v.slice(1);
                }
                I = l();
                O += 2;
                break;
              } else if (Y == 65501) {
                w = m();
              } else {
                O += F - 2;
              }
            }
            var a4 = f > 8 ? Uint16Array : Uint8Array, $2 = new a4(s * _ * E), M = { b: 0, f: 0, c: I == 8, a: O, data: b, d: b.length, e: w };
            if (M.c)
              a1($2, _ * E, M, G[0], s);
            else {
              var c = [], p = 0, D = 0;
              for (var t = 0; t < E; t++) {
                var N = x[t], S = N[0], K = N[1];
                if (S > p)
                  p = S;
                if (K > D)
                  D = K;
                c.push(S * K);
              }
              if (p != 1 || D != 1) {
                if (E != 3 || c[1] != 1 || c[2] != 1)
                  throw "e";
                if (p != 2 || D != 1 && D != 2)
                  throw "e";
                var u = [], Z = 0;
                for (var t = 0; t < E; t++) {
                  for (var R = 0; R < c[t]; R++)
                    u.push(G[t]);
                  Z += c[t];
                }
                var B = _ / p, e = s / D, d = B * e;
                X($2, B * Z, M, u, Z, e);
                j($2, I, B, e, Z - 2, Z, Z, f);
                var A = new Uint16Array(d * c[0]);
                if (p == 2 && D == 2) {
                  for (var t = 0; t < d; t++) {
                    A[4 * t] = $2[6 * t];
                    A[4 * t + 1] = $2[6 * t + 1];
                    A[4 * t + 2] = $2[6 * t + 2];
                    A[4 * t + 3] = $2[6 * t + 3];
                  }
                  j(A, I, B * 4, e, 0, 1, 1, f);
                  for (var t = 0; t < d; t++) {
                    $2[6 * t] = A[4 * t];
                    $2[6 * t + 1] = A[4 * t + 1];
                    $2[6 * t + 2] = A[4 * t + 2];
                    $2[6 * t + 3] = A[4 * t + 3];
                  }
                }
                if (p == 2 && D == 1) {
                  for (var t = 0; t < d; t++) {
                    A[2 * t] = $2[4 * t];
                    A[2 * t + 1] = $2[4 * t + 1];
                  }
                  j(A, I, B * 2, e, 0, 1, 1, f);
                  for (var t = 0; t < d; t++) {
                    $2[4 * t] = A[2 * t];
                    $2[4 * t + 1] = A[2 * t + 1];
                  }
                }
                var n = $2.slice(0);
                for (var K = 0; K < s; K++) {
                  if (D == 2)
                    for (var S = 0; S < _; S++) {
                      var q = (K * _ + S) * E, k = ((K >>> 1) * B + (S >>> 1)) * Z, y = (K & 1) * 2 + (S & 1);
                      $2[q] = n[k + y];
                      $2[q + 1] = n[k + 4];
                      $2[q + 2] = n[k + 5];
                    }
                  else
                    for (var S = 0; S < _; S++) {
                      var q = (K * _ + S) * E, k = (K * B + (S >>> 1)) * Z, y = S & 1;
                      $2[q] = n[k + y];
                      $2[q + 1] = n[k + 2];
                      $2[q + 2] = n[k + 3];
                    }
                }
              } else {
                X($2, _ * E, M, G, E, s);
                if (w == 0)
                  j($2, I, _, s, 0, E, E, f);
                else {
                  var U = Math.floor(w / _);
                  for (var K = 0; K < s; K += U) {
                    var L = $2.slice(K * _ * E, (K + U) * _ * E);
                    j(L, I, _, U, 0, E, E, f);
                    $2.set(L, K * _ * E);
                  }
                }
              }
            }
            return $2;
          }
          function j(h, V, I, f, w, x, G, E) {
            var s = I * G;
            for (var _ = w; _ < x; _++)
              h[_] += 1 << E - 1;
            for (var Y = G; Y < s; Y += G)
              for (var _ = w; _ < x; _++)
                h[Y + _] += h[Y + _ - G];
            for (var F = 1; F < f; F++) {
              var t = F * s;
              for (var _ = w; _ < x; _++)
                h[t + _] += h[t + _ - s];
              for (var Y = G; Y < s; Y += G) {
                for (var _ = w; _ < x; _++) {
                  var a = t + Y + _, J = a - s, r = h[a - G], Q = 0;
                  if (V == 0)
                    Q = 0;
                  else if (V == 1)
                    Q = r;
                  else if (V == 2)
                    Q = h[J];
                  else if (V == 3)
                    Q = h[J - G];
                  else if (V == 4)
                    Q = r + (h[J] - h[J - G]);
                  else if (V == 5)
                    Q = r + (h[J] - h[J - G] >>> 1);
                  else if (V == 6)
                    Q = h[J] + (r - h[J - G] >>> 1);
                  else if (V == 7)
                    Q = r + h[J] >>> 1;
                  else
                    throw V;
                  h[a] += Q;
                }
              }
            }
          }
          return C;
        }();
        (function() {
          var G = 0, F = 1, i2 = 2, b = 3, J = 4, N = 5, E = 6, s = 7, c = 8, T = 9, a3 = 10, f = 11, q = 12, M = 13, m = 14, x = 15, L = 16, $2 = 17, p = 18;
          function a5(t) {
            var Z = UTIF2._binBE.readUshort, u = { b: Z(t, 0), i: t[2], C: t[3], u: t[4], q: Z(t, 5), k: Z(t, 7), e: Z(t, 9), l: Z(t, 11), s: t[13], d: Z(t, 14) };
            if (u.b != 18771 || u.i > 1 || u.q < 6 || u.q % 6 || u.e < 768 || u.e % 24 || u.l != 768 || u.k < u.l || u.k % u.l || u.k - u.e >= u.l || u.s > 16 || u.s != u.k / u.l || u.s != Math.ceil(u.e / u.l) || u.d != u.q / 6 || u.u != 12 && u.u != 14 && u.u != 16 || u.C != 16 && u.C != 0) {
              throw "Invalid data";
            }
            if (u.i == 0) {
              throw "Not implemented. We need this file!";
            }
            u.h = u.C == 16;
            u.m = (u.h ? u.l * 2 / 3 : u.l >>> 1) | 0;
            u.A = u.m + 2;
            u.f = 64;
            u.g = (1 << u.u) - 1;
            u.n = 4 * u.u;
            return u;
          }
          function a7(t, Z) {
            var u = new Array(Z.s), e = 4 * Z.s, Q = 16 + e;
            if (e & 12)
              Q += 16 - (e & 12);
            for (var V = 0, O = 16; V < Z.s; O += 4) {
              var o = UTIF2._binBE.readUint(t, O);
              u[V] = t.slice(Q, Q + o);
              u[V].j = 0;
              u[V].a = 0;
              Q += o;
              V++;
            }
            if (Q != t.length)
              throw "Invalid data";
            return u;
          }
          function a6(t, Z) {
            for (var u = -Z[4], e = 0; u <= Z[4]; e++, u++) {
              t[e] = u <= -Z[3] ? -4 : u <= -Z[2] ? -3 : u <= -Z[1] ? -2 : u < -Z[0] ? -1 : u <= Z[0] ? 0 : u < Z[1] ? 1 : u < Z[2] ? 2 : u < Z[3] ? 3 : 4;
            }
          }
          function a1(t, Z, u) {
            var e = [Z, 3 * Z + 18, 5 * Z + 67, 7 * Z + 276, u];
            t.o = Z;
            t.w = (e[4] + 2 * Z) / (2 * Z + 1) + 1 | 0;
            t.v = Math.ceil(Math.log2(t.w));
            t.t = 9;
            a6(t.c, e);
          }
          function a2(t) {
            var Z = { c: new Int8Array(2 << t.u) };
            a1(Z, 0, t.g);
            return Z;
          }
          function D(t) {
            var Z = [[], [], []], u = Math.max(2, t.w + 32 >>> 6);
            for (var e = 0; e < 3; e++) {
              for (var Q = 0; Q < 41; Q++) {
                Z[e][Q] = [u, 1];
              }
            }
            return Z;
          }
          function a4(t) {
            for (var Z = -1, u = 0; !u; Z++) {
              u = t[t.j] >>> 7 - t.a & 1;
              t.a++;
              t.a &= 7;
              if (!t.a)
                t.j++;
            }
            return Z;
          }
          function K(t, Z) {
            var u = 0, e = 8 - t.a, Q = t.j, V = t.a;
            if (Z) {
              if (Z >= e) {
                do {
                  u <<= e;
                  Z -= e;
                  u |= t[t.j] & (1 << e) - 1;
                  t.j++;
                  e = 8;
                } while (Z >= 8);
              }
              if (Z) {
                u <<= Z;
                e -= Z;
                u |= t[t.j] >>> e & (1 << Z) - 1;
              }
              t.a = 8 - e;
            }
            return u;
          }
          function a0(t, Z) {
            var u = 0;
            if (Z < t) {
              while (u <= 14 && Z << ++u < t)
                ;
            }
            return u;
          }
          function r(t, Z, u, e, Q, V, O, o) {
            if (o == null)
              o = 0;
            var X = V + 1, k = X % 2, j = 0, I = 0, a = 0, l, R, w = e[Q], S = e[Q - 1], H = e[Q - 2][X], g = S[X - 1], Y = S[X], P = S[X + 1], A = w[X - 1], v = w[X + 1], y = Math.abs, d, C, n, h;
            if (k) {
              d = y(P - Y);
              C = y(H - Y);
              n = y(g - Y);
            }
            if (k) {
              h = d > n && C < d ? H + g : d < n && C < n ? H + P : P + g;
              h = h + 2 * Y >>> 2;
              if (o) {
                w[X] = h;
                return;
              }
              l = Z.t * Z.c[t.g + Y - H] + Z.c[t.g + g - Y];
            } else {
              h = Y > g && Y > P || Y < g && Y < P ? v + A + 2 * Y >>> 2 : A + v >>> 1;
              l = Z.t * Z.c[t.g + Y - g] + Z.c[t.g + g - A];
            }
            R = y(l);
            var W = a4(u);
            if (W < t.n - Z.v - 1) {
              var z = a0(O[R][0], O[R][1]);
              a = K(u, z) + (W << z);
            } else {
              a = K(u, Z.v) + 1;
            }
            a = a & 1 ? -1 - (a >>> 1) : a >>> 1;
            O[R][0] += y(a);
            if (O[R][1] == t.f) {
              O[R][0] >>>= 1;
              O[R][1] >>>= 1;
            }
            O[R][1]++;
            h = l < 0 ? h - a : h + a;
            if (t.i) {
              if (h < 0)
                h += Z.w;
              else if (h > t.g)
                h -= Z.w;
            }
            w[X] = h >= 0 ? Math.min(h, t.g) : 0;
          }
          function U(t, Z, u) {
            var e = t[0].length;
            for (var Q = Z; Q <= u; Q++) {
              t[Q][0] = t[Q - 1][1];
              t[Q][e - 1] = t[Q - 1][e - 2];
            }
          }
          function B(t) {
            U(t, s, q);
            U(t, i2, J);
            U(t, x, $2);
          }
          function _(t, Z, u, e, Q, V, O, o, X, k, j, I, a) {
            var l = 0, R = 1, w = Q < M && Q > J;
            while (R < t.m) {
              if (l < t.m) {
                r(t, Z, u, e, Q, l, O[X], t.h && (w && k || !w && (j || (l & I) == a)));
                r(t, Z, u, e, V, l, O[X], t.h && (!w && k || w && (j || (l & I) == a)));
                l += 2;
              }
              if (l > 8) {
                r(t, Z, u, e, Q, R, o[X]);
                r(t, Z, u, e, V, R, o[X]);
                R += 2;
              }
            }
            B(e);
          }
          function a8(t, Z, u, e, Q, V) {
            _(t, Z, u, e, i2, s, Q, V, 0, 0, 1, 0, 8);
            _(t, Z, u, e, c, x, Q, V, 1, 0, 1, 0, 8);
            _(t, Z, u, e, b, T, Q, V, 2, 1, 0, 3, 0);
            _(t, Z, u, e, a3, L, Q, V, 0, 0, 0, 3, 2);
            _(t, Z, u, e, J, f, Q, V, 1, 0, 0, 3, 2);
            _(t, Z, u, e, q, $2, Q, V, 2, 1, 0, 3, 0);
          }
          function a9(t, Z, u, e, Q, V) {
            var O = V.length, o = t.l;
            if (Q + 1 == t.s)
              o = t.e - Q * t.l;
            var X = 6 * t.e * e + Q * t.l;
            for (var k = 0; k < 6; k++) {
              for (var j = 0; j < o; j++) {
                var I = V[k % O][j % O], a;
                if (I == 0) {
                  a = i2 + (k >>> 1);
                } else if (I == 2) {
                  a = x + (k >>> 1);
                } else {
                  a = s + k;
                }
                var l = t.h ? (j * 2 / 3 & 2147483646 | j % 3 & 1) + (j % 3 >>> 1) : j >>> 1;
                Z[X + j] = u[a][l + 1];
              }
              X += t.e;
            }
          }
          UTIF2._decompressRAF = function(t, Z) {
            var u = a5(t), e = a7(t, u), Q = a2(u), V = new Int16Array(u.e * u.q);
            if (Z == null) {
              Z = u.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]];
            }
            var O = [[G, b], [F, J], [N, f], [E, q], [M, L], [m, $2]], o = [];
            for (var X = 0; X < p; X++) {
              o[X] = new Uint16Array(u.A);
            }
            for (var k = 0; k < u.s; k++) {
              var j = D(Q), I = D(Q);
              for (var X = 0; X < p; X++) {
                for (var a = 0; a < u.A; a++) {
                  o[X][a] = 0;
                }
              }
              for (var l = 0; l < u.d; l++) {
                a8(u, Q, e[k], o, j, I);
                for (var X = 0; X < 6; X++) {
                  for (var a = 0; a < u.A; a++) {
                    o[O[X][0]][a] = o[O[X][1]][a];
                  }
                }
                a9(u, V, o, l, k, Z);
                for (var X = i2; X < p; X++) {
                  if ([N, E, M, m].indexOf(X) == -1) {
                    for (var a = 0; a < u.A; a++) {
                      o[X][a] = 0;
                    }
                  }
                }
                B(o);
              }
            }
            return V;
          };
        })();
      })(UTIF, pako);
    })();
  }
});

// node_modules/@jimp/tiff/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@jimp/tiff/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utif = _interopRequireDefault(require_UTIF());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MIME_TYPE = "image/tiff";
    var _default = () => ({
      mime: {
        [MIME_TYPE]: ["tiff", "tif"]
      },
      constants: {
        MIME_TIFF: MIME_TYPE
      },
      decoders: {
        [MIME_TYPE]: (data) => {
          const ifds = _utif.default.decode(data);
          const page = ifds[0];
          ifds.forEach((ifd) => {
            _utif.default.decodeImage(data, ifd);
          });
          const rgba = _utif.default.toRGBA8(page);
          return {
            data: Buffer.from(rgba),
            width: page.t256[0],
            height: page.t257[0]
          };
        }
      },
      encoders: {
        [MIME_TYPE]: (image2) => {
          const tiff = _utif.default.encodeImage(image2.bitmap.data, image2.bitmap.width, image2.bitmap.height);
          return Buffer.from(tiff);
        }
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS({
  "node_modules/omggif/omggif.js"(exports2) {
    "use strict";
    function GifWriter(buf, width, height, gopts) {
      var p = 0;
      var gopts = gopts === void 0 ? {} : gopts;
      var loop_count = gopts.loop === void 0 ? null : gopts.loop;
      var global_palette = gopts.palette === void 0 ? null : gopts.palette;
      if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
        throw new Error("Width/Height invalid.");
      function check_palette_and_num_colors(palette2) {
        var num_colors = palette2.length;
        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
          throw new Error(
            "Invalid code/color length, must be power of 2 and 2 .. 256."
          );
        }
        return num_colors;
      }
      buf[p++] = 71;
      buf[p++] = 73;
      buf[p++] = 70;
      buf[p++] = 56;
      buf[p++] = 57;
      buf[p++] = 97;
      var gp_num_colors_pow2 = 0;
      var background = 0;
      if (global_palette !== null) {
        var gp_num_colors = check_palette_and_num_colors(global_palette);
        while (gp_num_colors >>= 1)
          ++gp_num_colors_pow2;
        gp_num_colors = 1 << gp_num_colors_pow2;
        --gp_num_colors_pow2;
        if (gopts.background !== void 0) {
          background = gopts.background;
          if (background >= gp_num_colors)
            throw new Error("Background index out of range.");
          if (background === 0)
            throw new Error("Background index explicitly passed as 0.");
        }
      }
      buf[p++] = width & 255;
      buf[p++] = width >> 8 & 255;
      buf[p++] = height & 255;
      buf[p++] = height >> 8 & 255;
      buf[p++] = (global_palette !== null ? 128 : 0) | // Global Color Table Flag.
      gp_num_colors_pow2;
      buf[p++] = background;
      buf[p++] = 0;
      if (global_palette !== null) {
        for (var i2 = 0, il = global_palette.length; i2 < il; ++i2) {
          var rgb = global_palette[i2];
          buf[p++] = rgb >> 16 & 255;
          buf[p++] = rgb >> 8 & 255;
          buf[p++] = rgb & 255;
        }
      }
      if (loop_count !== null) {
        if (loop_count < 0 || loop_count > 65535)
          throw new Error("Loop count invalid.");
        buf[p++] = 33;
        buf[p++] = 255;
        buf[p++] = 11;
        buf[p++] = 78;
        buf[p++] = 69;
        buf[p++] = 84;
        buf[p++] = 83;
        buf[p++] = 67;
        buf[p++] = 65;
        buf[p++] = 80;
        buf[p++] = 69;
        buf[p++] = 50;
        buf[p++] = 46;
        buf[p++] = 48;
        buf[p++] = 3;
        buf[p++] = 1;
        buf[p++] = loop_count & 255;
        buf[p++] = loop_count >> 8 & 255;
        buf[p++] = 0;
      }
      var ended = false;
      this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
        if (ended === true) {
          --p;
          ended = false;
        }
        opts = opts === void 0 ? {} : opts;
        if (x < 0 || y < 0 || x > 65535 || y > 65535)
          throw new Error("x/y invalid.");
        if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
          throw new Error("Width/Height invalid.");
        if (indexed_pixels.length < w * h)
          throw new Error("Not enough pixels for the frame size.");
        var using_local_palette = true;
        var palette2 = opts.palette;
        if (palette2 === void 0 || palette2 === null) {
          using_local_palette = false;
          palette2 = global_palette;
        }
        if (palette2 === void 0 || palette2 === null)
          throw new Error("Must supply either a local or global palette.");
        var num_colors = check_palette_and_num_colors(palette2);
        var min_code_size = 0;
        while (num_colors >>= 1)
          ++min_code_size;
        num_colors = 1 << min_code_size;
        var delay = opts.delay === void 0 ? 0 : opts.delay;
        var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
        if (disposal < 0 || disposal > 3)
          throw new Error("Disposal out of range.");
        var use_transparency = false;
        var transparent_index = 0;
        if (opts.transparent !== void 0 && opts.transparent !== null) {
          use_transparency = true;
          transparent_index = opts.transparent;
          if (transparent_index < 0 || transparent_index >= num_colors)
            throw new Error("Transparent color index.");
        }
        if (disposal !== 0 || use_transparency || delay !== 0) {
          buf[p++] = 33;
          buf[p++] = 249;
          buf[p++] = 4;
          buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
          buf[p++] = delay & 255;
          buf[p++] = delay >> 8 & 255;
          buf[p++] = transparent_index;
          buf[p++] = 0;
        }
        buf[p++] = 44;
        buf[p++] = x & 255;
        buf[p++] = x >> 8 & 255;
        buf[p++] = y & 255;
        buf[p++] = y >> 8 & 255;
        buf[p++] = w & 255;
        buf[p++] = w >> 8 & 255;
        buf[p++] = h & 255;
        buf[p++] = h >> 8 & 255;
        buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
        if (using_local_palette === true) {
          for (var i3 = 0, il2 = palette2.length; i3 < il2; ++i3) {
            var rgb2 = palette2[i3];
            buf[p++] = rgb2 >> 16 & 255;
            buf[p++] = rgb2 >> 8 & 255;
            buf[p++] = rgb2 & 255;
          }
        }
        p = GifWriterOutputLZWCodeStream(
          buf,
          p,
          min_code_size < 2 ? 2 : min_code_size,
          indexed_pixels
        );
        return p;
      };
      this.end = function() {
        if (ended === false) {
          buf[p++] = 59;
          ended = true;
        }
        return p;
      };
      this.getOutputBuffer = function() {
        return buf;
      };
      this.setOutputBuffer = function(v) {
        buf = v;
      };
      this.getOutputBufferPosition = function() {
        return p;
      };
      this.setOutputBufferPosition = function(v) {
        p = v;
      };
    }
    function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
      buf[p++] = min_code_size;
      var cur_subblock = p++;
      var clear_code = 1 << min_code_size;
      var code_mask = clear_code - 1;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var cur_shift = 0;
      var cur = 0;
      function emit_bytes_to_buffer(bit_block_size) {
        while (cur_shift >= bit_block_size) {
          buf[p++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p++;
          }
        }
      }
      function emit_code(c) {
        cur |= c << cur_shift;
        cur_shift += cur_code_size;
        emit_bytes_to_buffer(8);
      }
      var ib_code = index_stream[0] & code_mask;
      var code_table = {};
      emit_code(clear_code);
      for (var i2 = 1, il = index_stream.length; i2 < il; ++i2) {
        var k = index_stream[i2] & code_mask;
        var cur_key = ib_code << 8 | k;
        var cur_code = code_table[cur_key];
        if (cur_code === void 0) {
          cur |= ib_code << cur_shift;
          cur_shift += cur_code_size;
          while (cur_shift >= 8) {
            buf[p++] = cur & 255;
            cur >>= 8;
            cur_shift -= 8;
            if (p === cur_subblock + 256) {
              buf[cur_subblock] = 255;
              cur_subblock = p++;
            }
          }
          if (next_code === 4096) {
            emit_code(clear_code);
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_table = {};
          } else {
            if (next_code >= 1 << cur_code_size)
              ++cur_code_size;
            code_table[cur_key] = next_code++;
          }
          ib_code = k;
        } else {
          ib_code = cur_code;
        }
      }
      emit_code(ib_code);
      emit_code(eoi_code);
      emit_bytes_to_buffer(1);
      if (cur_subblock + 1 === p) {
        buf[cur_subblock] = 0;
      } else {
        buf[cur_subblock] = p - cur_subblock - 1;
        buf[p++] = 0;
      }
      return p;
    }
    function GifReader(buf) {
      var p = 0;
      if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
        throw new Error("Invalid GIF 87a/89a header.");
      }
      var width = buf[p++] | buf[p++] << 8;
      var height = buf[p++] | buf[p++] << 8;
      var pf0 = buf[p++];
      var global_palette_flag = pf0 >> 7;
      var num_global_colors_pow2 = pf0 & 7;
      var num_global_colors = 1 << num_global_colors_pow2 + 1;
      var background = buf[p++];
      buf[p++];
      var global_palette_offset = null;
      var global_palette_size = null;
      if (global_palette_flag) {
        global_palette_offset = p;
        global_palette_size = num_global_colors;
        p += num_global_colors * 3;
      }
      var no_eof = true;
      var frames = [];
      var delay = 0;
      var transparent_index = null;
      var disposal = 0;
      var loop_count = null;
      this.width = width;
      this.height = height;
      while (no_eof && p < buf.length) {
        switch (buf[p++]) {
          case 33:
            switch (buf[p++]) {
              case 255:
                if (buf[p] !== 11 || // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && // Sub-block
                buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                  p += 14;
                  loop_count = buf[p++] | buf[p++] << 8;
                  p++;
                } else {
                  p += 12;
                  while (true) {
                    var block_size = buf[p++];
                    if (!(block_size >= 0))
                      throw Error("Invalid block size");
                    if (block_size === 0)
                      break;
                    p += block_size;
                  }
                }
                break;
              case 249:
                if (buf[p++] !== 4 || buf[p + 4] !== 0)
                  throw new Error("Invalid graphics extension block.");
                var pf1 = buf[p++];
                delay = buf[p++] | buf[p++] << 8;
                transparent_index = buf[p++];
                if ((pf1 & 1) === 0)
                  transparent_index = null;
                disposal = pf1 >> 2 & 7;
                p++;
                break;
              case 254:
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
                break;
              default:
                throw new Error(
                  "Unknown graphic control label: 0x" + buf[p - 1].toString(16)
                );
            }
            break;
          case 44:
            var x = buf[p++] | buf[p++] << 8;
            var y = buf[p++] | buf[p++] << 8;
            var w = buf[p++] | buf[p++] << 8;
            var h = buf[p++] | buf[p++] << 8;
            var pf2 = buf[p++];
            var local_palette_flag = pf2 >> 7;
            var interlace_flag = pf2 >> 6 & 1;
            var num_local_colors_pow2 = pf2 & 7;
            var num_local_colors = 1 << num_local_colors_pow2 + 1;
            var palette_offset = global_palette_offset;
            var palette_size = global_palette_size;
            var has_local_palette = false;
            if (local_palette_flag) {
              var has_local_palette = true;
              palette_offset = p;
              palette_size = num_local_colors;
              p += num_local_colors * 3;
            }
            var data_offset = p;
            p++;
            while (true) {
              var block_size = buf[p++];
              if (!(block_size >= 0))
                throw Error("Invalid block size");
              if (block_size === 0)
                break;
              p += block_size;
            }
            frames.push({
              x,
              y,
              width: w,
              height: h,
              has_local_palette,
              palette_offset,
              palette_size,
              data_offset,
              data_length: p - data_offset,
              transparent_index,
              interlaced: !!interlace_flag,
              delay,
              disposal
            });
            break;
          case 59:
            no_eof = false;
            break;
          default:
            throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
            break;
        }
      }
      this.numFrames = function() {
        return frames.length;
      };
      this.loopCount = function() {
        return loop_count;
      };
      this.frameInfo = function(frame_num) {
        if (frame_num < 0 || frame_num >= frames.length)
          throw new Error("Frame index out of range.");
        return frames[frame_num];
      };
      this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(
          buf,
          frame.data_offset,
          index_stream,
          num_pixels
        );
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null)
          trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i2 = 0, il = index_stream.length; i2 < il; ++i2) {
          var index = index_stream[i2];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index * 3];
            var g = buf[palette_offset2 + index * 3 + 1];
            var b = buf[palette_offset2 + index * 3 + 2];
            pixels[op++] = b;
            pixels[op++] = g;
            pixels[op++] = r;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
      this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(
          buf,
          frame.data_offset,
          index_stream,
          num_pixels
        );
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null)
          trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i2 = 0, il = index_stream.length; i2 < il; ++i2) {
          var index = index_stream[i2];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index * 3];
            var g = buf[palette_offset2 + index * 3 + 1];
            var b = buf[palette_offset2 + index * 3 + 2];
            pixels[op++] = r;
            pixels[op++] = g;
            pixels[op++] = b;
            pixels[op++] = 255;
          }
          --xleft;
        }
      };
    }
    function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
      var min_code_size = code_stream[p++];
      var clear_code = 1 << min_code_size;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var code_mask = (1 << cur_code_size) - 1;
      var cur_shift = 0;
      var cur = 0;
      var op = 0;
      var subblock_size = code_stream[p++];
      var code_table = new Int32Array(4096);
      var prev_code = null;
      while (true) {
        while (cur_shift < 16) {
          if (subblock_size === 0)
            break;
          cur |= code_stream[p++] << cur_shift;
          cur_shift += 8;
          if (subblock_size === 1) {
            subblock_size = code_stream[p++];
          } else {
            --subblock_size;
          }
        }
        if (cur_shift < cur_code_size)
          break;
        var code = cur & code_mask;
        cur >>= cur_code_size;
        cur_shift -= cur_code_size;
        if (code === clear_code) {
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_mask = (1 << cur_code_size) - 1;
          prev_code = null;
          continue;
        } else if (code === eoi_code) {
          break;
        }
        var chase_code = code < next_code ? code : prev_code;
        var chase_length = 0;
        var chase = chase_code;
        while (chase > clear_code) {
          chase = code_table[chase] >> 8;
          ++chase_length;
        }
        var k = chase;
        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
        if (op_end > output_length) {
          console.log("Warning, gif stream longer than expected.");
          return;
        }
        output[op++] = k;
        op += chase_length;
        var b = op;
        if (chase_code !== code)
          output[op++] = k;
        chase = chase_code;
        while (chase_length--) {
          chase = code_table[chase];
          output[--b] = chase & 255;
          chase >>= 8;
        }
        if (prev_code !== null && next_code < 4096) {
          code_table[next_code++] = prev_code << 8 | k;
          if (next_code >= code_mask + 1 && cur_code_size < 12) {
            ++cur_code_size;
            code_mask = code_mask << 1 | 1;
          }
        }
        prev_code = code;
      }
      if (op !== output_length) {
        console.log("Warning, gif stream shorter than expected.");
      }
      return output;
    }
    try {
      exports2.GifWriter = GifWriter;
      exports2.GifReader = GifReader;
    } catch (e) {
    }
  }
});

// node_modules/gifwrap/src/bitmapimage.js
var require_bitmapimage = __commonJS({
  "node_modules/gifwrap/src/bitmapimage.js"(exports2, module2) {
    "use strict";
    var BitmapImage = class _BitmapImage {
      /**
       * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
       * 
       * Property | Description
       * --- | ---
       * bitmap.width | width of image in pixels
       * bitmap.height | height of image in pixels
       * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
       *
       * Its constructor supports the following signatures:
       *
       * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
       * * new BitmapImage(bitmapImage: BitmapImage)
       * * new BitmapImage(width: number, height: number, buffer: Buffer)
       * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
       * 
       * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
       *
       * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
       */
      constructor(...args) {
        if (args.length === 0) {
          throw new Error("constructor requires parameters");
        }
        const firstArg = args[0];
        if (firstArg !== null && typeof firstArg === "object") {
          if (firstArg instanceof _BitmapImage) {
            const sourceBitmap = firstArg.bitmap;
            this.bitmap = {
              width: sourceBitmap.width,
              height: sourceBitmap.height,
              data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
            };
            sourceBitmap.data.copy(this.bitmap.data);
          } else if (firstArg.width && firstArg.height && firstArg.data) {
            this.bitmap = firstArg;
          } else {
            throw new Error("unrecognized constructor parameters");
          }
        } else if (typeof firstArg === "number" && typeof args[1] === "number") {
          const width = firstArg;
          const height = args[1];
          const thirdArg = args[2];
          this.bitmap = { width, height };
          if (Buffer.isBuffer(thirdArg)) {
            this.bitmap.data = thirdArg;
          } else {
            this.bitmap.data = new Buffer(width * height * 4);
            if (typeof thirdArg === "number") {
              this.fillRGBA(thirdArg);
            }
          }
        } else {
          throw new Error("unrecognized constructor parameters");
        }
      }
      /**
       * Copy a square portion of this image into another image. 
       * 
       * @param {BitmapImage} toImage Image into which to copy the square
       * @param {number} toX x-coord in toImage of upper-left corner of receiving square
       * @param {number} toY y-coord in toImage of upper-left corner of receiving square
       * @param {number} fromX x-coord in this image of upper-left corner of source square
       * @param {number} fromY y-coord in this image of upper-left corner of source square
       * @return {BitmapImage} The present image to allow for chaining.
       */
      blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
        if (fromX + fromWidth > this.bitmap.width) {
          throw new Error("copy exceeds width of source bitmap");
        }
        if (toX + fromWidth > toImage.bitmap.width) {
          throw new Error("copy exceeds width of target bitmap");
        }
        if (fromY + fromHeight > this.bitmap.height) {
          throw new Error("copy exceeds height of source bitmap");
        }
        if (toY + fromHeight > toImage.bitmap.height) {
          throw new Erro("copy exceeds height of target bitmap");
        }
        const sourceBuf = this.bitmap.data;
        const targetBuf = toImage.bitmap.data;
        const sourceByteWidth = this.bitmap.width * 4;
        const targetByteWidth = toImage.bitmap.width * 4;
        const copyByteWidth = fromWidth * 4;
        let si = fromY * sourceByteWidth + fromX * 4;
        let ti = toY * targetByteWidth + toX * 4;
        while (--fromHeight >= 0) {
          sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
          si += sourceByteWidth;
          ti += targetByteWidth;
        }
        return this;
      }
      /**
       * Fills the image with a single color.
       * 
       * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
       * @return {BitmapImage} The present image to allow for chaining.
       */
      fillRGBA(rgba) {
        const buf = this.bitmap.data;
        const bufByteWidth = this.bitmap.height * 4;
        let bi = 0;
        while (bi < bufByteWidth) {
          buf.writeUInt32BE(rgba, bi);
          bi += 4;
        }
        while (bi < buf.length) {
          buf.copy(buf, bi, 0, bufByteWidth);
          bi += bufByteWidth;
        }
        return this;
      }
      /**
       * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
       * 
       * @param {number} x x-coord of pixel
       * @param {number} y y-coord of pixel
       * @return {number} RGBA of pixel in 0xRRGGBBAA form
       */
      getRGBA(x, y) {
        const bi = (y * this.bitmap.width + x) * 4;
        return this.bitmap.data.readUInt32BE(bi);
      }
      /**
       * Gets a set of all RGBA colors found within the image.
       * 
       * @return {Set} Set of all RGBA colors that the image contains.
       */
      getRGBASet() {
        const rgbaSet = /* @__PURE__ */ new Set();
        const buf = this.bitmap.data;
        for (let bi = 0; bi < buf.length; bi += 4) {
          rgbaSet.add(buf.readUInt32BE(bi, true));
        }
        return rgbaSet;
      }
      /**
       * Converts the image to greyscale using inferred Adobe metrics.
       * 
       * @return {BitmapImage} The present image to allow for chaining.
       */
      greyscale() {
        const buf = this.bitmap.data;
        this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
          const grey = Math.round(
            0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]
          );
          buf[idx] = grey;
          buf[idx + 1] = grey;
          buf[idx + 2] = grey;
        });
        return this;
      }
      /**
       * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
       * 
       * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
       * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
       * @param {number} width The width of the new image after reframing
       * @param {number} height The height of the new image after reframing
       * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
       * @return {BitmapImage} The present image to allow for chaining.
       */
      reframe(xOffset, yOffset, width, height, fillRGBA) {
        const cropX = xOffset < 0 ? 0 : xOffset;
        const cropY = yOffset < 0 ? 0 : yOffset;
        const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
        const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
        const newX = xOffset < 0 ? -xOffset : 0;
        const newY = yOffset < 0 ? -yOffset : 0;
        let image2;
        if (fillRGBA === void 0) {
          if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
            throw new GifError(`fillRGBA required for this reframing`);
          }
          image2 = new _BitmapImage(width, height);
        } else {
          image2 = new _BitmapImage(width, height, fillRGBA);
        }
        this.blit(image2, newX, newY, cropX, cropY, cropWidth, cropHeight);
        this.bitmap = image2.bitmap;
        return this;
      }
      /**
       * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
       * 
       * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
       * @return {BitmapImage} The present image to allow for chaining.
       */
      scale(factor) {
        if (factor === 1) {
          return;
        }
        if (!Number.isInteger(factor) || factor < 1) {
          throw new Error("the scale must be an integer >= 1");
        }
        const sourceWidth = this.bitmap.width;
        const sourceHeight = this.bitmap.height;
        const destByteWidth = sourceWidth * factor * 4;
        const sourceBuf = this.bitmap.data;
        const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
        let sourceIndex = 0;
        let priorDestRowIndex;
        let destIndex = 0;
        for (let y = 0; y < sourceHeight; ++y) {
          priorDestRowIndex = destIndex;
          for (let x = 0; x < sourceWidth; ++x) {
            const color = sourceBuf.readUInt32BE(sourceIndex, true);
            for (let cx = 0; cx < factor; ++cx) {
              destBuf.writeUInt32BE(color, destIndex);
              destIndex += 4;
            }
            sourceIndex += 4;
          }
          for (let cy = 1; cy < factor; ++cy) {
            destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
            destIndex += destByteWidth;
            priorDestRowIndex += destByteWidth;
          }
        }
        this.bitmap = {
          width: sourceWidth * factor,
          height: sourceHeight * factor,
          data: destBuf
        };
        return this;
      }
      /**
       * Scans all coordinates of the image, handing each in turn to the provided handler function.
       *
       * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
       * @see scanAllIndexes
       */
      scanAllCoords(scanHandler) {
        const width = this.bitmap.width;
        const bufferLength = this.bitmap.data.length;
        let x = 0;
        let y = 0;
        for (let bi = 0; bi < bufferLength; bi += 4) {
          scanHandler(x, y, bi);
          if (++x === width) {
            x = 0;
            ++y;
          }
        }
      }
      /**
       * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
       *
       * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
       * @see scanAllCoords
       */
      scanAllIndexes(scanHandler) {
        const bufferLength = this.bitmap.data.length;
        for (let bi = 0; bi < bufferLength; bi += 4) {
          scanHandler(bi);
        }
      }
    };
    module2.exports = BitmapImage;
  }
});

// node_modules/gifwrap/src/gif.js
var require_gif = __commonJS({
  "node_modules/gifwrap/src/gif.js"(exports2) {
    "use strict";
    var Gif = class {
      // width - width of GIF in pixels
      // height - height of GIF in pixels
      // loops - 0 = unending; (n > 0) = iterate n times
      // usesTransparency - whether any frames have transparent pixels
      // colorScope - scope of color tables in GIF
      // frames - array of frames
      // buffer - GIF-formatted data
      /**
       * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
       * 
       * Property | Description
       * --- | ---
       * width | width of the GIF at its widest
       * height | height of the GIF at its highest
       * loops | the number of times the GIF should loop before stopping; 0 => loop indefinitely
       * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
       * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
       * frames | a array of GifFrame instances, one for each frame of the GIF
       * buffer | a Buffer holding the encoding's byte data
       * 
       * Its constructor should only ever be called by the GIF encoder or decoder.
       *
       * @param {Buffer} buffer A Buffer containing the encoded bytes
       * @param {GifFrame[]} frames Array of frames found in the encoding
       * @param {object} spec Properties of the encoding as listed above
       */
      constructor(buffer, frames, spec) {
        this.width = spec.width;
        this.height = spec.height;
        this.loops = spec.loops;
        this.usesTransparency = spec.usesTransparency;
        this.colorScope = spec.colorScope;
        this.frames = frames;
        this.buffer = buffer;
      }
    };
    Gif.GlobalColorsPreferred = 0;
    Gif.GlobalColorsOnly = 1;
    Gif.LocalColorsOnly = 2;
    var GifError2 = class extends Error {
      /**
       * GifError is a class representing a GIF-related error
       * 
       * @param {string|Error} messageOrError
       */
      constructor(messageOrError) {
        super(messageOrError);
        if (messageOrError instanceof Error) {
          this.stack = "Gif" + messageOrError.stack;
        }
      }
    };
    exports2.Gif = Gif;
    exports2.GifError = GifError2;
  }
});

// node_modules/image-q/dist/cjs/image-q.cjs
var require_image_q = __commonJS({
  "node_modules/image-q/dist/cjs/image-q.cjs"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value2) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
    var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
    var __export = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __reExport = (target, module22, copyDefault, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames2(module22))
          if (!__hasOwnProp2.call(target, key) && (copyDefault || key !== "default"))
            __defProp2(target, key, { get: () => module22[key], enumerable: !(desc = __getOwnPropDesc2(module22, key)) || desc.enumerable });
      }
      return target;
    };
    var __toCommonJS = /* @__PURE__ */ ((cache) => {
      return (module22, temp) => {
        return cache && cache.get(module22) || (temp = __reExport(__markAsModule({}), module22, 1), cache && cache.set(module22, temp), temp);
      };
    })(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
    var __publicField = (obj, key, value2) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
      return value2;
    };
    var src_exports = {};
    __export(src_exports, {
      applyPalette: () => applyPalette,
      applyPaletteSync: () => applyPaletteSync,
      buildPalette: () => buildPalette,
      buildPaletteSync: () => buildPaletteSync,
      constants: () => constants_exports,
      conversion: () => conversion_exports,
      distance: () => distance_exports,
      image: () => image_exports,
      palette: () => palette_exports,
      quality: () => quality_exports,
      utils: () => utils_exports
    });
    var constants_exports = {};
    __export(constants_exports, {
      bt709: () => bt709_exports
    });
    var bt709_exports = {};
    __export(bt709_exports, {
      Y: () => Y,
      x: () => x,
      y: () => y
    });
    var Y = /* @__PURE__ */ ((Y2) => {
      Y2[Y2["RED"] = 0.2126] = "RED";
      Y2[Y2["GREEN"] = 0.7152] = "GREEN";
      Y2[Y2["BLUE"] = 0.0722] = "BLUE";
      Y2[Y2["WHITE"] = 1] = "WHITE";
      return Y2;
    })(Y || {});
    var x = /* @__PURE__ */ ((x2) => {
      x2[x2["RED"] = 0.64] = "RED";
      x2[x2["GREEN"] = 0.3] = "GREEN";
      x2[x2["BLUE"] = 0.15] = "BLUE";
      x2[x2["WHITE"] = 0.3127] = "WHITE";
      return x2;
    })(x || {});
    var y = /* @__PURE__ */ ((y2) => {
      y2[y2["RED"] = 0.33] = "RED";
      y2[y2["GREEN"] = 0.6] = "GREEN";
      y2[y2["BLUE"] = 0.06] = "BLUE";
      y2[y2["WHITE"] = 0.329] = "WHITE";
      return y2;
    })(y || {});
    var conversion_exports = {};
    __export(conversion_exports, {
      lab2rgb: () => lab2rgb,
      lab2xyz: () => lab2xyz,
      rgb2hsl: () => rgb2hsl,
      rgb2lab: () => rgb2lab,
      rgb2xyz: () => rgb2xyz,
      xyz2lab: () => xyz2lab,
      xyz2rgb: () => xyz2rgb
    });
    function correctGamma(n) {
      return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
    }
    function rgb2xyz(r, g, b) {
      r = correctGamma(r / 255);
      g = correctGamma(g / 255);
      b = correctGamma(b / 255);
      return {
        x: r * 0.4124 + g * 0.3576 + b * 0.1805,
        y: r * 0.2126 + g * 0.7152 + b * 0.0722,
        z: r * 0.0193 + g * 0.1192 + b * 0.9505
      };
    }
    var arithmetic_exports = {};
    __export(arithmetic_exports, {
      degrees2radians: () => degrees2radians,
      inRange0to255: () => inRange0to255,
      inRange0to255Rounded: () => inRange0to255Rounded,
      intInRange: () => intInRange,
      max3: () => max3,
      min3: () => min3,
      stableSort: () => stableSort
    });
    function degrees2radians(n) {
      return n * (Math.PI / 180);
    }
    function max3(a, b, c) {
      let m = a;
      if (m < b)
        m = b;
      if (m < c)
        m = c;
      return m;
    }
    function min3(a, b, c) {
      let m = a;
      if (m > b)
        m = b;
      if (m > c)
        m = c;
      return m;
    }
    function intInRange(value2, low, high) {
      if (value2 > high)
        value2 = high;
      if (value2 < low)
        value2 = low;
      return value2 | 0;
    }
    function inRange0to255Rounded(n) {
      n = Math.round(n);
      if (n > 255)
        n = 255;
      else if (n < 0)
        n = 0;
      return n;
    }
    function inRange0to255(n) {
      if (n > 255)
        n = 255;
      else if (n < 0)
        n = 0;
      return n;
    }
    function stableSort(arrayToSort, callback) {
      const type = typeof arrayToSort[0];
      let sorted;
      if (type === "number" || type === "string") {
        const ord = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0, l = arrayToSort.length; i2 < l; i2++) {
          const val = arrayToSort[i2];
          if (ord[val] || ord[val] === 0)
            continue;
          ord[val] = i2;
        }
        sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);
      } else {
        const ord2 = arrayToSort.slice(0);
        sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));
      }
      return sorted;
    }
    function rgb2hsl(r, g, b) {
      const min2 = min3(r, g, b);
      const max2 = max3(r, g, b);
      const delta = max2 - min2;
      const l = (min2 + max2) / 510;
      let s = 0;
      if (l > 0 && l < 1)
        s = delta / (l < 0.5 ? max2 + min2 : 510 - max2 - min2);
      let h = 0;
      if (delta > 0) {
        if (max2 === r) {
          h = (g - b) / delta;
        } else if (max2 === g) {
          h = 2 + (b - r) / delta;
        } else {
          h = 4 + (r - g) / delta;
        }
        h *= 60;
        if (h < 0)
          h += 360;
      }
      return { h, s, l };
    }
    var refX = 0.95047;
    var refY = 1;
    var refZ = 1.08883;
    function pivot(n) {
      return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
    }
    function xyz2lab(x2, y2, z) {
      x2 = pivot(x2 / refX);
      y2 = pivot(y2 / refY);
      z = pivot(z / refZ);
      if (116 * y2 - 16 < 0)
        throw new Error("xxx");
      return {
        L: Math.max(0, 116 * y2 - 16),
        a: 500 * (x2 - y2),
        b: 200 * (y2 - z)
      };
    }
    function rgb2lab(r, g, b) {
      const xyz = rgb2xyz(r, g, b);
      return xyz2lab(xyz.x, xyz.y, xyz.z);
    }
    var refX2 = 0.95047;
    var refY2 = 1;
    var refZ2 = 1.08883;
    function pivot2(n) {
      return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
    }
    function lab2xyz(L, a, b) {
      const y2 = (L + 16) / 116;
      const x2 = a / 500 + y2;
      const z = y2 - b / 200;
      return {
        x: refX2 * pivot2(x2),
        y: refY2 * pivot2(y2),
        z: refZ2 * pivot2(z)
      };
    }
    function correctGamma2(n) {
      return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
    }
    function xyz2rgb(x2, y2, z) {
      const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);
      const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);
      const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);
      return {
        r: inRange0to255Rounded(r * 255),
        g: inRange0to255Rounded(g * 255),
        b: inRange0to255Rounded(b * 255)
      };
    }
    function lab2rgb(L, a, b) {
      const xyz = lab2xyz(L, a, b);
      return xyz2rgb(xyz.x, xyz.y, xyz.z);
    }
    var distance_exports = {};
    __export(distance_exports, {
      AbstractDistanceCalculator: () => AbstractDistanceCalculator,
      AbstractEuclidean: () => AbstractEuclidean,
      AbstractManhattan: () => AbstractManhattan,
      CIE94GraphicArts: () => CIE94GraphicArts,
      CIE94Textiles: () => CIE94Textiles,
      CIEDE2000: () => CIEDE2000,
      CMetric: () => CMetric,
      Euclidean: () => Euclidean,
      EuclideanBT709: () => EuclideanBT709,
      EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
      Manhattan: () => Manhattan,
      ManhattanBT709: () => ManhattanBT709,
      ManhattanNommyde: () => ManhattanNommyde,
      PNGQuant: () => PNGQuant
    });
    var AbstractDistanceCalculator = class {
      constructor() {
        __publicField(this, "_maxDistance");
        __publicField(this, "_whitePoint");
        this._setDefaults();
        this.setWhitePoint(255, 255, 255, 255);
      }
      setWhitePoint(r, g, b, a) {
        this._whitePoint = {
          r: r > 0 ? 255 / r : 0,
          g: g > 0 ? 255 / g : 0,
          b: b > 0 ? 255 / b : 0,
          a: a > 0 ? 255 / a : 0
        };
        this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
      }
      calculateNormalized(colorA, colorB) {
        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
      }
    };
    var AbstractCIE94 = class extends AbstractDistanceCalculator {
      calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
        const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
        const dL = lab1.L - lab2.L;
        const dA = lab1.a - lab2.a;
        const dB = lab1.b - lab2.b;
        const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);
        const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
        const dC = c1 - c2;
        let deltaH = dA * dA + dB * dB - dC * dC;
        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
        return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
      }
    };
    var CIE94Textiles = class extends AbstractCIE94 {
      _setDefaults() {
        this._Kl = 2;
        this._K1 = 0.048;
        this._K2 = 0.014;
        this._kA = 0.25 * 50 / 255;
      }
    };
    var CIE94GraphicArts = class extends AbstractCIE94 {
      _setDefaults() {
        this._Kl = 1;
        this._K1 = 0.045;
        this._K2 = 0.015;
        this._kA = 0.25 * 100 / 255;
      }
    };
    var _CIEDE2000 = class extends AbstractDistanceCalculator {
      _setDefaults() {
      }
      static _calculatehp(b, ap) {
        const hp = Math.atan2(b, ap);
        if (hp >= 0)
          return hp;
        return hp + _CIEDE2000._deg360InRad;
      }
      static _calculateRT(ahp, aCp) {
        const aCp_to_7 = aCp ** 7;
        const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));
        const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
        return -Math.sin(2 * delta_theta) * R_C;
      }
      static _calculateT(ahp) {
        return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);
      }
      static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
        const hpSum = h1p + h2p;
        if (C1pC2p === 0)
          return hpSum;
        if (h_bar <= _CIEDE2000._deg180InRad)
          return hpSum / 2;
        if (hpSum < _CIEDE2000._deg360InRad) {
          return (hpSum + _CIEDE2000._deg360InRad) / 2;
        }
        return (hpSum - _CIEDE2000._deg360InRad) / 2;
      }
      static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
        let dhp;
        if (C1pC2p === 0) {
          dhp = 0;
        } else if (h_bar <= _CIEDE2000._deg180InRad) {
          dhp = h2p - h1p;
        } else if (h2p <= h1p) {
          dhp = h2p - h1p + _CIEDE2000._deg360InRad;
        } else {
          dhp = h2p - h1p - _CIEDE2000._deg360InRad;
        }
        return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
      }
      calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));
        const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));
        const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;
        const dE2 = this.calculateRawInLab(lab1, lab2);
        return Math.sqrt(dE2 + dA * dA);
      }
      calculateRawInLab(Lab1, Lab2) {
        const L1 = Lab1.L;
        const a1 = Lab1.a;
        const b1 = Lab1.b;
        const L2 = Lab2.L;
        const a2 = Lab2.a;
        const b2 = Lab2.b;
        const C1 = Math.sqrt(a1 * a1 + b1 * b1);
        const C2 = Math.sqrt(a2 * a2 + b2 * b2);
        const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;
        const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));
        const a1p = (1 + G) * a1;
        const a2p = (1 + G) * a2;
        const C1p = Math.sqrt(a1p * a1p + b1 * b1);
        const C2p = Math.sqrt(a2p * a2p + b2 * b2);
        const C1pC2p = C1p * C2p;
        const h1p = _CIEDE2000._calculatehp(b1, a1p);
        const h2p = _CIEDE2000._calculatehp(b2, a2p);
        const h_bar = Math.abs(h1p - h2p);
        const dLp = L2 - L1;
        const dCp = C2p - C1p;
        const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);
        const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);
        const T = _CIEDE2000._calculateT(ahp);
        const aCp = (C1p + C2p) / 2;
        const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;
        const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);
        const S_C = 1 + 0.045 * aCp;
        const S_H = 1 + 0.015 * T * aCp;
        const R_T = _CIEDE2000._calculateRT(ahp, aCp);
        const dLpSL = dLp / S_L;
        const dCpSC = dCp / S_C;
        const dHpSH = dHp / S_H;
        return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;
      }
    };
    var CIEDE2000 = _CIEDE2000;
    __publicField(CIEDE2000, "_kA", 0.25 * 100 / 255);
    __publicField(CIEDE2000, "_pow25to7", 25 ** 7);
    __publicField(CIEDE2000, "_deg360InRad", degrees2radians(360));
    __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180));
    __publicField(CIEDE2000, "_deg30InRad", degrees2radians(30));
    __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6));
    __publicField(CIEDE2000, "_deg63InRad", degrees2radians(63));
    __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275));
    __publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
    var CMetric = class extends AbstractDistanceCalculator {
      calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const rmean = (r1 + r2) / 2 * this._whitePoint.r;
        const r = (r1 - r2) * this._whitePoint.r;
        const g = (g1 - g2) * this._whitePoint.g;
        const b = (b1 - b2) * this._whitePoint.b;
        const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);
        const dA = (a2 - a1) * this._whitePoint.a;
        return Math.sqrt(dE + dA * dA);
      }
      _setDefaults() {
      }
    };
    var AbstractEuclidean = class extends AbstractDistanceCalculator {
      calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const dR = r2 - r1;
        const dG = g2 - g1;
        const dB = b2 - b1;
        const dA = a2 - a1;
        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
      }
    };
    var Euclidean = class extends AbstractEuclidean {
      _setDefaults() {
        this._kR = 1;
        this._kG = 1;
        this._kB = 1;
        this._kA = 1;
      }
    };
    var EuclideanBT709 = class extends AbstractEuclidean {
      _setDefaults() {
        this._kR = 0.2126;
        this._kG = 0.7152;
        this._kB = 0.0722;
        this._kA = 1;
      }
    };
    var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
      _setDefaults() {
        this._kR = 0.2126;
        this._kG = 0.7152;
        this._kB = 0.0722;
        this._kA = 0;
      }
    };
    var AbstractManhattan = class extends AbstractDistanceCalculator {
      calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        let dR = r2 - r1;
        let dG = g2 - g1;
        let dB = b2 - b1;
        let dA = a2 - a1;
        if (dR < 0)
          dR = 0 - dR;
        if (dG < 0)
          dG = 0 - dG;
        if (dB < 0)
          dB = 0 - dB;
        if (dA < 0)
          dA = 0 - dA;
        return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
      }
    };
    var Manhattan = class extends AbstractManhattan {
      _setDefaults() {
        this._kR = 1;
        this._kG = 1;
        this._kB = 1;
        this._kA = 1;
      }
    };
    var ManhattanNommyde = class extends AbstractManhattan {
      _setDefaults() {
        this._kR = 0.4984;
        this._kG = 0.8625;
        this._kB = 0.2979;
        this._kA = 1;
      }
    };
    var ManhattanBT709 = class extends AbstractManhattan {
      _setDefaults() {
        this._kR = 0.2126;
        this._kG = 0.7152;
        this._kB = 0.0722;
        this._kA = 1;
      }
    };
    var PNGQuant = class extends AbstractDistanceCalculator {
      calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const alphas = (a2 - a1) * this._whitePoint.a;
        return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
      }
      _colordifferenceCh(x2, y2, alphas) {
        const black = x2 - y2;
        const white = black + alphas;
        return black * black + white * white;
      }
      _setDefaults() {
      }
    };
    var palette_exports = {};
    __export(palette_exports, {
      AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
      ColorHistogram: () => ColorHistogram,
      NeuQuant: () => NeuQuant,
      NeuQuantFloat: () => NeuQuantFloat,
      RGBQuant: () => RGBQuant,
      WuColorCube: () => WuColorCube,
      WuQuant: () => WuQuant
    });
    var AbstractPaletteQuantizer = class {
      quantizeSync() {
        for (const value2 of this.quantize()) {
          if (value2.palette) {
            return value2.palette;
          }
        }
        throw new Error("unreachable");
      }
    };
    var Point = class {
      constructor() {
        __publicField(this, "r");
        __publicField(this, "g");
        __publicField(this, "b");
        __publicField(this, "a");
        __publicField(this, "uint32");
        __publicField(this, "rgba");
        this.uint32 = -1 >>> 0;
        this.r = this.g = this.b = this.a = 0;
        this.rgba = new Array(4);
        this.rgba[0] = 0;
        this.rgba[1] = 0;
        this.rgba[2] = 0;
        this.rgba[3] = 0;
      }
      static createByQuadruplet(quadruplet) {
        const point = new Point();
        point.r = quadruplet[0] | 0;
        point.g = quadruplet[1] | 0;
        point.b = quadruplet[2] | 0;
        point.a = quadruplet[3] | 0;
        point._loadUINT32();
        point._loadQuadruplet();
        return point;
      }
      static createByRGBA(red, green, blue, alpha) {
        const point = new Point();
        point.r = red | 0;
        point.g = green | 0;
        point.b = blue | 0;
        point.a = alpha | 0;
        point._loadUINT32();
        point._loadQuadruplet();
        return point;
      }
      static createByUint32(uint32) {
        const point = new Point();
        point.uint32 = uint32 >>> 0;
        point._loadRGBA();
        point._loadQuadruplet();
        return point;
      }
      from(point) {
        this.r = point.r;
        this.g = point.g;
        this.b = point.b;
        this.a = point.a;
        this.uint32 = point.uint32;
        this.rgba[0] = point.r;
        this.rgba[1] = point.g;
        this.rgba[2] = point.b;
        this.rgba[3] = point.a;
      }
      getLuminosity(useAlphaChannel) {
        let r = this.r;
        let g = this.g;
        let b = this.b;
        if (useAlphaChannel) {
          r = Math.min(255, 255 - this.a + this.a * r / 255);
          g = Math.min(255, 255 - this.a + this.a * g / 255);
          b = Math.min(255, 255 - this.a + this.a * b / 255);
        }
        return r * 0.2126 + g * 0.7152 + b * 0.0722;
      }
      _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
      }
      _loadRGBA() {
        this.r = this.uint32 & 255;
        this.g = this.uint32 >>> 8 & 255;
        this.b = this.uint32 >>> 16 & 255;
        this.a = this.uint32 >>> 24 & 255;
      }
      _loadQuadruplet() {
        this.rgba[0] = this.r;
        this.rgba[1] = this.g;
        this.rgba[2] = this.b;
        this.rgba[3] = this.a;
      }
    };
    var PointContainer = class {
      constructor() {
        __publicField(this, "_pointArray");
        __publicField(this, "_width");
        __publicField(this, "_height");
        this._width = 0;
        this._height = 0;
        this._pointArray = [];
      }
      getWidth() {
        return this._width;
      }
      getHeight() {
        return this._height;
      }
      setWidth(width) {
        this._width = width;
      }
      setHeight(height) {
        this._height = height;
      }
      getPointArray() {
        return this._pointArray;
      }
      clone() {
        const clone = new PointContainer();
        clone._width = this._width;
        clone._height = this._height;
        for (let i2 = 0, l = this._pointArray.length; i2 < l; i2++) {
          clone._pointArray[i2] = Point.createByUint32(this._pointArray[i2].uint32 | 0);
        }
        return clone;
      }
      toUint32Array() {
        const l = this._pointArray.length;
        const uint32Array = new Uint32Array(l);
        for (let i2 = 0; i2 < l; i2++) {
          uint32Array[i2] = this._pointArray[i2].uint32;
        }
        return uint32Array;
      }
      toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
      }
      static fromHTMLImageElement(img) {
        const width = img.naturalWidth;
        const height = img.naturalHeight;
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
        return PointContainer.fromHTMLCanvasElement(canvas);
      }
      static fromHTMLCanvasElement(canvas) {
        const width = canvas.width;
        const height = canvas.height;
        const ctx = canvas.getContext("2d");
        const imgData = ctx.getImageData(0, 0, width, height);
        return PointContainer.fromImageData(imgData);
      }
      static fromImageData(imageData) {
        const width = imageData.width;
        const height = imageData.height;
        return PointContainer.fromUint8Array(imageData.data, width, height);
      }
      static fromUint8Array(uint8Array, width, height) {
        switch (Object.prototype.toString.call(uint8Array)) {
          case "[object Uint8ClampedArray]":
          case "[object Uint8Array]":
            break;
          default:
            uint8Array = new Uint8Array(uint8Array);
        }
        const uint32Array = new Uint32Array(uint8Array.buffer);
        return PointContainer.fromUint32Array(uint32Array, width, height);
      }
      static fromUint32Array(uint32Array, width, height) {
        const container = new PointContainer();
        container._width = width;
        container._height = height;
        for (let i2 = 0, l = uint32Array.length; i2 < l; i2++) {
          container._pointArray[i2] = Point.createByUint32(uint32Array[i2] | 0);
        }
        return container;
      }
      static fromBuffer(buffer, width, height) {
        const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return PointContainer.fromUint32Array(uint32Array, width, height);
      }
    };
    var hueGroups = 10;
    function hueGroup(hue, segmentsNumber) {
      const maxHue = 360;
      const seg = maxHue / segmentsNumber;
      const half = seg / 2;
      for (let i2 = 1, mid = seg - half; i2 < segmentsNumber; i2++, mid += seg) {
        if (hue >= mid && hue < mid + seg)
          return i2;
      }
      return 0;
    }
    var Palette = class {
      constructor() {
        __publicField(this, "_pointContainer");
        __publicField(this, "_pointArray", []);
        __publicField(this, "_i32idx", {});
        this._pointContainer = new PointContainer();
        this._pointContainer.setHeight(1);
        this._pointArray = this._pointContainer.getPointArray();
      }
      add(color) {
        this._pointArray.push(color);
        this._pointContainer.setWidth(this._pointArray.length);
      }
      has(color) {
        for (let i2 = this._pointArray.length - 1; i2 >= 0; i2--) {
          if (color.uint32 === this._pointArray[i2].uint32)
            return true;
        }
        return false;
      }
      getNearestColor(colorDistanceCalculator, color) {
        return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];
      }
      getPointContainer() {
        return this._pointContainer;
      }
      _nearestPointFromCache(key) {
        return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
      }
      _getNearestIndex(colorDistanceCalculator, point) {
        let idx = this._nearestPointFromCache("" + point.uint32);
        if (idx >= 0)
          return idx;
        let minimalDistance = Number.MAX_VALUE;
        idx = 0;
        for (let i2 = 0, l = this._pointArray.length; i2 < l; i2++) {
          const p = this._pointArray[i2];
          const distance2 = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
          if (distance2 < minimalDistance) {
            minimalDistance = distance2;
            idx = i2;
          }
        }
        this._i32idx[point.uint32] = idx;
        return idx;
      }
      sort() {
        this._i32idx = {};
        this._pointArray.sort((a, b) => {
          const hslA = rgb2hsl(a.r, a.g, a.b);
          const hslB = rgb2hsl(b.r, b.g, b.b);
          const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);
          const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
          const hueDiff = hueB - hueA;
          if (hueDiff)
            return -hueDiff;
          const lA = a.getLuminosity(true);
          const lB = b.getLuminosity(true);
          if (lB - lA !== 0)
            return lB - lA;
          const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
          if (satDiff)
            return -satDiff;
          return 0;
        });
      }
    };
    var utils_exports = {};
    __export(utils_exports, {
      HueStatistics: () => HueStatistics,
      Palette: () => Palette,
      Point: () => Point,
      PointContainer: () => PointContainer,
      ProgressTracker: () => ProgressTracker,
      arithmetic: () => arithmetic_exports
    });
    var HueGroup = class {
      constructor() {
        __publicField(this, "num", 0);
        __publicField(this, "cols", []);
      }
    };
    var HueStatistics = class {
      constructor(numGroups, minCols) {
        __publicField(this, "_numGroups");
        __publicField(this, "_minCols");
        __publicField(this, "_stats");
        __publicField(this, "_groupsFull");
        this._numGroups = numGroups;
        this._minCols = minCols;
        this._stats = [];
        for (let i2 = 0; i2 <= numGroups; i2++) {
          this._stats[i2] = new HueGroup();
        }
        this._groupsFull = 0;
      }
      check(i32) {
        if (this._groupsFull === this._numGroups + 1) {
          this.check = () => {
          };
        }
        const r = i32 & 255;
        const g = i32 >>> 8 & 255;
        const b = i32 >>> 16 & 255;
        const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);
        const gr = this._stats[hg];
        const min2 = this._minCols;
        gr.num++;
        if (gr.num > min2) {
          return;
        }
        if (gr.num === min2) {
          this._groupsFull++;
        }
        if (gr.num <= min2) {
          this._stats[hg].cols.push(i32);
        }
      }
      injectIntoDictionary(histG) {
        for (let i2 = 0; i2 <= this._numGroups; i2++) {
          if (this._stats[i2].num <= this._minCols) {
            this._stats[i2].cols.forEach((col) => {
              if (!histG[col]) {
                histG[col] = 1;
              } else {
                histG[col]++;
              }
            });
          }
        }
      }
      injectIntoArray(histG) {
        for (let i2 = 0; i2 <= this._numGroups; i2++) {
          if (this._stats[i2].num <= this._minCols) {
            this._stats[i2].cols.forEach((col) => {
              if (histG.indexOf(col) === -1) {
                histG.push(col);
              }
            });
          }
        }
      }
    };
    var _ProgressTracker = class {
      constructor(valueRange, progressRange) {
        __publicField(this, "progress");
        __publicField(this, "_step");
        __publicField(this, "_range");
        __publicField(this, "_last");
        __publicField(this, "_progressRange");
        this._range = valueRange;
        this._progressRange = progressRange;
        this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);
        this._last = -this._step;
        this.progress = 0;
      }
      shouldNotify(current) {
        if (current - this._last >= this._step) {
          this._last = current;
          this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);
          return true;
        }
        return false;
      }
    };
    var ProgressTracker = _ProgressTracker;
    __publicField(ProgressTracker, "steps", 100);
    var networkBiasShift = 3;
    var Neuron = class {
      constructor(defaultValue) {
        __publicField(this, "r");
        __publicField(this, "g");
        __publicField(this, "b");
        __publicField(this, "a");
        this.r = this.g = this.b = this.a = defaultValue;
      }
      toPoint() {
        return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
      }
      subtract(r, g, b, a) {
        this.r -= r | 0;
        this.g -= g | 0;
        this.b -= b | 0;
        this.a -= a | 0;
      }
    };
    var _NeuQuant = class extends AbstractPaletteQuantizer {
      constructor(colorDistanceCalculator, colors = 256) {
        super();
        __publicField(this, "_pointArray");
        __publicField(this, "_networkSize");
        __publicField(this, "_network");
        __publicField(this, "_sampleFactor");
        __publicField(this, "_radPower");
        __publicField(this, "_freq");
        __publicField(this, "_bias");
        __publicField(this, "_distance");
        this._distance = colorDistanceCalculator;
        this._pointArray = [];
        this._sampleFactor = 1;
        this._networkSize = colors;
        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
      }
      sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
      }
      *quantize() {
        this._init();
        yield* this._learn();
        yield {
          palette: this._buildPalette(),
          progress: 100
        };
      }
      _init() {
        this._freq = [];
        this._bias = [];
        this._radPower = [];
        this._network = [];
        for (let i2 = 0; i2 < this._networkSize; i2++) {
          this._network[i2] = new Neuron((i2 << networkBiasShift + 8) / this._networkSize | 0);
          this._freq[i2] = _NeuQuant._initialBias / this._networkSize | 0;
          this._bias[i2] = 0;
        }
      }
      *_learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        if (pointsNumber < _NeuQuant._minpicturebytes)
          sampleFactor = 1;
        const alphadec = 30 + (sampleFactor - 1) / 3 | 0;
        const pointsToSample = pointsNumber / sampleFactor | 0;
        let delta = pointsToSample / _NeuQuant._nCycles | 0;
        let alpha = _NeuQuant._initAlpha;
        let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;
        let rad = radius >> _NeuQuant._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let i2 = 0; i2 < rad; i2++) {
          this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        }
        let step;
        if (pointsNumber < _NeuQuant._minpicturebytes) {
          step = 1;
        } else if (pointsNumber % _NeuQuant._prime1 !== 0) {
          step = _NeuQuant._prime1;
        } else if (pointsNumber % _NeuQuant._prime2 !== 0) {
          step = _NeuQuant._prime2;
        } else if (pointsNumber % _NeuQuant._prime3 !== 0) {
          step = _NeuQuant._prime3;
        } else {
          step = _NeuQuant._prime4;
        }
        const tracker = new ProgressTracker(pointsToSample, 99);
        for (let i2 = 0, pointIndex = 0; i2 < pointsToSample; ) {
          if (tracker.shouldNotify(i2)) {
            yield {
              progress: tracker.progress
            };
          }
          const point = this._pointArray[pointIndex];
          const b = point.b << networkBiasShift;
          const g = point.g << networkBiasShift;
          const r = point.r << networkBiasShift;
          const a = point.a << networkBiasShift;
          const neuronIndex = this._contest(b, g, r, a);
          this._alterSingle(alpha, neuronIndex, b, g, r, a);
          if (rad !== 0)
            this._alterNeighbour(rad, neuronIndex, b, g, r, a);
          pointIndex += step;
          if (pointIndex >= pointsNumber)
            pointIndex -= pointsNumber;
          i2++;
          if (delta === 0)
            delta = 1;
          if (i2 % delta === 0) {
            alpha -= alpha / alphadec | 0;
            radius -= radius / _NeuQuant._radiusDecrease | 0;
            rad = radius >> _NeuQuant._radiusBiasShift;
            if (rad <= 1)
              rad = 0;
            for (let j = 0; j < rad; j++) {
              this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
            }
          }
        }
      }
      _buildPalette() {
        const palette2 = new Palette();
        this._network.forEach((neuron) => {
          palette2.add(neuron.toPoint());
        });
        palette2.sort();
        return palette2;
      }
      _alterNeighbour(rad, i2, b, g, r, al) {
        let lo = i2 - rad;
        if (lo < -1)
          lo = -1;
        let hi = i2 + rad;
        if (hi > this._networkSize)
          hi = this._networkSize;
        let j = i2 + 1;
        let k = i2 - 1;
        let m = 1;
        while (j < hi || k > lo) {
          const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
          if (j < hi) {
            const p = this._network[j++];
            p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
          }
          if (k > lo) {
            const p = this._network[k--];
            p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
          }
        }
      }
      _alterSingle(alpha, i2, b, g, r, a) {
        alpha /= _NeuQuant._initAlpha;
        const n = this._network[i2];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
      }
      _contest(b, g, r, a) {
        const multiplier = 255 * 4 << networkBiasShift;
        let bestd = ~(1 << 31);
        let bestbiasd = bestd;
        let bestpos = -1;
        let bestbiaspos = bestpos;
        for (let i2 = 0; i2 < this._networkSize; i2++) {
          const n = this._network[i2];
          const dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
          if (dist < bestd) {
            bestd = dist;
            bestpos = i2;
          }
          const biasdist = dist - (this._bias[i2] >> _NeuQuant._initialBiasShift - networkBiasShift);
          if (biasdist < bestbiasd) {
            bestbiasd = biasdist;
            bestbiaspos = i2;
          }
          const betafreq = this._freq[i2] >> _NeuQuant._betaShift;
          this._freq[i2] -= betafreq;
          this._bias[i2] += betafreq << _NeuQuant._gammaShift;
        }
        this._freq[bestpos] += _NeuQuant._beta;
        this._bias[bestpos] -= _NeuQuant._betaGamma;
        return bestbiaspos;
      }
    };
    var NeuQuant = _NeuQuant;
    __publicField(NeuQuant, "_prime1", 499);
    __publicField(NeuQuant, "_prime2", 491);
    __publicField(NeuQuant, "_prime3", 487);
    __publicField(NeuQuant, "_prime4", 503);
    __publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4);
    __publicField(NeuQuant, "_nCycles", 100);
    __publicField(NeuQuant, "_initialBiasShift", 16);
    __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift);
    __publicField(NeuQuant, "_gammaShift", 10);
    __publicField(NeuQuant, "_betaShift", 10);
    __publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift);
    __publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);
    __publicField(NeuQuant, "_radiusBiasShift", 6);
    __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift);
    __publicField(NeuQuant, "_radiusDecrease", 30);
    __publicField(NeuQuant, "_alphaBiasShift", 10);
    __publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift);
    __publicField(NeuQuant, "_radBiasShift", 8);
    __publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift);
    __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);
    __publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
    var networkBiasShift2 = 3;
    var NeuronFloat = class {
      constructor(defaultValue) {
        __publicField(this, "r");
        __publicField(this, "g");
        __publicField(this, "b");
        __publicField(this, "a");
        this.r = this.g = this.b = this.a = defaultValue;
      }
      toPoint() {
        return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
      }
      subtract(r, g, b, a) {
        this.r -= r;
        this.g -= g;
        this.b -= b;
        this.a -= a;
      }
    };
    var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
      constructor(colorDistanceCalculator, colors = 256) {
        super();
        __publicField(this, "_pointArray");
        __publicField(this, "_networkSize");
        __publicField(this, "_network");
        __publicField(this, "_sampleFactor");
        __publicField(this, "_radPower");
        __publicField(this, "_freq");
        __publicField(this, "_bias");
        __publicField(this, "_distance");
        this._distance = colorDistanceCalculator;
        this._pointArray = [];
        this._sampleFactor = 1;
        this._networkSize = colors;
        this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
      }
      sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
      }
      *quantize() {
        this._init();
        yield* this._learn();
        yield {
          palette: this._buildPalette(),
          progress: 100
        };
      }
      _init() {
        this._freq = [];
        this._bias = [];
        this._radPower = [];
        this._network = [];
        for (let i2 = 0; i2 < this._networkSize; i2++) {
          this._network[i2] = new NeuronFloat((i2 << networkBiasShift2 + 8) / this._networkSize);
          this._freq[i2] = _NeuQuantFloat._initialBias / this._networkSize;
          this._bias[i2] = 0;
        }
      }
      *_learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        if (pointsNumber < _NeuQuantFloat._minpicturebytes)
          sampleFactor = 1;
        const alphadec = 30 + (sampleFactor - 1) / 3;
        const pointsToSample = pointsNumber / sampleFactor;
        let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;
        let alpha = _NeuQuantFloat._initAlpha;
        let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;
        let rad = radius >> _NeuQuantFloat._radiusBiasShift;
        if (rad <= 1)
          rad = 0;
        for (let i2 = 0; i2 < rad; i2++) {
          this._radPower[i2] = alpha * ((rad * rad - i2 * i2) * _NeuQuantFloat._radBias / (rad * rad));
        }
        let step;
        if (pointsNumber < _NeuQuantFloat._minpicturebytes) {
          step = 1;
        } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {
          step = _NeuQuantFloat._prime1;
        } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {
          step = _NeuQuantFloat._prime2;
        } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {
          step = _NeuQuantFloat._prime3;
        } else {
          step = _NeuQuantFloat._prime4;
        }
        const tracker = new ProgressTracker(pointsToSample, 99);
        for (let i2 = 0, pointIndex = 0; i2 < pointsToSample; ) {
          if (tracker.shouldNotify(i2)) {
            yield {
              progress: tracker.progress
            };
          }
          const point = this._pointArray[pointIndex];
          const b = point.b << networkBiasShift2;
          const g = point.g << networkBiasShift2;
          const r = point.r << networkBiasShift2;
          const a = point.a << networkBiasShift2;
          const neuronIndex = this._contest(b, g, r, a);
          this._alterSingle(alpha, neuronIndex, b, g, r, a);
          if (rad !== 0)
            this._alterNeighbour(rad, neuronIndex, b, g, r, a);
          pointIndex += step;
          if (pointIndex >= pointsNumber)
            pointIndex -= pointsNumber;
          i2++;
          if (delta === 0)
            delta = 1;
          if (i2 % delta === 0) {
            alpha -= alpha / alphadec;
            radius -= radius / _NeuQuantFloat._radiusDecrease;
            rad = radius >> _NeuQuantFloat._radiusBiasShift;
            if (rad <= 1)
              rad = 0;
            for (let j = 0; j < rad; j++) {
              this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
            }
          }
        }
      }
      _buildPalette() {
        const palette2 = new Palette();
        this._network.forEach((neuron) => {
          palette2.add(neuron.toPoint());
        });
        palette2.sort();
        return palette2;
      }
      _alterNeighbour(rad, i2, b, g, r, al) {
        let lo = i2 - rad;
        if (lo < -1)
          lo = -1;
        let hi = i2 + rad;
        if (hi > this._networkSize)
          hi = this._networkSize;
        let j = i2 + 1;
        let k = i2 - 1;
        let m = 1;
        while (j < hi || k > lo) {
          const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
          if (j < hi) {
            const p = this._network[j++];
            p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
          }
          if (k > lo) {
            const p = this._network[k--];
            p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
          }
        }
      }
      _alterSingle(alpha, i2, b, g, r, a) {
        alpha /= _NeuQuantFloat._initAlpha;
        const n = this._network[i2];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
      }
      _contest(b, g, r, al) {
        const multiplier = 255 * 4 << networkBiasShift2;
        let bestd = ~(1 << 31);
        let bestbiasd = bestd;
        let bestpos = -1;
        let bestbiaspos = bestpos;
        for (let i2 = 0; i2 < this._networkSize; i2++) {
          const n = this._network[i2];
          const dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
          if (dist < bestd) {
            bestd = dist;
            bestpos = i2;
          }
          const biasdist = dist - (this._bias[i2] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
          if (biasdist < bestbiasd) {
            bestbiasd = biasdist;
            bestbiaspos = i2;
          }
          const betafreq = this._freq[i2] >> _NeuQuantFloat._betaShift;
          this._freq[i2] -= betafreq;
          this._bias[i2] += betafreq << _NeuQuantFloat._gammaShift;
        }
        this._freq[bestpos] += _NeuQuantFloat._beta;
        this._bias[bestpos] -= _NeuQuantFloat._betaGamma;
        return bestbiaspos;
      }
    };
    var NeuQuantFloat = _NeuQuantFloat;
    __publicField(NeuQuantFloat, "_prime1", 499);
    __publicField(NeuQuantFloat, "_prime2", 491);
    __publicField(NeuQuantFloat, "_prime3", 487);
    __publicField(NeuQuantFloat, "_prime4", 503);
    __publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4);
    __publicField(NeuQuantFloat, "_nCycles", 100);
    __publicField(NeuQuantFloat, "_initialBiasShift", 16);
    __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift);
    __publicField(NeuQuantFloat, "_gammaShift", 10);
    __publicField(NeuQuantFloat, "_betaShift", 10);
    __publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);
    __publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);
    __publicField(NeuQuantFloat, "_radiusBiasShift", 6);
    __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift);
    __publicField(NeuQuantFloat, "_radiusDecrease", 30);
    __publicField(NeuQuantFloat, "_alphaBiasShift", 10);
    __publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift);
    __publicField(NeuQuantFloat, "_radBiasShift", 8);
    __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift);
    __publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);
    __publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
    var _ColorHistogram = class {
      constructor(method, colors) {
        __publicField(this, "_method");
        __publicField(this, "_hueStats");
        __publicField(this, "_histogram");
        __publicField(this, "_initColors");
        __publicField(this, "_minHueCols");
        this._method = method;
        this._minHueCols = colors << 2;
        this._initColors = colors << 2;
        this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);
        this._histogram = /* @__PURE__ */ Object.create(null);
      }
      sample(pointContainer) {
        switch (this._method) {
          case 1:
            this._colorStats1D(pointContainer);
            break;
          case 2:
            this._colorStats2D(pointContainer);
            break;
        }
      }
      getImportanceSortedColorsIDXI32() {
        const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);
        if (sorted.length === 0) {
          return [];
        }
        let idxi32;
        switch (this._method) {
          case 1:
            const initialColorsLimit = Math.min(sorted.length, this._initColors);
            const last = sorted[initialColorsLimit - 1];
            const freq = this._histogram[last];
            idxi32 = sorted.slice(0, initialColorsLimit);
            let pos = initialColorsLimit;
            const len = sorted.length;
            while (pos < len && this._histogram[sorted[pos]] === freq) {
              idxi32.push(sorted[pos++]);
            }
            this._hueStats.injectIntoArray(idxi32);
            break;
          case 2:
            idxi32 = sorted;
            break;
          default:
            throw new Error("Incorrect method");
        }
        return idxi32.map((v) => +v);
      }
      _colorStats1D(pointContainer) {
        const histG = this._histogram;
        const pointArray = pointContainer.getPointArray();
        const len = pointArray.length;
        for (let i2 = 0; i2 < len; i2++) {
          const col = pointArray[i2].uint32;
          this._hueStats.check(col);
          if (col in histG) {
            histG[col]++;
          } else {
            histG[col] = 1;
          }
        }
      }
      _colorStats2D(pointContainer) {
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const pointArray = pointContainer.getPointArray();
        const boxW = _ColorHistogram._boxSize[0];
        const boxH = _ColorHistogram._boxSize[1];
        const area = boxW * boxH;
        const boxes = this._makeBoxes(width, height, boxW, boxH);
        const histG = this._histogram;
        boxes.forEach((box) => {
          let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
          if (effc < 2)
            effc = 2;
          const histL = {};
          this._iterateBox(box, width, (i2) => {
            const col = pointArray[i2].uint32;
            this._hueStats.check(col);
            if (col in histG) {
              histG[col]++;
            } else if (col in histL) {
              if (++histL[col] >= effc) {
                histG[col] = histL[col];
              }
            } else {
              histL[col] = 1;
            }
          });
        });
        this._hueStats.injectIntoDictionary(histG);
      }
      _iterateBox(bbox, wid, fn) {
        const b = bbox;
        const i0 = b.y * wid + b.x;
        const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);
        const incr = wid - b.w + 1;
        let cnt = 0;
        let i2 = i0;
        do {
          fn.call(this, i2);
          i2 += ++cnt % b.w === 0 ? incr : 1;
        } while (i2 <= i1);
      }
      _makeBoxes(width, height, stepX, stepY) {
        const wrem = width % stepX;
        const hrem = height % stepY;
        const xend = width - wrem;
        const yend = height - hrem;
        const boxesArray = [];
        for (let y2 = 0; y2 < height; y2 += stepY) {
          for (let x2 = 0; x2 < width; x2 += stepX) {
            boxesArray.push({
              x: x2,
              y: y2,
              w: x2 === xend ? wrem : stepX,
              h: y2 === yend ? hrem : stepY
            });
          }
        }
        return boxesArray;
      }
    };
    var ColorHistogram = _ColorHistogram;
    __publicField(ColorHistogram, "_boxSize", [64, 64]);
    __publicField(ColorHistogram, "_boxPixels", 2);
    __publicField(ColorHistogram, "_hueGroups", 10);
    var RemovedColor = class {
      constructor(index, color, distance2) {
        __publicField(this, "index");
        __publicField(this, "color");
        __publicField(this, "distance");
        this.index = index;
        this.color = color;
        this.distance = distance2;
      }
    };
    var RGBQuant = class extends AbstractPaletteQuantizer {
      constructor(colorDistanceCalculator, colors = 256, method = 2) {
        super();
        __publicField(this, "_colors");
        __publicField(this, "_initialDistance");
        __publicField(this, "_distanceIncrement");
        __publicField(this, "_histogram");
        __publicField(this, "_distance");
        this._distance = colorDistanceCalculator;
        this._colors = colors;
        this._histogram = new ColorHistogram(method, colors);
        this._initialDistance = 0.01;
        this._distanceIncrement = 5e-3;
      }
      sample(image2) {
        this._histogram.sample(image2);
      }
      *quantize() {
        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
        if (idxi32.length === 0) {
          throw new Error("No colors in image");
        }
        yield* this._buildPalette(idxi32);
      }
      *_buildPalette(idxi32) {
        const palette2 = new Palette();
        const colorArray = palette2.getPointContainer().getPointArray();
        const usageArray = new Array(idxi32.length);
        for (let i2 = 0; i2 < idxi32.length; i2++) {
          colorArray.push(Point.createByUint32(idxi32[i2]));
          usageArray[i2] = 1;
        }
        const len = colorArray.length;
        const memDist = [];
        let palLen = len;
        let thold = this._initialDistance;
        const tracker = new ProgressTracker(palLen - this._colors, 99);
        while (palLen > this._colors) {
          memDist.length = 0;
          for (let i2 = 0; i2 < len; i2++) {
            if (tracker.shouldNotify(len - palLen)) {
              yield {
                progress: tracker.progress
              };
            }
            if (usageArray[i2] === 0)
              continue;
            const pxi = colorArray[i2];
            for (let j = i2 + 1; j < len; j++) {
              if (usageArray[j] === 0)
                continue;
              const pxj = colorArray[j];
              const dist = this._distance.calculateNormalized(pxi, pxj);
              if (dist < thold) {
                memDist.push(new RemovedColor(j, pxj, dist));
                usageArray[j] = 0;
                palLen--;
              }
            }
          }
          thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
        }
        if (palLen < this._colors) {
          stableSort(memDist, (a, b) => b.distance - a.distance);
          let k = 0;
          while (palLen < this._colors && k < memDist.length) {
            const removedColor = memDist[k];
            usageArray[removedColor.index] = 1;
            palLen++;
            k++;
          }
        }
        let colors = colorArray.length;
        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
          if (usageArray[colorIndex] === 0) {
            if (colorIndex !== colors - 1) {
              colorArray[colorIndex] = colorArray[colors - 1];
            }
            --colors;
          }
        }
        colorArray.length = colors;
        palette2.sort();
        yield {
          palette: palette2,
          progress: 100
        };
      }
    };
    function createArray1D(dimension1) {
      const a = [];
      for (let k = 0; k < dimension1; k++) {
        a[k] = 0;
      }
      return a;
    }
    function createArray4D(dimension1, dimension2, dimension3, dimension4) {
      const a = new Array(dimension1);
      for (let i2 = 0; i2 < dimension1; i2++) {
        a[i2] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
          a[i2][j] = new Array(dimension3);
          for (let k = 0; k < dimension3; k++) {
            a[i2][j][k] = new Array(dimension4);
            for (let l = 0; l < dimension4; l++) {
              a[i2][j][k][l] = 0;
            }
          }
        }
      }
      return a;
    }
    function createArray3D(dimension1, dimension2, dimension3) {
      const a = new Array(dimension1);
      for (let i2 = 0; i2 < dimension1; i2++) {
        a[i2] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
          a[i2][j] = new Array(dimension3);
          for (let k = 0; k < dimension3; k++) {
            a[i2][j][k] = 0;
          }
        }
      }
      return a;
    }
    function fillArray3D(a, dimension1, dimension2, dimension3, value2) {
      for (let i2 = 0; i2 < dimension1; i2++) {
        a[i2] = [];
        for (let j = 0; j < dimension2; j++) {
          a[i2][j] = [];
          for (let k = 0; k < dimension3; k++) {
            a[i2][j][k] = value2;
          }
        }
      }
    }
    function fillArray1D(a, dimension1, value2) {
      for (let i2 = 0; i2 < dimension1; i2++) {
        a[i2] = value2;
      }
    }
    var WuColorCube = class {
      constructor() {
        __publicField(this, "redMinimum");
        __publicField(this, "redMaximum");
        __publicField(this, "greenMinimum");
        __publicField(this, "greenMaximum");
        __publicField(this, "blueMinimum");
        __publicField(this, "blueMaximum");
        __publicField(this, "volume");
        __publicField(this, "alphaMinimum");
        __publicField(this, "alphaMaximum");
      }
    };
    var _WuQuant = class extends AbstractPaletteQuantizer {
      constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
        super();
        __publicField(this, "_reds");
        __publicField(this, "_greens");
        __publicField(this, "_blues");
        __publicField(this, "_alphas");
        __publicField(this, "_sums");
        __publicField(this, "_weights");
        __publicField(this, "_momentsRed");
        __publicField(this, "_momentsGreen");
        __publicField(this, "_momentsBlue");
        __publicField(this, "_momentsAlpha");
        __publicField(this, "_moments");
        __publicField(this, "_table");
        __publicField(this, "_pixels");
        __publicField(this, "_cubes");
        __publicField(this, "_colors");
        __publicField(this, "_significantBitsPerChannel");
        __publicField(this, "_maxSideIndex");
        __publicField(this, "_alphaMaxSideIndex");
        __publicField(this, "_sideSize");
        __publicField(this, "_alphaSideSize");
        __publicField(this, "_distance");
        this._distance = colorDistanceCalculator;
        this._setQuality(significantBitsPerChannel);
        this._initialize(colors);
      }
      sample(image2) {
        const pointArray = image2.getPointArray();
        for (let i2 = 0, l = pointArray.length; i2 < l; i2++) {
          this._addColor(pointArray[i2]);
        }
        this._pixels = this._pixels.concat(pointArray);
      }
      *quantize() {
        yield* this._preparePalette();
        const palette2 = new Palette();
        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
          if (this._sums[paletteIndex] > 0) {
            const sum = this._sums[paletteIndex];
            const r = this._reds[paletteIndex] / sum;
            const g = this._greens[paletteIndex] / sum;
            const b = this._blues[paletteIndex] / sum;
            const a = this._alphas[paletteIndex] / sum;
            const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
            palette2.add(color);
          }
        }
        palette2.sort();
        yield {
          palette: palette2,
          progress: 100
        };
      }
      *_preparePalette() {
        yield* this._calculateMoments();
        let next = 0;
        const volumeVariance = createArray1D(this._colors);
        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
          if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
            volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
            volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
          } else {
            volumeVariance[next] = 0;
            cubeIndex--;
          }
          next = 0;
          let temp = volumeVariance[0];
          for (let index = 1; index <= cubeIndex; ++index) {
            if (volumeVariance[index] > temp) {
              temp = volumeVariance[index];
              next = index;
            }
          }
          if (temp <= 0) {
            this._colors = cubeIndex + 1;
            break;
          }
        }
        const lookupRed = [];
        const lookupGreen = [];
        const lookupBlue = [];
        const lookupAlpha = [];
        for (let k = 0; k < this._colors; ++k) {
          const weight = _WuQuant._volume(this._cubes[k], this._weights);
          if (weight > 0) {
            lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;
            lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;
            lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;
            lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
          } else {
            lookupRed[k] = 0;
            lookupGreen[k] = 0;
            lookupBlue[k] = 0;
            lookupAlpha[k] = 0;
          }
        }
        this._reds = createArray1D(this._colors + 1);
        this._greens = createArray1D(this._colors + 1);
        this._blues = createArray1D(this._colors + 1);
        this._alphas = createArray1D(this._colors + 1);
        this._sums = createArray1D(this._colors + 1);
        for (let index = 0, l = this._pixels.length; index < l; index++) {
          const color = this._pixels[index];
          const match = -1;
          let bestMatch = match;
          let bestDistance = Number.MAX_VALUE;
          for (let lookup = 0; lookup < this._colors; lookup++) {
            const foundRed = lookupRed[lookup];
            const foundGreen = lookupGreen[lookup];
            const foundBlue = lookupBlue[lookup];
            const foundAlpha = lookupAlpha[lookup];
            const distance2 = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
            if (distance2 < bestDistance) {
              bestDistance = distance2;
              bestMatch = lookup;
            }
          }
          this._reds[bestMatch] += color.r;
          this._greens[bestMatch] += color.g;
          this._blues[bestMatch] += color.b;
          this._alphas[bestMatch] += color.a;
          this._sums[bestMatch]++;
        }
      }
      _addColor(color) {
        const bitsToRemove = 8 - this._significantBitsPerChannel;
        const indexRed = (color.r >> bitsToRemove) + 1;
        const indexGreen = (color.g >> bitsToRemove) + 1;
        const indexBlue = (color.b >> bitsToRemove) + 1;
        const indexAlpha = (color.a >> bitsToRemove) + 1;
        this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
        this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
        this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
        this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
        this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
        this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
      }
      *_calculateMoments() {
        const area = [];
        const areaRed = [];
        const areaGreen = [];
        const areaBlue = [];
        const areaAlpha = [];
        const area2 = [];
        const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        let trackerProgress = 0;
        const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
          fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
          fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
          fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
          fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
          fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
          fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
          for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
            if (tracker.shouldNotify(trackerProgress)) {
              yield {
                progress: tracker.progress
              };
            }
            fillArray1D(area, this._sideSize, 0);
            fillArray1D(areaRed, this._sideSize, 0);
            fillArray1D(areaGreen, this._sideSize, 0);
            fillArray1D(areaBlue, this._sideSize, 0);
            fillArray1D(areaAlpha, this._sideSize, 0);
            fillArray1D(area2, this._sideSize, 0);
            for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
              let line = 0;
              let lineRed = 0;
              let lineGreen = 0;
              let lineBlue = 0;
              let lineAlpha = 0;
              let line2 = 0;
              for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
                line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
                lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
                lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
                lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
                lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
                line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
                area[blueIndex] += line;
                areaRed[blueIndex] += lineRed;
                areaGreen[blueIndex] += lineGreen;
                areaBlue[blueIndex] += lineBlue;
                areaAlpha[blueIndex] += lineAlpha;
                area2[blueIndex] += line2;
                xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
                xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
                xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
                xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
                xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
                xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
                this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
                this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
                this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
                this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
                this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
                this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
              }
            }
          }
        }
      }
      static _volumeFloat(cube, moment) {
        return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
      }
      static _volume(cube, moment) {
        return _WuQuant._volumeFloat(cube, moment) | 0;
      }
      static _top(cube, direction, position, moment) {
        let result;
        switch (direction) {
          case _WuQuant._alpha:
            result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            break;
          case _WuQuant._red:
            result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
            break;
          case _WuQuant._green:
            result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
            break;
          case _WuQuant._blue:
            result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
            break;
          default:
            throw new Error("impossible");
        }
        return result | 0;
      }
      static _bottom(cube, direction, moment) {
        switch (direction) {
          case _WuQuant._alpha:
            return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          case _WuQuant._red:
            return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          case _WuQuant._green:
            return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          case _WuQuant._blue:
            return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
          default:
            return 0;
        }
      }
      _calculateVariance(cube) {
        const volumeRed = _WuQuant._volume(cube, this._momentsRed);
        const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);
        const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);
        const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
        const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);
        const volumeWeight = _WuQuant._volume(cube, this._weights);
        const distance2 = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
        return volumeMoment - distance2 / volumeWeight;
      }
      _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
        const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;
        const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;
        const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;
        const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;
        const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;
        let result = 0;
        let cutPosition = -1;
        for (let position = first; position < last; ++position) {
          let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);
          let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);
          let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);
          let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);
          let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
          if (halfWeight !== 0) {
            let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
            let temp = halfDistance / halfWeight;
            halfRed = wholeRed - halfRed;
            halfGreen = wholeGreen - halfGreen;
            halfBlue = wholeBlue - halfBlue;
            halfAlpha = wholeAlpha - halfAlpha;
            halfWeight = wholeWeight - halfWeight;
            if (halfWeight !== 0) {
              halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
              temp += halfDistance / halfWeight;
              if (temp > result) {
                result = temp;
                cutPosition = position;
              }
            }
          }
        }
        return { max: result, position: cutPosition };
      }
      _cut(first, second) {
        let direction;
        const wholeRed = _WuQuant._volume(first, this._momentsRed);
        const wholeGreen = _WuQuant._volume(first, this._momentsGreen);
        const wholeBlue = _WuQuant._volume(first, this._momentsBlue);
        const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);
        const wholeWeight = _WuQuant._volume(first, this._weights);
        const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
          direction = _WuQuant._alpha;
          if (alpha.position < 0)
            return false;
        } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
          direction = _WuQuant._red;
        } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
          direction = _WuQuant._green;
        } else {
          direction = _WuQuant._blue;
        }
        second.redMaximum = first.redMaximum;
        second.greenMaximum = first.greenMaximum;
        second.blueMaximum = first.blueMaximum;
        second.alphaMaximum = first.alphaMaximum;
        switch (direction) {
          case _WuQuant._red:
            second.redMinimum = first.redMaximum = red.position;
            second.greenMinimum = first.greenMinimum;
            second.blueMinimum = first.blueMinimum;
            second.alphaMinimum = first.alphaMinimum;
            break;
          case _WuQuant._green:
            second.greenMinimum = first.greenMaximum = green.position;
            second.redMinimum = first.redMinimum;
            second.blueMinimum = first.blueMinimum;
            second.alphaMinimum = first.alphaMinimum;
            break;
          case _WuQuant._blue:
            second.blueMinimum = first.blueMaximum = blue.position;
            second.redMinimum = first.redMinimum;
            second.greenMinimum = first.greenMinimum;
            second.alphaMinimum = first.alphaMinimum;
            break;
          case _WuQuant._alpha:
            second.alphaMinimum = first.alphaMaximum = alpha.position;
            second.blueMinimum = first.blueMinimum;
            second.redMinimum = first.redMinimum;
            second.greenMinimum = first.greenMinimum;
            break;
        }
        first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
        return true;
      }
      _initialize(colors) {
        this._colors = colors;
        this._cubes = [];
        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
          this._cubes[cubeIndex] = new WuColorCube();
        }
        this._cubes[0].redMinimum = 0;
        this._cubes[0].greenMinimum = 0;
        this._cubes[0].blueMinimum = 0;
        this._cubes[0].alphaMinimum = 0;
        this._cubes[0].redMaximum = this._maxSideIndex;
        this._cubes[0].greenMaximum = this._maxSideIndex;
        this._cubes[0].blueMaximum = this._maxSideIndex;
        this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
        this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
        this._table = [];
        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {
          this._table[tableIndex] = tableIndex * tableIndex;
        }
        this._pixels = [];
      }
      _setQuality(significantBitsPerChannel = 5) {
        this._significantBitsPerChannel = significantBitsPerChannel;
        this._maxSideIndex = 1 << this._significantBitsPerChannel;
        this._alphaMaxSideIndex = this._maxSideIndex;
        this._sideSize = this._maxSideIndex + 1;
        this._alphaSideSize = this._alphaMaxSideIndex + 1;
      }
    };
    var WuQuant = _WuQuant;
    __publicField(WuQuant, "_alpha", 3);
    __publicField(WuQuant, "_red", 2);
    __publicField(WuQuant, "_green", 1);
    __publicField(WuQuant, "_blue", 0);
    var image_exports = {};
    __export(image_exports, {
      AbstractImageQuantizer: () => AbstractImageQuantizer,
      ErrorDiffusionArray: () => ErrorDiffusionArray,
      ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
      ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
      NearestColor: () => NearestColor
    });
    var AbstractImageQuantizer = class {
      quantizeSync(pointContainer, palette2) {
        for (const value2 of this.quantize(pointContainer, palette2)) {
          if (value2.pointContainer) {
            return value2.pointContainer;
          }
        }
        throw new Error("unreachable");
      }
    };
    var NearestColor = class extends AbstractImageQuantizer {
      constructor(colorDistanceCalculator) {
        super();
        __publicField(this, "_distance");
        this._distance = colorDistanceCalculator;
      }
      *quantize(pointContainer, palette2) {
        const pointArray = pointContainer.getPointArray();
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const tracker = new ProgressTracker(height, 99);
        for (let y2 = 0; y2 < height; y2++) {
          if (tracker.shouldNotify(y2)) {
            yield {
              progress: tracker.progress
            };
          }
          for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
            const point = pointArray[idx];
            point.from(palette2.getNearestColor(this._distance, point));
          }
        }
        yield {
          pointContainer,
          progress: 100
        };
      }
    };
    var ErrorDiffusionArrayKernel = /* @__PURE__ */ ((ErrorDiffusionArrayKernel2) => {
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
      ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
      return ErrorDiffusionArrayKernel2;
    })(ErrorDiffusionArrayKernel || {});
    var ErrorDiffusionArray = class extends AbstractImageQuantizer {
      constructor(colorDistanceCalculator, kernel, serpentine = true, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = false) {
        super();
        __publicField(this, "_minColorDistance");
        __publicField(this, "_serpentine");
        __publicField(this, "_kernel");
        __publicField(this, "_calculateErrorLikeGIMP");
        __publicField(this, "_distance");
        this._setKernel(kernel);
        this._distance = colorDistanceCalculator;
        this._minColorDistance = minimumColorDistanceToDither;
        this._serpentine = serpentine;
        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
      }
      *quantize(pointContainer, palette2) {
        const pointArray = pointContainer.getPointArray();
        const originalPoint = new Point();
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const errorLines = [];
        let dir = 1;
        let maxErrorLines = 1;
        for (const kernel of this._kernel) {
          const kernelErrorLines = kernel[2] + 1;
          if (maxErrorLines < kernelErrorLines)
            maxErrorLines = kernelErrorLines;
        }
        for (let i2 = 0; i2 < maxErrorLines; i2++) {
          this._fillErrorLine(errorLines[i2] = [], width);
        }
        const tracker = new ProgressTracker(height, 99);
        for (let y2 = 0; y2 < height; y2++) {
          if (tracker.shouldNotify(y2)) {
            yield {
              progress: tracker.progress
            };
          }
          if (this._serpentine)
            dir *= -1;
          const lni = y2 * width;
          const xStart = dir === 1 ? 0 : width - 1;
          const xEnd = dir === 1 ? width : -1;
          this._fillErrorLine(errorLines[0], width);
          errorLines.push(errorLines.shift());
          const errorLine = errorLines[0];
          for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
            const point = pointArray[idx];
            const error = errorLine[x2];
            originalPoint.from(point);
            const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));
            const palettePoint = palette2.getNearestColor(this._distance, correctedPoint);
            point.from(palettePoint);
            if (this._minColorDistance) {
              const dist = this._distance.calculateNormalized(originalPoint, palettePoint);
              if (dist < this._minColorDistance)
                continue;
            }
            let er;
            let eg;
            let eb;
            let ea;
            if (this._calculateErrorLikeGIMP) {
              er = correctedPoint.r - palettePoint.r;
              eg = correctedPoint.g - palettePoint.g;
              eb = correctedPoint.b - palettePoint.b;
              ea = correctedPoint.a - palettePoint.a;
            } else {
              er = originalPoint.r - palettePoint.r;
              eg = originalPoint.g - palettePoint.g;
              eb = originalPoint.b - palettePoint.b;
              ea = originalPoint.a - palettePoint.a;
            }
            const dStart = dir === 1 ? 0 : this._kernel.length - 1;
            const dEnd = dir === 1 ? this._kernel.length : -1;
            for (let i2 = dStart; i2 !== dEnd; i2 += dir) {
              const x1 = this._kernel[i2][1] * dir;
              const y1 = this._kernel[i2][2];
              if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
                const d = this._kernel[i2][0];
                const e = errorLines[y1][x1 + x2];
                e[0] += er * d;
                e[1] += eg * d;
                e[2] += eb * d;
                e[3] += ea * d;
              }
            }
          }
        }
        yield {
          pointContainer,
          progress: 100
        };
      }
      _fillErrorLine(errorLine, width) {
        if (errorLine.length > width) {
          errorLine.length = width;
        }
        const l = errorLine.length;
        for (let i2 = 0; i2 < l; i2++) {
          const error = errorLine[i2];
          error[0] = error[1] = error[2] = error[3] = 0;
        }
        for (let i2 = l; i2 < width; i2++) {
          errorLine[i2] = [0, 0, 0, 0];
        }
      }
      _setKernel(kernel) {
        switch (kernel) {
          case 0:
            this._kernel = [
              [7 / 16, 1, 0],
              [3 / 16, -1, 1],
              [5 / 16, 0, 1],
              [1 / 16, 1, 1]
            ];
            break;
          case 1:
            this._kernel = [
              [3 / 8, 1, 0],
              [3 / 8, 0, 1],
              [2 / 8, 1, 1]
            ];
            break;
          case 2:
            this._kernel = [
              [8 / 42, 1, 0],
              [4 / 42, 2, 0],
              [2 / 42, -2, 1],
              [4 / 42, -1, 1],
              [8 / 42, 0, 1],
              [4 / 42, 1, 1],
              [2 / 42, 2, 1],
              [1 / 42, -2, 2],
              [2 / 42, -1, 2],
              [4 / 42, 0, 2],
              [2 / 42, 1, 2],
              [1 / 42, 2, 2]
            ];
            break;
          case 3:
            this._kernel = [
              [1 / 8, 1, 0],
              [1 / 8, 2, 0],
              [1 / 8, -1, 1],
              [1 / 8, 0, 1],
              [1 / 8, 1, 1],
              [1 / 8, 0, 2]
            ];
            break;
          case 4:
            this._kernel = [
              [7 / 48, 1, 0],
              [5 / 48, 2, 0],
              [3 / 48, -2, 1],
              [5 / 48, -1, 1],
              [7 / 48, 0, 1],
              [5 / 48, 1, 1],
              [3 / 48, 2, 1],
              [1 / 48, -2, 2],
              [3 / 48, -1, 2],
              [5 / 48, 0, 2],
              [3 / 48, 1, 2],
              [1 / 48, 2, 2]
            ];
            break;
          case 5:
            this._kernel = [
              [8 / 32, 1, 0],
              [4 / 32, 2, 0],
              [2 / 32, -2, 1],
              [4 / 32, -1, 1],
              [8 / 32, 0, 1],
              [4 / 32, 1, 1],
              [2 / 32, 2, 1]
            ];
            break;
          case 6:
            this._kernel = [
              [5 / 32, 1, 0],
              [3 / 32, 2, 0],
              [2 / 32, -2, 1],
              [4 / 32, -1, 1],
              [5 / 32, 0, 1],
              [4 / 32, 1, 1],
              [2 / 32, 2, 1],
              [2 / 32, -1, 2],
              [3 / 32, 0, 2],
              [2 / 32, 1, 2]
            ];
            break;
          case 7:
            this._kernel = [
              [4 / 16, 1, 0],
              [3 / 16, 2, 0],
              [1 / 16, -2, 1],
              [2 / 16, -1, 1],
              [3 / 16, 0, 1],
              [2 / 16, 1, 1],
              [1 / 16, 2, 1]
            ];
            break;
          case 8:
            this._kernel = [
              [2 / 4, 1, 0],
              [1 / 4, -1, 1],
              [1 / 4, 0, 1]
            ];
            break;
          default:
            throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
        }
      }
    };
    function* hilbertCurve(width, height, callback) {
      const maxBound = Math.max(width, height);
      const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);
      const tracker = new ProgressTracker(width * height, 99);
      const data = {
        width,
        height,
        level,
        callback,
        tracker,
        index: 0,
        x: 0,
        y: 0
      };
      yield* walkHilbert(
        data,
        1
        /* UP */
      );
      visit(
        data,
        0
        /* NONE */
      );
    }
    function* walkHilbert(data, direction) {
      if (data.level < 1)
        return;
      if (data.tracker.shouldNotify(data.index)) {
        yield { progress: data.tracker.progress };
      }
      data.level--;
      switch (direction) {
        case 2:
          yield* walkHilbert(
            data,
            1
            /* UP */
          );
          visit(
            data,
            3
            /* RIGHT */
          );
          yield* walkHilbert(
            data,
            2
            /* LEFT */
          );
          visit(
            data,
            4
            /* DOWN */
          );
          yield* walkHilbert(
            data,
            2
            /* LEFT */
          );
          visit(
            data,
            2
            /* LEFT */
          );
          yield* walkHilbert(
            data,
            4
            /* DOWN */
          );
          break;
        case 3:
          yield* walkHilbert(
            data,
            4
            /* DOWN */
          );
          visit(
            data,
            2
            /* LEFT */
          );
          yield* walkHilbert(
            data,
            3
            /* RIGHT */
          );
          visit(
            data,
            1
            /* UP */
          );
          yield* walkHilbert(
            data,
            3
            /* RIGHT */
          );
          visit(
            data,
            3
            /* RIGHT */
          );
          yield* walkHilbert(
            data,
            1
            /* UP */
          );
          break;
        case 1:
          yield* walkHilbert(
            data,
            2
            /* LEFT */
          );
          visit(
            data,
            4
            /* DOWN */
          );
          yield* walkHilbert(
            data,
            1
            /* UP */
          );
          visit(
            data,
            3
            /* RIGHT */
          );
          yield* walkHilbert(
            data,
            1
            /* UP */
          );
          visit(
            data,
            1
            /* UP */
          );
          yield* walkHilbert(
            data,
            3
            /* RIGHT */
          );
          break;
        case 4:
          yield* walkHilbert(
            data,
            3
            /* RIGHT */
          );
          visit(
            data,
            1
            /* UP */
          );
          yield* walkHilbert(
            data,
            4
            /* DOWN */
          );
          visit(
            data,
            2
            /* LEFT */
          );
          yield* walkHilbert(
            data,
            4
            /* DOWN */
          );
          visit(
            data,
            4
            /* DOWN */
          );
          yield* walkHilbert(
            data,
            2
            /* LEFT */
          );
          break;
        default:
          break;
      }
      data.level++;
    }
    function visit(data, direction) {
      if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {
        data.callback(data.x, data.y);
        data.index++;
      }
      switch (direction) {
        case 2:
          data.x--;
          break;
        case 3:
          data.x++;
          break;
        case 1:
          data.y--;
          break;
        case 4:
          data.y++;
          break;
      }
    }
    var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
      constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
        super();
        __publicField(this, "_distance");
        __publicField(this, "_weights");
        __publicField(this, "_errorQueueSize");
        this._distance = colorDistanceCalculator;
        this._errorQueueSize = errorQueueSize;
        this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
      }
      *quantize(pointContainer, palette2) {
        const pointArray = pointContainer.getPointArray();
        const width = pointContainer.getWidth();
        const height = pointContainer.getHeight();
        const errorQueue = [];
        let head = 0;
        for (let i2 = 0; i2 < this._errorQueueSize; i2++) {
          errorQueue[i2] = { r: 0, g: 0, b: 0, a: 0 };
        }
        yield* hilbertCurve(width, height, (x2, y2) => {
          const p = pointArray[x2 + y2 * width];
          let { r, g, b, a } = p;
          for (let i2 = 0; i2 < this._errorQueueSize; i2++) {
            const weight = this._weights[i2];
            const e = errorQueue[(i2 + head) % this._errorQueueSize];
            r += e.r * weight;
            g += e.g * weight;
            b += e.b * weight;
            a += e.a * weight;
          }
          const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));
          const quantizedPoint = palette2.getNearestColor(this._distance, correctedPoint);
          head = (head + 1) % this._errorQueueSize;
          const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
          errorQueue[tail].r = p.r - quantizedPoint.r;
          errorQueue[tail].g = p.g - quantizedPoint.g;
          errorQueue[tail].b = p.b - quantizedPoint.b;
          errorQueue[tail].a = p.a - quantizedPoint.a;
          p.from(quantizedPoint);
        });
        yield {
          pointContainer,
          progress: 100
        };
      }
      static _createWeights(errorPropagation, errorQueueSize) {
        const weights = [];
        const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
        for (let i2 = 0, next = 1; i2 < errorQueueSize; i2++) {
          weights[i2] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;
          next *= multiplier;
        }
        return weights;
      }
    };
    var quality_exports = {};
    __export(quality_exports, {
      ssim: () => ssim
    });
    var K1 = 0.01;
    var K2 = 0.03;
    function ssim(image1, image2) {
      if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
        throw new Error("Images have different sizes!");
      }
      const bitsPerComponent = 8;
      const L = (1 << bitsPerComponent) - 1;
      const c1 = (K1 * L) ** 2;
      const c2 = (K2 * L) ** 2;
      let numWindows = 0;
      let mssim = 0;
      iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
        let sigxy = 0;
        let sigsqx = 0;
        let sigsqy = 0;
        for (let i2 = 0; i2 < lumaValues1.length; i2++) {
          sigsqx += (lumaValues1[i2] - averageLumaValue1) ** 2;
          sigsqy += (lumaValues2[i2] - averageLumaValue2) ** 2;
          sigxy += (lumaValues1[i2] - averageLumaValue1) * (lumaValues2[i2] - averageLumaValue2);
        }
        const numPixelsInWin = lumaValues1.length - 1;
        sigsqx /= numPixelsInWin;
        sigsqy /= numPixelsInWin;
        sigxy /= numPixelsInWin;
        const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
        const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);
        const ssim2 = numerator / denominator;
        mssim += ssim2;
        numWindows++;
      });
      return mssim / numWindows;
    }
    function iterate(image1, image2, callback) {
      const windowSize = 8;
      const width = image1.getWidth();
      const height = image1.getHeight();
      for (let y2 = 0; y2 < height; y2 += windowSize) {
        for (let x2 = 0; x2 < width; x2 += windowSize) {
          const windowWidth = Math.min(windowSize, width - x2);
          const windowHeight = Math.min(windowSize, height - y2);
          const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);
          const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
          const averageLuma1 = calculateAverageLuma(lumaValues1);
          const averageLuma2 = calculateAverageLuma(lumaValues2);
          callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
        }
      }
    }
    function calculateLumaValuesForWindow(image2, x2, y2, width, height) {
      const pointArray = image2.getPointArray();
      const lumaValues = [];
      let counter = 0;
      for (let j = y2; j < y2 + height; j++) {
        const offset = j * image2.getWidth();
        for (let i2 = x2; i2 < x2 + width; i2++) {
          const point = pointArray[offset + i2];
          lumaValues[counter] = point.r * 0.2126 + point.g * 0.7152 + point.b * 0.0722;
          counter++;
        }
      }
      return lumaValues;
    }
    function calculateAverageLuma(lumaValues) {
      let sumLuma = 0;
      for (const luma of lumaValues) {
        sumLuma += luma;
      }
      return sumLuma / lumaValues.length;
    }
    var setImmediateImpl = typeof setImmediate === "function" ? setImmediate : typeof process !== "undefined" && typeof (process == null ? void 0 : process.nextTick) === "function" ? (callback) => process.nextTick(callback) : (callback) => setTimeout(callback, 0);
    function buildPaletteSync(images, {
      colorDistanceFormula,
      paletteQuantization,
      colors
    } = {}) {
      const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
      const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
      images.forEach((image2) => paletteQuantizer.sample(image2));
      return paletteQuantizer.quantizeSync();
    }
    async function buildPalette(images, {
      colorDistanceFormula,
      paletteQuantization,
      colors,
      onProgress
    } = {}) {
      return new Promise((resolve5, reject2) => {
        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
        const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);
        images.forEach((image2) => paletteQuantizer.sample(image2));
        let palette2;
        const iterator = paletteQuantizer.quantize();
        const next = () => {
          try {
            const result = iterator.next();
            if (result.done) {
              resolve5(palette2);
            } else {
              if (result.value.palette)
                palette2 = result.value.palette;
              if (onProgress)
                onProgress(result.value.progress);
              setImmediateImpl(next);
            }
          } catch (error) {
            reject2(error);
          }
        };
        setImmediateImpl(next);
      });
    }
    function applyPaletteSync(image2, palette2, { colorDistanceFormula, imageQuantization } = {}) {
      const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
      const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
      return imageQuantizer.quantizeSync(image2, palette2);
    }
    async function applyPalette(image2, palette2, {
      colorDistanceFormula,
      imageQuantization,
      onProgress
    } = {}) {
      return new Promise((resolve5, reject2) => {
        const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);
        const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);
        let outPointContainer;
        const iterator = imageQuantizer.quantize(image2, palette2);
        const next = () => {
          try {
            const result = iterator.next();
            if (result.done) {
              resolve5(outPointContainer);
            } else {
              if (result.value.pointContainer) {
                outPointContainer = result.value.pointContainer;
              }
              if (onProgress)
                onProgress(result.value.progress);
              setImmediateImpl(next);
            }
          } catch (error) {
            reject2(error);
          }
        };
        setImmediateImpl(next);
      });
    }
    function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
      switch (colorDistanceFormula) {
        case "cie94-graphic-arts":
          return new CIE94GraphicArts();
        case "cie94-textiles":
          return new CIE94Textiles();
        case "ciede2000":
          return new CIEDE2000();
        case "color-metric":
          return new CMetric();
        case "euclidean":
          return new Euclidean();
        case "euclidean-bt709":
          return new EuclideanBT709();
        case "euclidean-bt709-noalpha":
          return new EuclideanBT709NoAlpha();
        case "manhattan":
          return new Manhattan();
        case "manhattan-bt709":
          return new ManhattanBT709();
        case "manhattan-nommyde":
          return new ManhattanNommyde();
        case "pngquant":
          return new PNGQuant();
        default:
          throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
      }
    }
    function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
      switch (imageQuantization) {
        case "nearest":
          return new NearestColor(distanceCalculator);
        case "riemersma":
          return new ErrorDiffusionRiemersma(distanceCalculator);
        case "floyd-steinberg":
          return new ErrorDiffusionArray(
            distanceCalculator,
            0
            /* FloydSteinberg */
          );
        case "false-floyd-steinberg":
          return new ErrorDiffusionArray(
            distanceCalculator,
            1
            /* FalseFloydSteinberg */
          );
        case "stucki":
          return new ErrorDiffusionArray(
            distanceCalculator,
            2
            /* Stucki */
          );
        case "atkinson":
          return new ErrorDiffusionArray(
            distanceCalculator,
            3
            /* Atkinson */
          );
        case "jarvis":
          return new ErrorDiffusionArray(
            distanceCalculator,
            4
            /* Jarvis */
          );
        case "burkes":
          return new ErrorDiffusionArray(
            distanceCalculator,
            5
            /* Burkes */
          );
        case "sierra":
          return new ErrorDiffusionArray(
            distanceCalculator,
            6
            /* Sierra */
          );
        case "two-sierra":
          return new ErrorDiffusionArray(
            distanceCalculator,
            7
            /* TwoSierra */
          );
        case "sierra-lite":
          return new ErrorDiffusionArray(
            distanceCalculator,
            8
            /* SierraLite */
          );
        default:
          throw new Error(`Unknown imageQuantization ${imageQuantization}`);
      }
    }
    function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
      switch (paletteQuantization) {
        case "neuquant":
          return new NeuQuant(distanceCalculator, colors);
        case "rgbquant":
          return new RGBQuant(distanceCalculator, colors);
        case "wuquant":
          return new WuQuant(distanceCalculator, colors);
        case "neuquant-float":
          return new NeuQuantFloat(distanceCalculator, colors);
        default:
          throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
      }
    }
    module2.exports = __toCommonJS(src_exports);
  }
});

// node_modules/gifwrap/src/gifframe.js
var require_gifframe = __commonJS({
  "node_modules/gifwrap/src/gifframe.js"(exports2) {
    "use strict";
    var BitmapImage = require_bitmapimage();
    var { GifError: GifError2 } = require_gif();
    var GifFrame = class _GifFrame extends BitmapImage {
      // xOffset - x offset of bitmap on GIF (defaults to 0)
      // yOffset - y offset of bitmap on GIF (defaults to 0)
      // disposalMethod - pixel disposal method when handling partial images
      // delayCentisecs - duration of frame in hundredths of a second
      // interlaced - whether the image is interlaced (defaults to false)
      /**
       * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
       * 
       * Property | Description
       * --- | ---
       * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
       * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
       * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
       * delayCentisecs | duration of the frame in hundreths of a second
       * interlaced | boolean indicating whether the frame renders interlaced
       * 
       * Its constructor supports the following signatures:
       * 
       * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
       * * new GifFrame(bitmapImage: BitmapImage, options?)
       * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
       * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
       * * new GifFrame(frame: GifFrame)
       * 
       * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
       * 
       * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
       */
      constructor(...args) {
        super(...args);
        if (args[0] instanceof _GifFrame) {
          const source = args[0];
          this.xOffset = source.xOffset;
          this.yOffset = source.yOffset;
          this.disposalMethod = source.disposalMethod;
          this.delayCentisecs = source.delayCentisecs;
          this.interlaced = source.interlaced;
        } else {
          const lastArg = args[args.length - 1];
          let options = {};
          if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
            options = lastArg;
          }
          this.xOffset = options.xOffset || 0;
          this.yOffset = options.yOffset || 0;
          this.disposalMethod = options.disposalMethod !== void 0 ? options.disposalMethod : _GifFrame.DisposeToBackgroundColor;
          this.delayCentisecs = options.delayCentisecs || 8;
          this.interlaced = options.interlaced || false;
        }
      }
      /**
       * Get a summary of the colors found within the frame. The return value is an object of the following form:
       * 
       * Property | Description
       * --- | ---
       * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
       * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
       * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
       * 
       * @return {object} An object representing a color palette as described above.
       */
      getPalette() {
        const colorSet = /* @__PURE__ */ new Set();
        const buf = this.bitmap.data;
        let i2 = 0;
        let usesTransparency = false;
        while (i2 < buf.length) {
          if (buf[i2 + 3] === 0) {
            usesTransparency = true;
          } else {
            const color = buf.readUInt32BE(i2, true) >> 8 & 16777215;
            colorSet.add(color);
          }
          i2 += 4;
        }
        const colors = new Array(colorSet.size);
        const iter = colorSet.values();
        for (i2 = 0; i2 < colors.length; ++i2) {
          colors[i2] = iter.next().value;
        }
        colors.sort((a, b) => a - b);
        let indexCount = colors.length;
        if (usesTransparency) {
          ++indexCount;
        }
        return { colors, usesTransparency, indexCount };
      }
    };
    GifFrame.DisposeToAnything = 0;
    GifFrame.DisposeNothing = 1;
    GifFrame.DisposeToBackgroundColor = 2;
    GifFrame.DisposeToPrevious = 3;
    exports2.GifFrame = GifFrame;
  }
});

// node_modules/gifwrap/src/gifutil.js
var require_gifutil = __commonJS({
  "node_modules/gifwrap/src/gifutil.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var ImageQ = require_image_q();
    var BitmapImage = require_bitmapimage();
    var { GifFrame } = require_gifframe();
    var { GifError: GifError2 } = require_gif();
    var { GifCodec } = require_gifcodec();
    var INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
    var defaultCodec = new GifCodec();
    exports2.cloneFrames = function(frames) {
      let clones = [];
      frames.forEach((frame) => {
        clones.push(new GifFrame(frame));
      });
      return clones;
    };
    exports2.getColorInfo = function(frames, maxGlobalIndex) {
      let usesTransparency = false;
      const palettes = [];
      for (let i2 = 0; i2 < frames.length; ++i2) {
        let palette2 = frames[i2].getPalette();
        if (palette2.usesTransparency) {
          usesTransparency = true;
        }
        if (palette2.indexCount > 256) {
          throw new GifError2(`Frame ${i2} uses more than 256 color indexes`);
        }
        palettes.push(palette2);
      }
      if (maxGlobalIndex === 0) {
        return { usesTransparency, palettes };
      }
      const globalColorSet = /* @__PURE__ */ new Set();
      palettes.forEach((palette2) => {
        palette2.colors.forEach((color) => {
          globalColorSet.add(color);
        });
      });
      let indexCount = globalColorSet.size;
      if (usesTransparency) {
        ++indexCount;
      }
      if (maxGlobalIndex && indexCount > maxGlobalIndex) {
        return { usesTransparency, palettes };
      }
      const colors = new Array(globalColorSet.size);
      const iter = globalColorSet.values();
      for (let i2 = 0; i2 < colors.length; ++i2) {
        colors[i2] = iter.next().value;
      }
      colors.sort((a, b) => a - b);
      return { colors, indexCount, usesTransparency, palettes };
    };
    exports2.copyAsJimp = function(jimp2, bitmapImageToCopy) {
      return exports2.shareAsJimp(jimp2, new BitmapImage(bitmapImageToCopy));
    };
    exports2.getMaxDimensions = function(frames) {
      let maxWidth = 0, maxHeight = 0;
      frames.forEach((frame) => {
        const width = frame.xOffset + frame.bitmap.width;
        if (width > maxWidth) {
          maxWidth = width;
        }
        const height = frame.yOffset + frame.bitmap.height;
        if (height > maxHeight) {
          maxHeight = height;
        }
      });
      return { maxWidth, maxHeight };
    };
    exports2.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
    };
    exports2.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      histogram = histogram || "min-pop";
      let histogramID;
      switch (histogram) {
        case "min-pop":
          histogramID = 2;
          break;
        case "top-pop":
          histogramID = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
      }
      _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
    };
    exports2.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      significantBits = significantBits || 5;
      if (significantBits < 1 || significantBits > 8) {
        throw new Error("Invalid quantization quality");
      }
      _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
    };
    exports2.read = function(source, decoder) {
      decoder = decoder || defaultCodec;
      if (Buffer.isBuffer(source)) {
        return decoder.decodeGif(source);
      }
      return _readBinary(source).then((buffer) => {
        return decoder.decodeGif(buffer);
      });
    };
    exports2.shareAsJimp = function(jimp2, bitmapImageToShare) {
      const jimpImage = new jimp2(
        bitmapImageToShare.bitmap.width,
        bitmapImageToShare.bitmap.height,
        0
      );
      jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
      return jimpImage;
    };
    exports2.write = function(path4, frames, spec, encoder) {
      encoder = encoder || defaultCodec;
      const matches = path4.match(/\.[a-zA-Z]+$/);
      if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
        throw new Error(`GIF '${path4}' has an unexpected suffix`);
      }
      return encoder.encodeGif(frames, spec).then((gif) => {
        return _writeBinary(path4, gif.buffer).then(() => {
          return gif;
        });
      });
    };
    function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
      const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
      const ditherAlgs = [
        "FloydSteinberg",
        "FalseFloydSteinberg",
        "Stucki",
        "Atkinson",
        "Jarvis",
        "Burkes",
        "Sierra",
        "TwoSierra",
        "SierraLite"
      ];
      if (dither) {
        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
          throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
        }
        if (dither.serpentine === void 0) {
          dither.serpentine = true;
        }
        if (dither.minimumColorDistanceToDither === void 0) {
          dither.minimumColorDistanceToDither = 0;
        }
        if (dither.calculateErrorLikeGIMP === void 0) {
          dither.calculateErrorLikeGIMP = false;
        }
      }
      const distCalculator = new ImageQ.distance.Euclidean();
      const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
      let imageMaker;
      if (dither) {
        imageMaker = new ImageQ.image.ErrorDiffusionArray(
          distCalculator,
          ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm],
          dither.serpentine,
          dither.minimumColorDistanceToDither,
          dither.calculateErrorLikeGIMP
        );
      } else {
        imageMaker = new ImageQ.image.NearestColor(distCalculator);
      }
      const inputContainers = [];
      images.forEach((image2) => {
        const imageBuf = image2.bitmap.data;
        const inputBuf = new ArrayBuffer(imageBuf.length);
        const inputArray = new Uint32Array(inputBuf);
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          inputArray[ai] = imageBuf.readUInt32LE(bi, true);
        }
        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(
          inputArray,
          image2.bitmap.width,
          image2.bitmap.height
        );
        quantizer.sample(inputContainer);
        inputContainers.push(inputContainer);
      });
      const limitedPalette = quantizer.quantizeSync();
      for (let i2 = 0; i2 < images.length; ++i2) {
        const imageBuf = images[i2].bitmap.data;
        const outputContainer = imageMaker.quantizeSync(inputContainers[i2], limitedPalette);
        const outputArray = outputContainer.toUint32Array();
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          imageBuf.writeUInt32LE(outputArray[ai], bi);
        }
      }
    }
    function _readBinary(path4) {
      return new Promise((resolve5, reject2) => {
        fs.readFile(path4, (err, buffer) => {
          if (err) {
            return reject2(err);
          }
          return resolve5(buffer);
        });
      });
    }
    function _writeBinary(path4, buffer) {
      return new Promise((resolve5, reject2) => {
        fs.writeFile(path4, buffer, (err) => {
          if (err) {
            return reject2(err);
          }
          return resolve5();
        });
      });
    }
  }
});

// node_modules/gifwrap/src/gifcodec.js
var require_gifcodec = __commonJS({
  "node_modules/gifwrap/src/gifcodec.js"(exports2) {
    "use strict";
    var Omggif = require_omggif();
    var { Gif, GifError: GifError2 } = require_gif();
    function GifUtil() {
      const data = require_gifutil();
      GifUtil = function() {
        return data;
      };
      return data;
    }
    var { GifFrame } = require_gifframe();
    var PER_GIF_OVERHEAD = 200;
    var PER_FRAME_OVERHEAD = 100;
    var GifCodec = class {
      // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest
      /**
       * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
       * 
       * Instances of this class are stateless and can be shared across multiple encodings and decodings.
       * 
       * Its constructor takes one option argument:
       * 
       * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
       */
      constructor(options = {}) {
        this._transparentRGB = null;
        if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
          this._transparentRGBA = options.transparentRGB * 256;
        }
        this._testInitialBufferSize = 0;
      }
      /**
       * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
       * 
       * @param {Buffer} buffer Bytes of an encoded GIF to decode.
       * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
       * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
       */
      decodeGif(buffer) {
        try {
          let reader;
          try {
            reader = new Omggif.GifReader(buffer);
          } catch (err) {
            throw new GifError2(err);
          }
          const frameCount = reader.numFrames();
          const frames = [];
          const spec = {
            width: reader.width,
            height: reader.height,
            loops: reader.loopCount()
          };
          spec.usesTransparency = false;
          for (let i2 = 0; i2 < frameCount; ++i2) {
            const frameInfo = this._decodeFrame(reader, i2, spec.usesTransparency);
            frames.push(frameInfo.frame);
            if (frameInfo.usesTransparency) {
              spec.usesTransparency = true;
            }
          }
          return Promise.resolve(new Gif(buffer, frames, spec));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      /**
       * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
       * 
       * @param {GifFrame[]} frames Array of frames to encode
       * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely. Set `loop` to null to disable looping, playing only once. `colorScope` defaults to Gif.GlobalColorsPreferred.
       * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
       * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
       */
      encodeGif(frames, spec = {}) {
        try {
          if (frames === null || frames.length === 0) {
            throw new GifError2("there are no frames");
          }
          const dims = GifUtil().getMaxDimensions(frames);
          spec = Object.assign({}, spec);
          spec.width = dims.maxWidth;
          spec.height = dims.maxHeight;
          if (spec.loops === void 0) {
            spec.loops = 0;
          }
          spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
          return Promise.resolve(this._encodeGif(frames, spec));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
        let info, buffer;
        try {
          info = reader.frameInfo(frameIndex);
          buffer = new Buffer(reader.width * reader.height * 4);
          reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
          if (info.width !== reader.width || info.height !== reader.height) {
            if (info.y) {
              buffer = buffer.slice(info.y * reader.width * 4);
            }
            if (reader.width > info.width) {
              for (let ii = 0; ii < info.height; ++ii) {
                buffer.copy(
                  buffer,
                  ii * info.width * 4,
                  (info.x + ii * reader.width) * 4,
                  (info.x + ii * reader.width) * 4 + info.width * 4
                );
              }
            }
            buffer = buffer.slice(0, info.width * info.height * 4);
          }
        } catch (err) {
          throw new GifError2(err);
        }
        let usesTransparency = false;
        if (this._transparentRGBA === null) {
          if (!alreadyUsedTransparency) {
            for (let i2 = 3; i2 < buffer.length; i2 += 4) {
              if (buffer[i2] === 0) {
                usesTransparency = true;
                i2 = buffer.length;
              }
            }
          }
        } else {
          for (let i2 = 3; i2 < buffer.length; i2 += 4) {
            if (buffer[i2] === 0) {
              buffer.writeUInt32BE(this._transparentRGBA, i2 - 3);
              usesTransparency = true;
            }
          }
        }
        const frame = new GifFrame(info.width, info.height, buffer, {
          xOffset: info.x,
          yOffset: info.y,
          disposalMethod: info.disposal,
          interlaced: info.interlaced,
          delayCentisecs: info.delay
        });
        return { frame, usesTransparency };
      }
      _encodeGif(frames, spec) {
        let colorInfo;
        if (spec.colorScope === Gif.LocalColorsOnly) {
          colorInfo = GifUtil().getColorInfo(frames, 0);
        } else {
          colorInfo = GifUtil().getColorInfo(frames, 256);
          if (!colorInfo.colors) {
            if (spec.colorScope === Gif.GlobalColorsOnly) {
              throw new GifError2(
                "Too many color indexes for global color table"
              );
            }
            spec.colorScope = Gif.LocalColorsOnly;
          }
        }
        spec.usesTransparency = colorInfo.usesTransparency;
        const localPalettes = colorInfo.palettes;
        if (spec.colorScope === Gif.LocalColorsOnly) {
          const localSizeEst = 2e3;
          return _encodeLocal(frames, spec, localSizeEst, localPalettes);
        }
        const globalSizeEst = 2e3;
        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
      }
      _getSizeEstimateGlobal(globalPalette, frames) {
        if (this._testInitialBufferSize > 0) {
          return this._testInitialBufferSize;
        }
        let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
        const pixelBitWidth = _getPixelBitWidth(globalPalette);
        frames.forEach((frame) => {
          sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
        });
        return sizeEst;
      }
      _getSizeEstimateLocal(palettes, frames) {
        if (this._testInitialBufferSize > 0) {
          return this._testInitialBufferSize;
        }
        let sizeEst = PER_GIF_OVERHEAD;
        for (let i2 = 0; i2 < frames.length; ++i2) {
          const palette2 = palettes[i2];
          const pixelBitWidth = _getPixelBitWidth(palette2);
          sizeEst += _getFrameSizeEst(frames[i2], pixelBitWidth);
        }
        return sizeEst;
      }
    };
    exports2.GifCodec = GifCodec;
    function _colorLookupLinear(colors, color) {
      const index = colors.indexOf(color);
      return index === -1 ? null : index;
    }
    function _colorLookupBinary(colors, color) {
      var lo = 0, hi = colors.length - 1, mid;
      while (lo <= hi) {
        mid = Math.floor((lo + hi) / 2);
        if (colors[mid] > color)
          hi = mid - 1;
        else if (colors[mid] < color)
          lo = mid + 1;
        else
          return mid;
      }
      return null;
    }
    function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
      const extendedGlobalPalette = {
        colors: globalPalette.colors.slice(),
        usesTransparency: globalPalette.usesTransparency
      };
      _extendPaletteToPowerOf2(extendedGlobalPalette);
      const options = {
        palette: extendedGlobalPalette.colors,
        loop: spec.loops
      };
      let buffer = new Buffer(bufferSizeEst);
      let gifWriter;
      try {
        gifWriter = new Omggif.GifWriter(
          buffer,
          spec.width,
          spec.height,
          options
        );
      } catch (err) {
        throw new GifError2(err);
      }
      for (let i2 = 0; i2 < frames.length; ++i2) {
        buffer = _writeFrame(gifWriter, i2, frames[i2], globalPalette, false);
      }
      return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
    }
    function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
      const options = {
        loop: spec.loops
      };
      let buffer = new Buffer(bufferSizeEst);
      let gifWriter;
      try {
        gifWriter = new Omggif.GifWriter(
          buffer,
          spec.width,
          spec.height,
          options
        );
      } catch (err) {
        throw new GifError2(err);
      }
      for (let i2 = 0; i2 < frames.length; ++i2) {
        buffer = _writeFrame(gifWriter, i2, frames[i2], localPalettes[i2], true);
      }
      return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
    }
    function _extendPaletteToPowerOf2(palette2) {
      const colors = palette2.colors;
      if (palette2.usesTransparency) {
        colors.push(0);
      }
      const colorCount = colors.length;
      let powerOf2 = 2;
      while (colorCount > powerOf2) {
        powerOf2 <<= 1;
      }
      colors.length = powerOf2;
      colors.fill(0, colorCount);
    }
    function _getFrameSizeEst(frame, pixelBitWidth) {
      let byteLength = frame.bitmap.width * frame.bitmap.height;
      byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
      byteLength += Math.ceil(byteLength / 255);
      return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
    }
    function _getIndexedImage(frameIndex, frame, palette2) {
      const colors = palette2.colors;
      const colorToIndexFunc = colors.length <= 8 ? (
        // guess at the break-even
        _colorLookupLinear
      ) : _colorLookupBinary;
      const colorBuffer = frame.bitmap.data;
      const indexBuffer = new Buffer(colorBuffer.length / 4);
      let transparentIndex = colors.length;
      let i2 = 0, j = 0;
      while (i2 < colorBuffer.length) {
        if (colorBuffer[i2 + 3] !== 0) {
          const color = colorBuffer.readUInt32BE(i2, true) >> 8 & 16777215;
          indexBuffer[j] = colorToIndexFunc(colors, color);
        } else {
          indexBuffer[j] = transparentIndex;
        }
        i2 += 4;
        ++j;
      }
      if (palette2.usesTransparency) {
        if (transparentIndex === 256) {
          throw new GifError2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
        }
      } else {
        transparentIndex = null;
      }
      return { buffer: indexBuffer, transparentIndex };
    }
    function _getPixelBitWidth(palette2) {
      let indexCount = palette2.indexCount;
      let pixelBitWidth = 0;
      --indexCount;
      while (indexCount) {
        ++pixelBitWidth;
        indexCount >>= 1;
      }
      return pixelBitWidth > 0 ? pixelBitWidth : 1;
    }
    function _writeFrame(gifWriter, frameIndex, frame, palette2, isLocalPalette) {
      if (frame.interlaced) {
        throw new GifError2("writing interlaced GIFs is not supported");
      }
      const frameInfo = _getIndexedImage(frameIndex, frame, palette2);
      const options = {
        delay: frame.delayCentisecs,
        disposal: frame.disposalMethod,
        transparent: frameInfo.transparentIndex
      };
      if (isLocalPalette) {
        _extendPaletteToPowerOf2(palette2);
        options.palette = palette2.colors;
      }
      try {
        let buffer = gifWriter.getOutputBuffer();
        let startOfFrame = gifWriter.getOutputBufferPosition();
        let endOfFrame;
        let tryAgain = true;
        while (tryAgain) {
          endOfFrame = gifWriter.addFrame(
            frame.xOffset,
            frame.yOffset,
            frame.bitmap.width,
            frame.bitmap.height,
            frameInfo.buffer,
            options
          );
          tryAgain = false;
          if (endOfFrame >= buffer.length - 1) {
            const biggerBuffer = new Buffer(buffer.length * 1.5);
            buffer.copy(biggerBuffer);
            gifWriter.setOutputBuffer(biggerBuffer);
            gifWriter.setOutputBufferPosition(startOfFrame);
            buffer = biggerBuffer;
            tryAgain = true;
          }
        }
        return buffer;
      } catch (err) {
        throw new GifError2(err);
      }
    }
  }
});

// node_modules/gifwrap/src/index.js
var require_src = __commonJS({
  "node_modules/gifwrap/src/index.js"(exports2, module2) {
    "use strict";
    var BitmapImage = require_bitmapimage();
    var { Gif, GifError: GifError2 } = require_gif();
    var { GifCodec } = require_gifcodec();
    var { GifFrame } = require_gifframe();
    var GifUtil = require_gifutil();
    module2.exports = {
      BitmapImage,
      Gif,
      GifCodec,
      GifFrame,
      GifUtil,
      GifError: GifError2
    };
  }
});

// node_modules/@jimp/gif/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@jimp/gif/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _omggif = _interopRequireDefault(require_omggif());
    var _gifwrap = require_src();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MIME_TYPE = "image/gif";
    var _default = () => ({
      mime: {
        [MIME_TYPE]: ["gif"]
      },
      constants: {
        MIME_GIF: MIME_TYPE
      },
      decoders: {
        [MIME_TYPE]: (data) => {
          const gifObj = new _omggif.default.GifReader(data);
          const gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
          gifObj.decodeAndBlitFrameRGBA(0, gifData);
          return {
            data: gifData,
            width: gifObj.width,
            height: gifObj.height
          };
        }
      },
      encoders: {
        [MIME_TYPE]: (data) => {
          const bitmap = new _gifwrap.BitmapImage(data.bitmap);
          _gifwrap.GifUtil.quantizeDekker(bitmap, 256);
          const newFrame = new _gifwrap.GifFrame(bitmap);
          const gifCodec = new _gifwrap.GifCodec();
          return gifCodec.encodeGif([newFrame], {}).then((newGif) => {
            return newGif.buffer;
          });
        }
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/types/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/@jimp/types/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _timm = require_timm();
    var _jpeg = _interopRequireDefault(require_dist4());
    var _png = _interopRequireDefault(require_dist5());
    var _bmp = _interopRequireDefault(require_dist6());
    var _tiff = _interopRequireDefault(require_dist7());
    var _gif = _interopRequireDefault(require_dist8());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = () => (0, _timm.mergeDeep)((0, _jpeg.default)(), (0, _png.default)(), (0, _bmp.default)(), (0, _tiff.default)(), (0, _gif.default)());
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-blit/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@jimp/plugin-blit/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      /**
       * Blits a source image on to this image
       * @param {Jimp} src the source Jimp instance
       * @param {number} x the x position to blit the image
       * @param {number} y the y position to blit the image
       * @param {number} srcx (optional) the x position from which to crop the source image
       * @param {number} srcy (optional) the y position from which to crop the source image
       * @param {number} srcw (optional) the width to which to crop the source image
       * @param {number} srch (optional) the height to which to crop the source image
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      blit(src, x, y, srcx, srcy, srcw, srch, cb) {
        if (!(src instanceof this.constructor)) {
          return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        }
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        }
        if (typeof srcx === "function") {
          cb = srcx;
          srcx = 0;
          srcy = 0;
          srcw = src.bitmap.width;
          srch = src.bitmap.height;
        } else if (typeof srcx === typeof srcy && typeof srcy === typeof srcw && typeof srcw === typeof srch) {
          srcx = srcx || 0;
          srcy = srcy || 0;
          srcw = srcw || src.bitmap.width;
          srch = srch || src.bitmap.height;
        } else {
          return _utils.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
        }
        x = Math.round(x);
        y = Math.round(y);
        srcx = Math.round(srcx);
        srcy = Math.round(srcy);
        srcw = Math.round(srcw);
        srch = Math.round(srch);
        const maxWidth = this.bitmap.width;
        const maxHeight = this.bitmap.height;
        const baseImage = this;
        src.scanQuiet(srcx, srcy, srcw, srch, function(sx, sy, idx) {
          const xOffset = x + sx - srcx;
          const yOffset = y + sy - srcy;
          if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
            const dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
            const src2 = {
              r: this.bitmap.data[idx],
              g: this.bitmap.data[idx + 1],
              b: this.bitmap.data[idx + 2],
              a: this.bitmap.data[idx + 3]
            };
            const dst = {
              r: baseImage.bitmap.data[dstIdx],
              g: baseImage.bitmap.data[dstIdx + 1],
              b: baseImage.bitmap.data[dstIdx + 2],
              a: baseImage.bitmap.data[dstIdx + 3]
            };
            baseImage.bitmap.data[dstIdx] = (src2.a * (src2.r - dst.r) - dst.r + 255 >> 8) + dst.r;
            baseImage.bitmap.data[dstIdx + 1] = (src2.a * (src2.g - dst.g) - dst.g + 255 >> 8) + dst.g;
            baseImage.bitmap.data[dstIdx + 2] = (src2.a * (src2.b - dst.b) - dst.b + 255 >> 8) + dst.b;
            baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + src2.a);
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-blur/dist/blur-tables.js
var require_blur_tables = __commonJS({
  "node_modules/@jimp/plugin-blur/dist/blur-tables.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.shgTable = exports2.mulTable = void 0;
    var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
    exports2.mulTable = mulTable;
    var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
    exports2.shgTable = shgTable;
  }
});

// node_modules/@jimp/plugin-blur/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@jimp/plugin-blur/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _blurTables = require_blur_tables();
    var _default = () => ({
      /**
       * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
       * @param {number} r the pixel radius of the blur
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      blur(r, cb) {
        if (typeof r !== "number")
          return _utils.throwError.call(this, "r must be a number", cb);
        if (r < 1)
          return _utils.throwError.call(this, "r must be greater than 0", cb);
        let rsum;
        let gsum;
        let bsum;
        let asum;
        let x;
        let y;
        let i2;
        let p;
        let p1;
        let p2;
        let yp;
        let yi;
        let yw;
        let pa;
        const wm = this.bitmap.width - 1;
        const hm = this.bitmap.height - 1;
        const rad1 = r + 1;
        const mulSum = _blurTables.mulTable[r];
        const shgSum = _blurTables.shgTable[r];
        const red = [];
        const green = [];
        const blue = [];
        const alpha = [];
        const vmin = [];
        const vmax = [];
        let iterations = 2;
        while (iterations-- > 0) {
          yi = 0;
          yw = 0;
          for (y = 0; y < this.bitmap.height; y++) {
            rsum = this.bitmap.data[yw] * rad1;
            gsum = this.bitmap.data[yw + 1] * rad1;
            bsum = this.bitmap.data[yw + 2] * rad1;
            asum = this.bitmap.data[yw + 3] * rad1;
            for (i2 = 1; i2 <= r; i2++) {
              p = yw + ((i2 > wm ? wm : i2) << 2);
              rsum += this.bitmap.data[p++];
              gsum += this.bitmap.data[p++];
              bsum += this.bitmap.data[p++];
              asum += this.bitmap.data[p];
            }
            for (x = 0; x < this.bitmap.width; x++) {
              red[yi] = rsum;
              green[yi] = gsum;
              blue[yi] = bsum;
              alpha[yi] = asum;
              if (y === 0) {
                vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
              }
              p1 = yw + vmin[x];
              p2 = yw + vmax[x];
              rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
              gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
              bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
              asum += this.bitmap.data[p1] - this.bitmap.data[p2];
              yi++;
            }
            yw += this.bitmap.width << 2;
          }
          for (x = 0; x < this.bitmap.width; x++) {
            yp = x;
            rsum = red[yp] * rad1;
            gsum = green[yp] * rad1;
            bsum = blue[yp] * rad1;
            asum = alpha[yp] * rad1;
            for (i2 = 1; i2 <= r; i2++) {
              yp += i2 > hm ? 0 : this.bitmap.width;
              rsum += red[yp];
              gsum += green[yp];
              bsum += blue[yp];
              asum += alpha[yp];
            }
            yi = x << 2;
            for (y = 0; y < this.bitmap.height; y++) {
              pa = asum * mulSum >>> shgSum;
              this.bitmap.data[yi + 3] = pa;
              if (pa > 255) {
                this.bitmap.data[yi + 3] = 255;
              }
              if (pa > 0) {
                pa = 255 / pa;
                this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;
                this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
                this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
              } else {
                this.bitmap.data[yi + 2] = 0;
                this.bitmap.data[yi + 1] = 0;
                this.bitmap.data[yi] = 0;
              }
              if (x === 0) {
                vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;
                vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;
              }
              p1 = x + vmin[y];
              p2 = x + vmax[y];
              rsum += red[p1] - red[p2];
              gsum += green[p1] - green[p2];
              bsum += blue[p1] - blue[p2];
              asum += alpha[p1] - alpha[p2];
              yi += this.bitmap.width << 2;
            }
          }
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-circle/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@jimp/plugin-circle/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      circle() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let cb = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        const radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;
        const center = {
          x: typeof options.x === "number" ? options.x : this.bitmap.width / 2,
          y: typeof options.y === "number" ? options.y : this.bitmap.height / 2
        };
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          const curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
          if (radius - curR <= 0) {
            this.bitmap.data[idx + 3] = 0;
          } else if (radius - curR < 1) {
            this.bitmap.data[idx + 3] = 255 * (radius - curR);
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-color/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/@jimp/plugin-color/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.ColorActionName = void 0;
    var _tinycolor = _interopRequireDefault(require_tinycolor());
    var _utils = require_dist();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function applyKernel(im, kernel, x, y) {
      const value2 = [0, 0, 0];
      const size = (kernel.length - 1) / 2;
      for (let kx = 0; kx < kernel.length; kx += 1) {
        for (let ky = 0; ky < kernel[kx].length; ky += 1) {
          const idx = im.getPixelIndex(x + kx - size, y + ky - size);
          value2[0] += im.bitmap.data[idx] * kernel[kx][ky];
          value2[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];
          value2[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
        }
      }
      return value2;
    }
    var isDef = (v) => typeof v !== "undefined" && v !== null;
    function greyscale(cb) {
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        const grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
        this.bitmap.data[idx] = grey;
        this.bitmap.data[idx + 1] = grey;
        this.bitmap.data[idx + 2] = grey;
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    function mix(clr, clr2) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
      return {
        r: (clr2.r - clr.r) * (p / 100) + clr.r,
        g: (clr2.g - clr.g) * (p / 100) + clr.g,
        b: (clr2.b - clr.b) * (p / 100) + clr.b
      };
    }
    function colorFn(actions, cb) {
      if (!actions || !Array.isArray(actions)) {
        return _utils.throwError.call(this, "actions must be an array", cb);
      }
      actions = actions.map((action) => {
        if (action.apply === "xor" || action.apply === "mix") {
          action.params[0] = (0, _tinycolor.default)(action.params[0]).toRgb();
        }
        return action;
      });
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
        let clr = {
          r: this.bitmap.data[idx],
          g: this.bitmap.data[idx + 1],
          b: this.bitmap.data[idx + 2]
        };
        const colorModifier = (i2, amount) => this.constructor.limit255(clr[i2] + amount);
        actions.forEach((action) => {
          if (action.apply === "mix") {
            clr = mix(clr, action.params[0], action.params[1]);
          } else if (action.apply === "tint") {
            clr = mix(clr, {
              r: 255,
              g: 255,
              b: 255
            }, action.params[0]);
          } else if (action.apply === "shade") {
            clr = mix(clr, {
              r: 0,
              g: 0,
              b: 0
            }, action.params[0]);
          } else if (action.apply === "xor") {
            clr = {
              r: clr.r ^ action.params[0].r,
              g: clr.g ^ action.params[0].g,
              b: clr.b ^ action.params[0].b
            };
          } else if (action.apply === "red") {
            clr.r = colorModifier("r", action.params[0]);
          } else if (action.apply === "green") {
            clr.g = colorModifier("g", action.params[0]);
          } else if (action.apply === "blue") {
            clr.b = colorModifier("b", action.params[0]);
          } else {
            if (action.apply === "hue") {
              action.apply = "spin";
            }
            clr = (0, _tinycolor.default)(clr);
            if (!clr[action.apply]) {
              return _utils.throwError.call(this, "action " + action.apply + " not supported", cb);
            }
            clr = clr[action.apply](...action.params).toRgb();
          }
        });
        this.bitmap.data[idx] = clr.r;
        this.bitmap.data[idx + 1] = clr.g;
        this.bitmap.data[idx + 2] = clr.b;
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    var ColorActionName = Object.freeze({
      LIGHTEN: "lighten",
      BRIGHTEN: "brighten",
      DARKEN: "darken",
      DESATURATE: "desaturate",
      SATURATE: "saturate",
      GREYSCALE: "greyscale",
      SPIN: "spin",
      HUE: "hue",
      MIX: "mix",
      TINT: "tint",
      SHADE: "shade",
      XOR: "xor",
      RED: "red",
      GREEN: "green",
      BLUE: "blue"
    });
    exports2.ColorActionName = ColorActionName;
    var _default = () => ({
      /**
       * Adjusts the brightness of the image
       * @param {number} val the amount to adjust the brightness, a number between -1 and +1
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      brightness(val, cb) {
        if (typeof val !== "number") {
          return _utils.throwError.call(this, "val must be numbers", cb);
        }
        if (val < -1 || val > 1) {
          return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          if (val < 0) {
            this.bitmap.data[idx] *= 1 + val;
            this.bitmap.data[idx + 1] *= 1 + val;
            this.bitmap.data[idx + 2] *= 1 + val;
          } else {
            this.bitmap.data[idx] += (255 - this.bitmap.data[idx]) * val;
            this.bitmap.data[idx + 1] += (255 - this.bitmap.data[idx + 1]) * val;
            this.bitmap.data[idx + 2] += (255 - this.bitmap.data[idx + 2]) * val;
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Adjusts the contrast of the image
       * @param {number} val the amount to adjust the contrast, a number between -1 and +1
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      contrast(val, cb) {
        if (typeof val !== "number") {
          return _utils.throwError.call(this, "val must be numbers", cb);
        }
        if (val < -1 || val > 1) {
          return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
        }
        const factor = (val + 1) / (1 - val);
        function adjust(value2) {
          value2 = Math.floor(factor * (value2 - 127) + 127);
          return value2 < 0 ? 0 : value2 > 255 ? 255 : value2;
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);
          this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);
          this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Apply a posterize effect
       * @param {number} n the amount to adjust the contrast, minimum threshold is two
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      posterize(n, cb) {
        if (typeof n !== "number") {
          return _utils.throwError.call(this, "n must be numbers", cb);
        }
        if (n < 2) {
          n = 2;
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;
          this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;
          this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Removes colour from the image using ITU Rec 709 luminance values
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      greyscale,
      // Alias of greyscale for our American friends
      grayscale: greyscale,
      /**
       * Multiplies the opacity of each pixel by a factor between 0 and 1
       * @param {number} f A number, the factor by which to multiply the opacity of each pixel
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      opacity(f, cb) {
        if (typeof f !== "number")
          return _utils.throwError.call(this, "f must be a number", cb);
        if (f < 0 || f > 1)
          return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          const v = this.bitmap.data[idx + 3] * f;
          this.bitmap.data[idx + 3] = v;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Applies a sepia tone to the image
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      sepia(cb) {
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          let red = this.bitmap.data[idx];
          let green = this.bitmap.data[idx + 1];
          let blue = this.bitmap.data[idx + 2];
          red = red * 0.393 + green * 0.769 + blue * 0.189;
          green = red * 0.349 + green * 0.686 + blue * 0.168;
          blue = red * 0.272 + green * 0.534 + blue * 0.131;
          this.bitmap.data[idx] = red < 255 ? red : 255;
          this.bitmap.data[idx + 1] = green < 255 ? green : 255;
          this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Fades each pixel by a factor between 0 and 1
       * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      fade(f, cb) {
        if (typeof f !== "number") {
          return _utils.throwError.call(this, "f must be a number", cb);
        }
        if (f < 0 || f > 1) {
          return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
        }
        this.opacity(1 - f);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Adds each element of the image to its local neighbors, weighted by the kernel
       * @param {array} kernel a matrix to weight the neighbors sum
       * @param {number} edgeHandling (optional) define how to sum pixels from outside the border
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      convolution(kernel, edgeHandling, cb) {
        if (typeof edgeHandling === "function" && typeof cb === "undefined") {
          cb = edgeHandling;
          edgeHandling = null;
        }
        if (!edgeHandling) {
          edgeHandling = this.constructor.EDGE_EXTEND;
        }
        const newData = Buffer.from(this.bitmap.data);
        const kRows = kernel.length;
        const kCols = kernel[0].length;
        const rowEnd = Math.floor(kRows / 2);
        const colEnd = Math.floor(kCols / 2);
        const rowIni = -rowEnd;
        const colIni = -colEnd;
        let weight;
        let rSum;
        let gSum;
        let bSum;
        let ri;
        let gi;
        let bi;
        let xi;
        let yi;
        let idxi;
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          bSum = 0;
          gSum = 0;
          rSum = 0;
          for (let row = rowIni; row <= rowEnd; row++) {
            for (let col = colIni; col <= colEnd; col++) {
              xi = x + col;
              yi = y + row;
              weight = kernel[row + rowEnd][col + colEnd];
              idxi = this.getPixelIndex(xi, yi, edgeHandling);
              if (idxi === -1) {
                bi = 0;
                gi = 0;
                ri = 0;
              } else {
                ri = this.bitmap.data[idxi + 0];
                gi = this.bitmap.data[idxi + 1];
                bi = this.bitmap.data[idxi + 2];
              }
              rSum += weight * ri;
              gSum += weight * gi;
              bSum += weight * bi;
            }
          }
          if (rSum < 0) {
            rSum = 0;
          }
          if (gSum < 0) {
            gSum = 0;
          }
          if (bSum < 0) {
            bSum = 0;
          }
          if (rSum > 255) {
            rSum = 255;
          }
          if (gSum > 255) {
            gSum = 255;
          }
          if (bSum > 255) {
            bSum = 255;
          }
          newData[idx + 0] = rSum;
          newData[idx + 1] = gSum;
          newData[idx + 2] = bSum;
        });
        this.bitmap.data = newData;
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Set the alpha channel on every pixel to fully opaque
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      opaque(cb) {
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx + 3] = 255;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Pixelates the image or a region
       * @param {number} size the size of the pixels
       * @param {number} x (optional) the x position of the region to pixelate
       * @param {number} y (optional) the y position of the region to pixelate
       * @param {number} w (optional) the width of the region to pixelate
       * @param {number} h (optional) the height of the region to pixelate
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      pixelate(size, x, y, w, h, cb) {
        if (typeof x === "function") {
          cb = x;
          h = null;
          w = null;
          y = null;
          x = null;
        } else {
          if (typeof size !== "number") {
            return _utils.throwError.call(this, "size must be a number", cb);
          }
          if (isDef(x) && typeof x !== "number") {
            return _utils.throwError.call(this, "x must be a number", cb);
          }
          if (isDef(y) && typeof y !== "number") {
            return _utils.throwError.call(this, "y must be a number", cb);
          }
          if (isDef(w) && typeof w !== "number") {
            return _utils.throwError.call(this, "w must be a number", cb);
          }
          if (isDef(h) && typeof h !== "number") {
            return _utils.throwError.call(this, "h must be a number", cb);
          }
        }
        const kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
        x = x || 0;
        y = y || 0;
        w = isDef(w) ? w : this.bitmap.width - x;
        h = isDef(h) ? h : this.bitmap.height - y;
        const source = this.cloneQuiet();
        this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
          xx = size * Math.floor(xx / size);
          yx = size * Math.floor(yx / size);
          const value2 = applyKernel(source, kernel, xx, yx);
          this.bitmap.data[idx] = value2[0];
          this.bitmap.data[idx + 1] = value2[1];
          this.bitmap.data[idx + 2] = value2[2];
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Applies a convolution kernel to the image or a region
       * @param {array} kernel the convolution kernel
       * @param {number} x (optional) the x position of the region to apply convolution to
       * @param {number} y (optional) the y position of the region to apply convolution to
       * @param {number} w (optional) the width of the region to apply convolution to
       * @param {number} h (optional) the height of the region to apply convolution to
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      convolute(kernel, x, y, w, h, cb) {
        if (!Array.isArray(kernel))
          return _utils.throwError.call(this, "the kernel must be an array", cb);
        if (typeof x === "function") {
          cb = x;
          x = null;
          y = null;
          w = null;
          h = null;
        } else {
          if (isDef(x) && typeof x !== "number") {
            return _utils.throwError.call(this, "x must be a number", cb);
          }
          if (isDef(y) && typeof y !== "number") {
            return _utils.throwError.call(this, "y must be a number", cb);
          }
          if (isDef(w) && typeof w !== "number") {
            return _utils.throwError.call(this, "w must be a number", cb);
          }
          if (isDef(h) && typeof h !== "number") {
            return _utils.throwError.call(this, "h must be a number", cb);
          }
        }
        x = isDef(x) ? x : 0;
        y = isDef(y) ? y : 0;
        w = isDef(w) ? w : this.bitmap.width - x;
        h = isDef(h) ? h : this.bitmap.height - y;
        const source = this.cloneQuiet();
        this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
          const value2 = applyKernel(source, kernel, xx, yx);
          this.bitmap.data[idx] = this.constructor.limit255(value2[0]);
          this.bitmap.data[idx + 1] = this.constructor.limit255(value2[1]);
          this.bitmap.data[idx + 2] = this.constructor.limit255(value2[2]);
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Apply multiple color modification rules
       * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp }this for chaining of methods
       */
      color: colorFn,
      colour: colorFn
    });
    exports2.default = _default;
  }
});

// node_modules/@jimp/plugin-contain/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/@jimp/plugin-contain/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      contain(w, h, alignBits, mode, cb) {
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        }
        if (typeof alignBits === "string") {
          if (typeof mode === "function" && typeof cb === "undefined")
            cb = mode;
          mode = alignBits;
          alignBits = null;
        }
        if (typeof alignBits === "function") {
          if (typeof cb === "undefined")
            cb = alignBits;
          mode = null;
          alignBits = null;
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
        const hbits = alignBits & (1 << 3) - 1;
        const vbits = alignBits >> 3;
        if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
          return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
        }
        const alignH = hbits >> 1;
        const alignV = vbits >> 1;
        const f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
        const c = this.cloneQuiet().scale(f, mode);
        this.resize(w, h, mode);
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data.writeUInt32BE(this._background, idx);
        });
        this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-cover/dist/index.js
var require_dist15 = __commonJS({
  "node_modules/@jimp/plugin-cover/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      cover(w, h, alignBits, mode, cb) {
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        }
        if (alignBits && typeof alignBits === "function" && typeof cb === "undefined") {
          cb = alignBits;
          alignBits = null;
          mode = null;
        } else if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
        const hbits = alignBits & (1 << 3) - 1;
        const vbits = alignBits >> 3;
        if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1)))
          return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
        const alignH = hbits >> 1;
        const alignV = vbits >> 1;
        const f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
        this.scale(f, mode);
        this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-crop/dist/index.js
var require_dist16 = __commonJS({
  "node_modules/@jimp/plugin-crop/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = pluginCrop;
    var _utils = require_dist();
    function pluginCrop(event) {
      event("crop", function(x, y, w, h, cb) {
        if (typeof x !== "number" || typeof y !== "number")
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        if (typeof w !== "number" || typeof h !== "number")
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        x = Math.round(x);
        y = Math.round(y);
        w = Math.round(w);
        h = Math.round(h);
        if (x === 0 && w === this.bitmap.width) {
          const start = w * y + x << 2;
          const end = start + (h * w << 2);
          this.bitmap.data = this.bitmap.data.slice(start, end);
        } else {
          const bitmap = Buffer.allocUnsafe(w * h * 4);
          let offset = 0;
          this.scanQuiet(x, y, w, h, function(x2, y2, idx) {
            const data = this.bitmap.data.readUInt32BE(idx, true);
            bitmap.writeUInt32BE(data, offset, true);
            offset += 4;
          });
          this.bitmap.data = bitmap;
        }
        this.bitmap.width = w;
        this.bitmap.height = h;
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      });
      return {
        class: {
          /**
           * Autocrop same color borders from this image
           * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
           * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
           * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
           * @returns {Jimp} this for chaining of methods
           */
          autocrop() {
            const w = this.bitmap.width;
            const h = this.bitmap.height;
            const minPixelsPerSide = 1;
            let cb;
            let leaveBorder = 0;
            let tolerance = 2e-4;
            let cropOnlyFrames = true;
            let cropSymmetric = false;
            let ignoreSides = {
              north: false,
              south: false,
              east: false,
              west: false
            };
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            for (let a = 0, len = args.length; a < len; a++) {
              if (typeof args[a] === "number") {
                tolerance = args[a];
              }
              if (typeof args[a] === "boolean") {
                cropOnlyFrames = args[a];
              }
              if (typeof args[a] === "function") {
                cb = args[a];
              }
              if (typeof args[a] === "object") {
                const config = args[a];
                if (typeof config.tolerance !== "undefined") {
                  ({
                    tolerance
                  } = config);
                }
                if (typeof config.cropOnlyFrames !== "undefined") {
                  ({
                    cropOnlyFrames
                  } = config);
                }
                if (typeof config.cropSymmetric !== "undefined") {
                  ({
                    cropSymmetric
                  } = config);
                }
                if (typeof config.leaveBorder !== "undefined") {
                  ({
                    leaveBorder
                  } = config);
                }
                if (typeof config.ignoreSides !== "undefined") {
                  ({
                    ignoreSides
                  } = config);
                }
              }
            }
            let colorTarget = this.getPixelColor(0, 0);
            const rgba1 = this.constructor.intToRGBA(colorTarget);
            let northPixelsToCrop = 0;
            let eastPixelsToCrop = 0;
            let southPixelsToCrop = 0;
            let westPixelsToCrop = 0;
            colorTarget = this.getPixelColor(0, 0);
            if (!ignoreSides.north) {
              north:
                for (let y = 0; y < h - minPixelsPerSide; y++) {
                  for (let x = 0; x < w; x++) {
                    const colorXY = this.getPixelColor(x, y);
                    const rgba2 = this.constructor.intToRGBA(colorXY);
                    if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                      break north;
                    }
                  }
                  northPixelsToCrop++;
                }
            }
            colorTarget = this.getPixelColor(w, 0);
            if (!ignoreSides.west) {
              west:
                for (let x = 0; x < w - minPixelsPerSide; x++) {
                  for (let y = 0 + northPixelsToCrop; y < h; y++) {
                    const colorXY = this.getPixelColor(x, y);
                    const rgba2 = this.constructor.intToRGBA(colorXY);
                    if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                      break west;
                    }
                  }
                  westPixelsToCrop++;
                }
            }
            colorTarget = this.getPixelColor(0, h);
            if (!ignoreSides.south) {
              south:
                for (let y = h - 1; y >= northPixelsToCrop + minPixelsPerSide; y--) {
                  for (let x = w - eastPixelsToCrop - 1; x >= 0; x--) {
                    const colorXY = this.getPixelColor(x, y);
                    const rgba2 = this.constructor.intToRGBA(colorXY);
                    if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                      break south;
                    }
                  }
                  southPixelsToCrop++;
                }
            }
            colorTarget = this.getPixelColor(w, h);
            if (!ignoreSides.east) {
              east:
                for (let x = w - 1; x >= 0 + westPixelsToCrop + minPixelsPerSide; x--) {
                  for (let y = h - 1; y >= 0 + northPixelsToCrop; y--) {
                    const colorXY = this.getPixelColor(x, y);
                    const rgba2 = this.constructor.intToRGBA(colorXY);
                    if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                      break east;
                    }
                  }
                  eastPixelsToCrop++;
                }
            }
            let doCrop = false;
            westPixelsToCrop -= leaveBorder;
            eastPixelsToCrop -= leaveBorder;
            northPixelsToCrop -= leaveBorder;
            southPixelsToCrop -= leaveBorder;
            if (cropSymmetric) {
              const horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
              const vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
              westPixelsToCrop = horizontal;
              eastPixelsToCrop = horizontal;
              northPixelsToCrop = vertical;
              southPixelsToCrop = vertical;
            }
            westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
            eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
            northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
            southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
            const widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
            const heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
            if (cropOnlyFrames) {
              doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
            } else {
              doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
            }
            if (doCrop) {
              this.crop(westPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);
            }
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
        }
      };
    }
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-displace/dist/index.js
var require_dist17 = __commonJS({
  "node_modules/@jimp/plugin-displace/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      displace(map, offset, cb) {
        if (typeof map !== "object" || map.constructor !== this.constructor) {
          return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        }
        if (typeof offset !== "number") {
          return _utils.throwError.call(this, "factor must be a number", cb);
        }
        const source = this.cloneQuiet();
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          let displacement = map.bitmap.data[idx] / 256 * offset;
          displacement = Math.round(displacement);
          const ids = this.getPixelIndex(x + displacement, y);
          this.bitmap.data[ids] = source.bitmap.data[idx];
          this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
          this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-dither/dist/index.js
var require_dist18 = __commonJS({
  "node_modules/@jimp/plugin-dither/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    function dither(cb) {
      const rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        const thresholdId = ((y & 3) << 2) + x % 4;
        const dither2 = rgb565Matrix[thresholdId];
        this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither2, 255);
        this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither2, 255);
        this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither2, 255);
      });
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    var _default = () => ({
      dither565: dither,
      dither16: dither
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-fisheye/dist/index.js
var require_dist19 = __commonJS({
  "node_modules/@jimp/plugin-fisheye/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      fisheye() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          r: 2.5
        };
        let cb = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          cb = options;
          options = {
            r: 2.5
          };
        }
        const source = this.cloneQuiet();
        const {
          width,
          height
        } = source.bitmap;
        source.scanQuiet(0, 0, width, height, (x, y) => {
          const hx = x / width;
          const hy = y / height;
          const r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
          const rn = 2 * Math.pow(r, options.r);
          const cosA = (hx - 0.5) / r;
          const sinA = (hy - 0.5) / r;
          const newX = Math.round((rn * cosA + 0.5) * width);
          const newY = Math.round((rn * sinA + 0.5) * height);
          const color = source.getPixelColor(newX, newY);
          this.setPixelColor(color, x, y);
        });
        this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-flip/dist/index.js
var require_dist20 = __commonJS({
  "node_modules/@jimp/plugin-flip/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    function flipFn(horizontal, vertical, cb) {
      if (typeof horizontal !== "boolean" || typeof vertical !== "boolean")
        return _utils.throwError.call(this, "horizontal and vertical must be Booleans", cb);
      const bitmap = Buffer.alloc(this.bitmap.data.length);
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
        const _x = horizontal ? this.bitmap.width - 1 - x : x;
        const _y = vertical ? this.bitmap.height - 1 - y : y;
        const _idx = this.bitmap.width * _y + _x << 2;
        const data = this.bitmap.data.readUInt32BE(idx);
        bitmap.writeUInt32BE(data, _idx);
      });
      this.bitmap.data = Buffer.from(bitmap);
      if ((0, _utils.isNodePattern)(cb)) {
        cb.call(this, null, this);
      }
      return this;
    }
    var _default = () => ({
      flip: flipFn,
      mirror: flipFn
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-gaussian/dist/index.js
var require_dist21 = __commonJS({
  "node_modules/@jimp/plugin-gaussian/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      gaussian(r, cb) {
        if (typeof r !== "number") {
          return _utils.throwError.call(this, "r must be a number", cb);
        }
        if (r < 1) {
          return _utils.throwError.call(this, "r must be greater than 0", cb);
        }
        const rs = Math.ceil(r * 2.57);
        const range = rs * 2 + 1;
        const rr2 = r * r * 2;
        const rr2pi = rr2 * Math.PI;
        const weights = [];
        for (let y = 0; y < range; y++) {
          weights[y] = [];
          for (let x = 0; x < range; x++) {
            const dsq = (x - rs) ** 2 + (y - rs) ** 2;
            weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
          }
        }
        for (let y = 0; y < this.bitmap.height; y++) {
          for (let x = 0; x < this.bitmap.width; x++) {
            let red = 0;
            let green = 0;
            let blue = 0;
            let alpha = 0;
            let wsum = 0;
            for (let iy = 0; iy < range; iy++) {
              for (let ix = 0; ix < range; ix++) {
                const x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + x - rs));
                const y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + y - rs));
                const weight = weights[iy][ix];
                const idx2 = y1 * this.bitmap.width + x1 << 2;
                red += this.bitmap.data[idx2] * weight;
                green += this.bitmap.data[idx2 + 1] * weight;
                blue += this.bitmap.data[idx2 + 2] * weight;
                alpha += this.bitmap.data[idx2 + 3] * weight;
                wsum += weight;
              }
              const idx = y * this.bitmap.width + x << 2;
              this.bitmap.data[idx] = Math.round(red / wsum);
              this.bitmap.data[idx + 1] = Math.round(green / wsum);
              this.bitmap.data[idx + 2] = Math.round(blue / wsum);
              this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
            }
          }
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-invert/dist/index.js
var require_dist22 = __commonJS({
  "node_modules/@jimp/plugin-invert/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      invert(cb) {
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data[idx] = 255 - this.bitmap.data[idx];
          this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];
          this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-mask/dist/index.js
var require_dist23 = __commonJS({
  "node_modules/@jimp/plugin-mask/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      mask(src) {
        let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        let cb = arguments.length > 3 ? arguments[3] : void 0;
        if (!(src instanceof this.constructor)) {
          return _utils.throwError.call(this, "The source must be a Jimp image", cb);
        }
        if (typeof x !== "number" || typeof y !== "number") {
          return _utils.throwError.call(this, "x and y must be numbers", cb);
        }
        x = Math.round(x);
        y = Math.round(y);
        const w = this.bitmap.width;
        const h = this.bitmap.height;
        const baseImage = this;
        src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
          const destX = x + sx;
          const destY = y + sy;
          if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
            const dstIdx = baseImage.getPixelIndex(destX, destY);
            const {
              data
            } = this.bitmap;
            const avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
            baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
          }
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-normalize/dist/index.js
var require_dist24 = __commonJS({
  "node_modules/@jimp/plugin-normalize/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    function histogram() {
      const histogram2 = {
        r: new Array(256).fill(0),
        g: new Array(256).fill(0),
        b: new Array(256).fill(0)
      };
      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, index) {
        histogram2.r[this.bitmap.data[index + 0]]++;
        histogram2.g[this.bitmap.data[index + 1]]++;
        histogram2.b[this.bitmap.data[index + 2]]++;
      });
      return histogram2;
    }
    var normalize = function(value2, min2, max2) {
      return (value2 - min2) * 255 / (max2 - min2);
    };
    var getBounds = function(histogramChannel) {
      return [histogramChannel.findIndex((value2) => value2 > 0), 255 - histogramChannel.slice().reverse().findIndex((value2) => value2 > 0)];
    };
    var _default = () => ({
      normalize(cb) {
        const h = histogram.call(this);
        const bounds = {
          r: getBounds(h.r),
          g: getBounds(h.g),
          b: getBounds(h.b)
        };
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          const r = this.bitmap.data[idx + 0];
          const g = this.bitmap.data[idx + 1];
          const b = this.bitmap.data[idx + 2];
          this.bitmap.data[idx + 0] = normalize(r, bounds.r[0], bounds.r[1]);
          this.bitmap.data[idx + 1] = normalize(g, bounds.g[0], bounds.g[1]);
          this.bitmap.data[idx + 2] = normalize(b, bounds.b[0], bounds.b[1]);
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/phin/lib/phin.compiled.js
var require_phin_compiled = __commonJS({
  "node_modules/phin/lib/phin.compiled.js"(exports2, module2) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var http = require("http");
    var https = require("https");
    var url = require("url");
    var qs = require("querystring");
    var zlib = require("zlib");
    var util = require("util");
    var phin = function phin2(opts, cb) {
      if (typeof opts !== "string") {
        if (!opts.hasOwnProperty("url")) {
          throw new Error("Missing url option from options for request method.");
        }
      }
      var addr = (typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object" ? url.parse(opts.url) : url.parse(opts);
      var options = { "hostname": addr.hostname, "port": addr.port || (addr.protocol.toLowerCase() === "http:" ? 80 : 443), "path": addr.path, "method": "GET", "headers": {}, "auth": addr.auth || null, "parse": "none", "stream": false };
      if ((typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object") {
        options = Object.assign(options, opts);
      }
      options.port = Number(options.port);
      if (options.hasOwnProperty("timeout"))
        delete options.timeout;
      if (options.compressed === true) {
        options.headers["accept-encoding"] = "gzip, deflate";
      }
      if (opts.hasOwnProperty("form")) {
        if (_typeof(opts.form) !== "object") {
          throw new Error("phin 'form' option must be of type Object if present.");
        }
        var formDataString = qs.stringify(opts.form);
        options.headers["Content-Type"] = "application/x-www-form-urlencoded";
        options.headers["Content-Length"] = Buffer.byteLength(formDataString);
        opts.data = formDataString;
      }
      var req = void 0;
      var resHandler = function resHandler2(res) {
        var stream2 = res;
        if (options.compressed === true) {
          if (res.headers["content-encoding"] === "gzip") {
            stream2 = res.pipe(zlib.createGunzip());
          } else if (res.headers["content-encoding"] === "deflate") {
            stream2 = res.pipe(zlib.createInflate());
          }
        }
        if (options.stream === true) {
          res.stream = stream2;
          if (cb)
            cb(null, res);
        } else {
          res.body = new Buffer([]);
          stream2.on("data", function(chunk2) {
            res.body = Buffer.concat([res.body, chunk2]);
          });
          stream2.on("end", function() {
            if (cb) {
              if (options.parse === "json") {
                try {
                  res.body = JSON.parse(res.body.toString());
                } catch (err) {
                  cb("Invalid JSON received.", res);
                  return;
                }
              }
              cb(null, res);
            }
          });
        }
      };
      switch (addr.protocol.toLowerCase()) {
        case "http:":
          req = http.request(options, resHandler);
          break;
        case "https:":
          req = https.request(options, resHandler);
          break;
        default:
          if (cb)
            cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
          return;
      }
      if (typeof opts.timeout === "number") {
        req.setTimeout(opts.timeout, function() {
          req.abort();
          if (cb)
            cb(new Error("Timeout has been reached."), null);
          cb = null;
        });
      }
      req.on("error", function(err) {
        if (cb)
          cb(err, null);
      });
      if (opts.hasOwnProperty("data")) {
        var postData = opts.data;
        if (!(opts.data instanceof Buffer) && _typeof(opts.data) === "object") {
          var contentType = options.headers["content-type"] || options.headers["Content-Type"];
          if (contentType === "application/x-www-form-urlencoded") {
            postData = qs.stringify(opts.data);
          } else {
            try {
              postData = JSON.stringify(opts.data);
            } catch (err) {
              if (cb)
                cb(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
            }
          }
        }
        req.write(postData);
      }
      req.end();
    };
    phin.promisified = function(opts, http2) {
      return new Promise(function(resolve5, reject2) {
        phin(opts, function(err, res) {
          if (err) {
            reject2(err);
          } else {
            resolve5(res);
          }
        }, http2);
      });
    };
    if (util.promisify) {
      phin[util.promisify.custom] = phin.promisified;
    }
    module2.exports = phin;
  }
});

// node_modules/parse-bmfont-ascii/index.js
var require_parse_bmfont_ascii = __commonJS({
  "node_modules/parse-bmfont-ascii/index.js"(exports2, module2) {
    module2.exports = function parseBMFontAscii(data) {
      if (!data)
        throw new Error("no data provided");
      data = data.toString().trim();
      var output = {
        pages: [],
        chars: [],
        kernings: []
      };
      var lines = data.split(/\r\n?|\n/g);
      if (lines.length === 0)
        throw new Error("no data in BMFont file");
      for (var i2 = 0; i2 < lines.length; i2++) {
        var lineData = splitLine(lines[i2], i2);
        if (!lineData)
          continue;
        if (lineData.key === "page") {
          if (typeof lineData.data.id !== "number")
            throw new Error("malformed file at line " + i2 + " -- needs page id=N");
          if (typeof lineData.data.file !== "string")
            throw new Error("malformed file at line " + i2 + ' -- needs page file="path"');
          output.pages[lineData.data.id] = lineData.data.file;
        } else if (lineData.key === "chars" || lineData.key === "kernings") {
        } else if (lineData.key === "char") {
          output.chars.push(lineData.data);
        } else if (lineData.key === "kerning") {
          output.kernings.push(lineData.data);
        } else {
          output[lineData.key] = lineData.data;
        }
      }
      return output;
    };
    function splitLine(line, idx) {
      line = line.replace(/\t+/g, " ").trim();
      if (!line)
        return null;
      var space = line.indexOf(" ");
      if (space === -1)
        throw new Error("no named row at line " + idx);
      var key = line.substring(0, space);
      line = line.substring(space + 1);
      line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, "");
      line = line.split("=");
      line = line.map(function(str) {
        return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
      });
      var data = [];
      for (var i2 = 0; i2 < line.length; i2++) {
        var dt = line[i2];
        if (i2 === 0) {
          data.push({
            key: dt[0],
            data: ""
          });
        } else if (i2 === line.length - 1) {
          data[data.length - 1].data = parseData(dt[0]);
        } else {
          data[data.length - 1].data = parseData(dt[0]);
          data.push({
            key: dt[1],
            data: ""
          });
        }
      }
      var out = {
        key,
        data: {}
      };
      data.forEach(function(v) {
        out.data[v.key] = v.data;
      });
      return out;
    }
    function parseData(data) {
      if (!data || data.length === 0)
        return "";
      if (data.indexOf('"') === 0 || data.indexOf("'") === 0)
        return data.substring(1, data.length - 1);
      if (data.indexOf(",") !== -1)
        return parseIntList(data);
      return parseInt(data, 10);
    }
    function parseIntList(data) {
      return data.split(",").map(function(val) {
        return parseInt(val, 10);
      });
    }
  }
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports2) {
    (function() {
      exports2.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports2, module2) {
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i2, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i2 = 0, len = sources.length; i2 < len; i2++) {
            source = sources[i2];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty = function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key))
              continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports2, module2) {
    (function() {
      var XMLDOMImplementation;
      module2.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation2() {
        }
        XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports2, module2) {
    (function() {
      var XMLDOMErrorHandler;
      module2.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler2() {
        }
        XMLDOMErrorHandler2.prototype.handleError = function(error) {
          throw new Error(error);
        };
        return XMLDOMErrorHandler2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports2, module2) {
    (function() {
      var XMLDOMStringList;
      module2.exports = XMLDOMStringList = function() {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        });
        XMLDOMStringList2.prototype.item = function(index) {
          return this.arr[index] || null;
        };
        XMLDOMStringList2.prototype.contains = function(str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports2, module2) {
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module2.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            "canonical-form": false,
            "cdata-sections": false,
            "comments": false,
            "datatype-normalization": false,
            "element-content-whitespace": true,
            "entities": true,
            "error-handler": new XMLDOMErrorHandler(),
            "infoset": true,
            "validate-if-schema": false,
            "namespaces": true,
            "namespace-declarations": true,
            "normalize-characters": false,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": true,
            "validate": false,
            "well-formed": true
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }
        });
        XMLDOMConfiguration2.prototype.getParameter = function(name2) {
          if (this.params.hasOwnProperty(name2)) {
            return this.params[name2];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function(name2, value2) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function(name2, value2) {
          if (value2 != null) {
            return this.params[name2] = value2;
          } else {
            return delete this.params[name2];
          }
        };
        return XMLDOMConfiguration2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/xmlbuilder/lib/NodeType.js"(exports2, module2) {
    (function() {
      module2.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports2, module2) {
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name2, value2) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name2 == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name2));
          }
          this.name = this.stringify.name(name2);
          this.value = this.stringify.attValue(value2);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value2) {
            return this.value = value2 || "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: function() {
            return true;
          }
        });
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute2.prototype.debugInfo = function(name2) {
          name2 = name2 || this.name;
          if (name2 == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name2 + "}, parent: <" + this.parent.name + ">";
          }
        };
        XMLAttribute2.prototype.isEqualNode = function(node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports2, module2) {
    (function() {
      var XMLNamedNodeMap;
      module2.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        });
        XMLNamedNodeMap2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function(name2) {
          return this.nodes[name2];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function(name2) {
          var oldNode;
          oldNode = this.nodes[name2];
          delete this.nodes[name2];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function(index) {
          return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports2, module2) {
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name2, attributes) {
          var child, j, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent);
          if (name2 == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.name(name2);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
            if (parent.children) {
              ref1 = parent.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }
        });
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name2, value2) {
          var attName, attValue;
          if (name2 != null) {
            name2 = getValue(name2);
          }
          if (isObject(name2)) {
            for (attName in name2) {
              if (!hasProp.call(name2, attName))
                continue;
              attValue = name2[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            if (this.options.keepNullAttributes && value2 == null) {
              this.attribs[name2] = new XMLAttribute(this, name2, "");
            } else if (value2 != null) {
              this.attribs[name2] = new XMLAttribute(this, name2, value2);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name2) {
          var attName, j, len;
          if (name2 == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name2 = getValue(name2);
          if (Array.isArray(name2)) {
            for (j = 0, len = name2.length; j < len; j++) {
              attName = name2[j];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name2];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement2.prototype.att = function(name2, value2) {
          return this.attribute(name2, value2);
        };
        XMLElement2.prototype.a = function(name2, value2) {
          return this.attribute(name2, value2);
        };
        XMLElement2.prototype.getAttribute = function(name2) {
          if (this.attribs.hasOwnProperty(name2)) {
            return this.attribs[name2].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function(name2, value2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function(name2) {
          if (this.attribs.hasOwnProperty(name2)) {
            return this.attribs[name2];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(name2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function(name2) {
          return this.attribs.hasOwnProperty(name2);
        };
        XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function(name2, isId) {
          if (this.attribs.hasOwnProperty(name2)) {
            return this.attribs[name2].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function(node) {
          var i2, j, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (i2 = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i2 = 0 <= ref1 ? ++j : --j) {
            if (!this.attribs[i2].isEqualNode(node.attribs[i2])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports2, module2) {
    (function() {
      var XMLCharacterData, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent) {
          XMLCharacterData2.__super__.constructor.call(this, parent);
          this.value = "";
        }
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(value2) {
            return this.value = value2 || "";
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value2) {
            return this.value = value2 || "";
          }
        });
        XMLCharacterData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function(arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function(offset, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function(node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version)) {
            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name2, value2) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name2 == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name2));
          }
          if (value2 == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name2));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name2);
          this.type = NodeType.EntityDeclaration;
          if (!isObject(value2)) {
            this.value = this.stringify.dtdEntityValue(value2);
            this.internal = true;
          } else {
            if (!value2.pubID && !value2.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name2));
            }
            if (value2.pubID && !value2.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name2));
            }
            this.internal = false;
            if (value2.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value2.pubID);
            }
            if (value2.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value2.sysID);
            }
            if (value2.nData != null) {
              this.nData = this.stringify.dtdNData(value2.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name2));
            }
          }
        }
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        });
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name2, value2) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name2 == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value2) {
            value2 = "(#PCDATA)";
          }
          if (Array.isArray(value2)) {
            value2 = "(" + value2.join(",") + ")";
          }
          this.name = this.stringify.name(name2);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value2);
        }
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name2, value2) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name2 == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name2));
          }
          if (!value2.pubID && !value2.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name2));
          }
          this.name = this.stringify.name(name2);
          this.type = NodeType.NotationDeclaration;
          if (value2.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value2.pubID);
          }
          if (value2.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value2.sysID);
          }
        }
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var child, i2, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.type = NodeType.DocType;
          if (parent.children) {
            ref = parent.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent;
          if (isObject(pubID)) {
            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
          }
          if (sysID == null) {
            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: function() {
            var child, i2, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: function() {
            var child, i2, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLDocType2.prototype.element = function(name2, value2) {
          var child;
          child = new XMLDTDElement(this, name2, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name2, value2) {
          var child;
          child = new XMLDTDEntity(this, false, name2, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name2, value2) {
          var child;
          child = new XMLDTDEntity(this, true, name2, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name2, value2) {
          var child;
          child = new XMLDTDNotation(this, name2, value2);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType2.prototype.ele = function(name2, value2) {
          return this.element(name2, value2);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name2, value2) {
          return this.entity(name2, value2);
        };
        XMLDocType2.prototype.pent = function(name2, value2) {
          return this.pEntity(name2, value2);
        };
        XMLDocType2.prototype.not = function(name2, value2) {
          return this.notation(name2, value2);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function(node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports2, module2) {
    (function() {
      var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.name = "#text";
          this.type = NodeType.Text;
          this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: function() {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          }
        });
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText2.prototype.splitText = function(offset) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function(content) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports2, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value2) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value2) {
            this.value = this.stringify.insValue(value2);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      }(XMLCharacterData);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.type = NodeType.Dummy;
        }
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports2, module2) {
    (function() {
      var XMLNodeList;
      module2.exports = XMLNodeList = function() {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        });
        XMLNodeList2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNodeList2.prototype.item = function(index) {
          return this.nodes[index] || null;
        };
        return XMLNodeList2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports2, module2) {
    (function() {
      module2.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports2, module2) {
    (function() {
      var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
      ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module2.exports = XMLNode = function() {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition = require_DocumentPosition();
          }
        }
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            return this.parent.children[i2 - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            return this.parent.children[i2 + 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: function() {
            var child, j, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function(value2) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLNode2.prototype.setParent = function(parent) {
          var child, j, len, ref2, results;
          this.parent = parent;
          if (parent) {
            this.options = parent.options;
            this.stringify = parent.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function(name2, attributes, text) {
          var childNode, item2, j, k, key, lastChild, len, len1, ref2, ref3, val;
          lastChild = null;
          if (attributes === null && text == null) {
            ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
          }
          if (name2 != null) {
            name2 = getValue(name2);
          }
          if (Array.isArray(name2)) {
            for (j = 0, len = name2.length; j < len; j++) {
              item2 = name2[j];
              lastChild = this.element(item2);
            }
          } else if (isFunction(name2)) {
            lastChild = this.element(name2.apply());
          } else if (isObject(name2)) {
            for (key in name2) {
              if (!hasProp.call(name2, key))
                continue;
              val = name2[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                lastChild = this.dummy();
              } else if (isObject(val) && isEmpty(val)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item2 = val[k];
                  childNode = {};
                  childNode[key] = item2;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (!this.options.keepNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name2.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name2.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name2.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name2.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name2.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name2.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name2, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name2 + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name2, attributes, text) {
          var child, i2, newChild, refChild, removed;
          if (name2 != null ? name2.type : void 0) {
            newChild = name2;
            refChild = attributes;
            newChild.setParent(this);
            if (refChild) {
              i2 = children.indexOf(refChild);
              removed = children.splice(i2);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name2));
            }
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2);
            child = this.parent.element(name2, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function(name2, attributes, text) {
          var child, i2, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name2));
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.element(name2, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i2, ref2;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i2 = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref2 = [])), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name2, attributes, text) {
          var child, ref2;
          if (name2 != null) {
            name2 = getValue(name2);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          child = new XMLElement(this, name2, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value2) {
          var child;
          if (isObject(value2)) {
            this.element(value2);
          }
          child = new XMLText(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value2) {
          var child;
          child = new XMLCData(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value2) {
          var child;
          child = new XMLComment(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value2) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.comment(value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value2) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.comment(value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value2) {
          var child;
          child = new XMLRaw(this, value2);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value2) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value2 != null) {
            value2 = getValue(value2);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value2);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value2) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.instruction(target, value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value2) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.instruction(target, value2);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          var child, doc, doctype, i2, j, k, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i2 = j = 0, len = ref2.length; j < len; i2 = ++j) {
            child = ref2[i2];
            if (child.type === NodeType.DocType) {
              doc.children[i2] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i2 = k = 0, len1 = ref3.length; k < len1; i2 = ++k) {
            child = ref3[i2];
            if (child.isRoot) {
              doc.children.splice(i2, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          if (i2 < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i2 - 1];
        };
        XMLNode2.prototype.next = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          if (i2 === -1 || i2 === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i2 + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name2) {
          var ref2, ref3;
          name2 = name2 || this.name;
          if (name2 == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "";
          } else if (name2 == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return "node: <" + name2 + ">";
          } else {
            return "node: <" + name2 + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name2, attributes, text) {
          return this.element(name2, attributes, text);
        };
        XMLNode2.prototype.nod = function(name2, attributes, text) {
          return this.node(name2, attributes, text);
        };
        XMLNode2.prototype.txt = function(value2) {
          return this.text(value2);
        };
        XMLNode2.prototype.dat = function(value2) {
          return this.cdata(value2);
        };
        XMLNode2.prototype.com = function(value2) {
          return this.comment(value2);
        };
        XMLNode2.prototype.ins = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.e = function(name2, attributes, text) {
          return this.element(name2, attributes, text);
        };
        XMLNode2.prototype.n = function(name2, attributes, text) {
          return this.node(name2, attributes, text);
        };
        XMLNode2.prototype.t = function(value2) {
          return this.text(value2);
        };
        XMLNode2.prototype.d = function(value2) {
          return this.cdata(value2);
        };
        XMLNode2.prototype.c = function(value2) {
          return this.comment(value2);
        };
        XMLNode2.prototype.r = function(value2) {
          return this.raw(value2);
        };
        XMLNode2.prototype.i = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function(oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function(newChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function(deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function(feature, version) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function(other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition.Preceding;
            } else {
              res |= DocumentPosition.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition.Contains | DocumentPosition.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition.Contains | DocumentPosition.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition.Preceding;
          } else {
            return DocumentPosition.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function(other) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function(node) {
          var i2, j, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (i2 = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i2 = 0 <= ref2 ? ++j : --j) {
            if (!this.children[i2].isEqualNode(node.children[i2])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function(key, data, handler) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function(key) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.contains = function(other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function(node) {
          var child, isDescendantChild, j, len, ref2;
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function(node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function(node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function(childNode) {
            pos++;
            if (!found && childNode === node) {
              return found = true;
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function(node, func) {
          var child, j, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (res = func(child)) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports2, module2) {
    (function() {
      var XMLStringifier, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalName = bind(this.assertLegalName, this);
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value2;
          options || (options = {});
          this.options = options;
          if (!this.options.version) {
            this.options.version = "1.0";
          }
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this[key] = value2;
          }
        }
        XMLStringifier2.prototype.name = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalName("" + val || "");
        };
        XMLStringifier2.prototype.text = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.textEscape("" + val || ""));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.attEscape(val = "" + val || ""));
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.insValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = "";
          if (this.options.version === "1.0") {
            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          } else if (this.options.version === "1.1") {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function(str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error("Invalid character in name");
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/xmlbuilder/lib/WriterState.js"(exports2, module2) {
    (function() {
      module2.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module2.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, value2;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this["_" + key] = this[key];
            this[key] = value2;
          }
        }
        XMLWriterBase2.prototype.filterOptions = function(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
          filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        };
        XMLWriterBase2.prototype.endline = function(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function(att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          r = " " + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options, level);
          return r;
        };
        XMLWriterBase2.prototype.cdata = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.comment = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.declaration = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.docType = function(node, options, level) {
          var child, i2, len, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += "]";
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, i2, j, len, len1, name2, prettySuppressed, r, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r = "";
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r += this.indent(node, options, level) + "<" + node.name;
          ref = node.attribs;
          for (name2 in ref) {
            if (!hasProp.call(ref, name2))
              continue;
            att = ref[name2];
            r += this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              r += ">";
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            r += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                child = ref1[i2];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.raw = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.text = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports2, module2) {
    (function() {
      var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function(doc, options) {
          var child, i2, len, r, ref;
          options = this.filterOptions(options);
          r = "";
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            r += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r.slice(-options.newline.length) === options.newline) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports2, module2) {
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "#document";
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: function() {
            var child, i2, len, ref;
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: function() {
            return false;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: function() {
            return null;
          }
        });
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument2.prototype.createElement = function(tagName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function(name2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function(name2) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function(importedNode, deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function(elementId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function(source) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function(eventInterface) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module2.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.createChildNode = function(node) {
          var att, attName, attributes, child, i2, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref2 = node.children;
          for (i2 = 0, len = ref2.length; i2 < len; i2++) {
            child = ref2[i2];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function() {
          return this;
        };
        XMLDocumentCB2.prototype.node = function(name2, attributes, text) {
          var ref1;
          if (name2 == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name2));
          }
          this.openCurrent();
          name2 = getValue(name2);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name2, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name2, attributes, text) {
          var child, i2, len, oldValidationFlag, ref1, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name2) || isObject(name2) || isFunction(name2)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element("TEMP_ROOT");
              root.element(name2);
              this.options.noValidation = oldValidationFlag;
              ref1 = root.children;
              for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                child = ref1[i2];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name2, attributes, text);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function(name2, value2) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name2));
          }
          if (name2 != null) {
            name2 = getValue(name2);
          }
          if (isObject(name2)) {
            for (attName in name2) {
              if (!hasProp.call(name2, attName))
                continue;
              attValue = name2[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            if (this.options.keepNullAttributes && value2 == null) {
              this.currentNode.attribs[name2] = new XMLAttribute(this, name2, "");
            } else if (value2 != null) {
              this.currentNode.attribs[name2] = new XMLAttribute(this, name2, value2);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value2);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value2);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value2);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value2) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value2);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value2) {
          var i2, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value2 != null) {
            value2 = getValue(value2);
          }
          if (Array.isArray(target)) {
            for (i2 = 0, len = target.length; i2 < len; i2++) {
              insTarget = target[i2];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value2)) {
              value2 = value2.apply();
            }
            node = new XMLProcessingInstruction(this, target, value2);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name2, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name2, value2);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name2, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name2, value2);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name2, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name2, value2);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name2, value2) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name2, value2);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          var att, chunk2, name2, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk2 = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk2 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref1 = node.attribs;
              for (name2 in ref1) {
                if (!hasProp.call(ref1, name2))
                  continue;
                att = ref1[name2];
                chunk2 += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk2 += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk2 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk2 += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk2 += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk2 += ">";
              }
              chunk2 += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk2, this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          var chunk2;
          if (!node.isClosed) {
            chunk2 = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk2 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk2 = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk2, this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk2, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk2, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name2) {
          if (name2 == null) {
            return "";
          } else {
            return "node: <" + name2 + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name2, attributes, text) {
          return this.node(name2, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value2) {
          return this.text(value2);
        };
        XMLDocumentCB2.prototype.dat = function(value2) {
          return this.cdata(value2);
        };
        XMLDocumentCB2.prototype.com = function(value2) {
          return this.comment(value2);
        };
        XMLDocumentCB2.prototype.ins = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name2, attributes, text) {
          return this.element(name2, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name2, attributes, text) {
          return this.node(name2, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value2) {
          return this.text(value2);
        };
        XMLDocumentCB2.prototype.d = function(value2) {
          return this.cdata(value2);
        };
        XMLDocumentCB2.prototype.c = function(value2) {
          return this.comment(value2);
        };
        XMLDocumentCB2.prototype.r = function(value2) {
          return this.raw(value2);
        };
        XMLDocumentCB2.prototype.i = function(target, value2) {
          return this.instruction(target, value2);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name2, value2) {
          return this.entity(name2, value2);
        };
        XMLDocumentCB2.prototype.pent = function(name2, value2) {
          return this.pEntity(name2, value2);
        };
        XMLDocumentCB2.prototype.not = function(name2, value2) {
          return this.notation(name2, value2);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module2.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream2, options) {
          this.stream = stream2;
          XMLStreamWriter2.__super__.constructor.call(this, options);
        }
        XMLStreamWriter2.prototype.endline = function(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
          }
        };
        XMLStreamWriter2.prototype.document = function(doc, options) {
          var child, i2, j, k, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i2 = j = 0, len = ref.length; j < len; i2 = ++j) {
            child = ref[i2];
            child.isLastRootNode = i2 === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter2.prototype.cdata = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.comment = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.declaration = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.docType = function(node, options, level) {
          var child, j, len, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, j, len, name2, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level) + "<" + node.name);
          ref = node.attribs;
          for (name2 in ref) {
            if (!hasProp.call(ref, name2))
              continue;
            att = ref[name2];
            this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.raw = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.text = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports2, module2) {
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module2.exports.create = function(name2, xmldec, doctype, options) {
        var doc, root;
        if (name2 == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name2);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream2, options) {
        return new XMLStreamWriter(stream2, options);
      };
      module2.exports.implementation = new XMLDOMImplementation();
      module2.exports.nodeType = NodeType;
      module2.exports.writerState = WriterState;
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports2) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib6();
      defaults = require_defaults().defaults;
      requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      };
      exports2.Builder = function() {
        function Builder(opts) {
          var key, ref, value2;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this.options[key] = value2;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value2 = opts[key];
            this.options[key] = value2;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = function(_this) {
            return function(element, obj) {
              var attr, child, entry, index, key, value2;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index))
                    continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value2 = child[attr];
                        element = element.att(attr, value2);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index))
                        continue;
                      entry = child[index];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports2);
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i2 in o)
            if (o.hasOwnProperty(i2))
              a.push(i2);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream)
        Stream = function() {
        };
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk2) {
        if (chunk2 && chunk2.length) {
          this.write(chunk2);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name2, attribute) {
        var i2 = name2.indexOf(":");
        var qualName = i2 < 0 ? ["", name2] : name2.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name2 === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
            var nv = parser.attribList[i2];
            var name2 = nv[0];
            var value2 = nv[1];
            var qualName = qname(name2, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name: name2,
              value: value2,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name2] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i2 in tag.ns) {
            x[i2] = tag.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk2, i2) {
        var result = "";
        if (i2 < chunk2.length) {
          result = chunk2.charAt(i2);
        }
        return result;
      }
      function write(chunk2) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk2 === null) {
          return end(parser);
        }
        if (typeof chunk2 === "object") {
          chunk2 = chunk2.toString();
        }
        var i2 = 0;
        var c = "";
        while (true) {
          c = charAt(chunk2, i2++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk2, i2++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk2.substring(starti, i2 - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                if (parser.opt.unparsedEntities) {
                  var parsedEntity = parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parseEntity(parser);
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports2) {
    (function() {
      "use strict";
      exports2.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports2) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports2.normalize = function(str) {
        return str.toLowerCase();
      };
      exports2.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports2.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports2.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports2.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser3 = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports2) {
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate2, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = require("events");
      bom = require_bom();
      processors = require_processors();
      setImmediate2 = require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function(processors2, item2, key) {
        var i2, len, process2;
        for (i2 = 0, len = processors2.length; i2 < len; i2++) {
          process2 = processors2[i2];
          item2 = process2(item2, key);
        }
        return item2;
      };
      exports2.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseStringPromise = bind(this.parseStringPromise, this);
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value2;
          if (!(this instanceof exports2.Parser)) {
            return new exports2.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value2 = ref[key];
            this.options[key] = value2;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value2 = opts[key];
            this.options[key] = value2;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function() {
          var chunk2, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk2 = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk2);
              return this.saxParser.close();
            } else {
              chunk2 = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk2);
              return setImmediate2(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          }(this);
          this.saxParser.onend = function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i2, len, results;
                  results = [];
                  for (i2 = 0, len = stack.length; i2 < len; i2++) {
                    node = stack[i2];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = function(_this) {
            return function(text) {
              var charChild, s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate2(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser.prototype.parseStringPromise = function(str) {
          return new Promise(function(_this) {
            return function(resolve5, reject2) {
              return _this.parseString(str, function(err, value2) {
                if (err) {
                  return reject2(err);
                } else {
                  return resolve5(value2);
                }
              });
            };
          }(this));
        };
        return Parser;
      }(events);
      exports2.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options = {};
        }
        parser = new exports2.Parser(options);
        return parser.parseString(str, cb);
      };
      exports2.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === "object") {
          options = a;
        }
        parser = new exports2.Parser(options);
        return parser.parseStringPromise(str);
      };
    }).call(exports2);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports2) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder();
      parser = require_parser3();
      processors = require_processors();
      exports2.defaults = defaults.defaults;
      exports2.processors = processors;
      exports2.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      }(Error);
      exports2.Builder = builder.Builder;
      exports2.Parser = parser.Parser;
      exports2.parseString = parser.parseString;
      exports2.parseStringPromise = parser.parseStringPromise;
    }).call(exports2);
  }
});

// node_modules/parse-bmfont-xml/lib/parse-attribs.js
var require_parse_attribs = __commonJS({
  "node_modules/parse-bmfont-xml/lib/parse-attribs.js"(exports2, module2) {
    var GLYPH_DESIGNER_ERROR = "chasrset";
    module2.exports = function parseAttributes(obj) {
      if (GLYPH_DESIGNER_ERROR in obj) {
        obj["charset"] = obj[GLYPH_DESIGNER_ERROR];
        delete obj[GLYPH_DESIGNER_ERROR];
      }
      for (var k in obj) {
        if (k === "face" || k === "charset")
          continue;
        else if (k === "padding" || k === "spacing")
          obj[k] = parseIntList(obj[k]);
        else
          obj[k] = parseInt(obj[k], 10);
      }
      return obj;
    };
    function parseIntList(data) {
      return data.split(",").map(function(val) {
        return parseInt(val, 10);
      });
    }
  }
});

// node_modules/parse-bmfont-xml/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/parse-bmfont-xml/lib/index.js"(exports2, module2) {
    var xml2js = require_xml2js();
    var parseAttributes = require_parse_attribs();
    module2.exports = function parseBMFontXML(data) {
      data = data.toString().trim();
      var output = {
        pages: [],
        chars: [],
        kernings: []
      };
      xml2js.parseString(data, function(err, result) {
        if (err)
          throw err;
        if (!result.font)
          throw "XML bitmap font doesn't have <font> root";
        result = result.font;
        output.common = parseAttributes(result.common[0].$);
        output.info = parseAttributes(result.info[0].$);
        for (var i2 = 0; i2 < result.pages.length; i2++) {
          var p = result.pages[i2].page[0].$;
          if (typeof p.id === "undefined")
            throw new Error("malformed file -- needs page id=N");
          if (typeof p.file !== "string")
            throw new Error('malformed file -- needs page file="path"');
          output.pages[parseInt(p.id, 10)] = p.file;
        }
        if (result.chars) {
          var chrArray = result.chars[0]["char"] || [];
          for (var i2 = 0; i2 < chrArray.length; i2++) {
            output.chars.push(parseAttributes(chrArray[i2].$));
          }
        }
        if (result.kernings) {
          var kernArray = result.kernings[0]["kerning"] || [];
          for (var i2 = 0; i2 < kernArray.length; i2++) {
            output.kernings.push(parseAttributes(kernArray[i2].$));
          }
        }
      });
      return output;
    };
  }
});

// node_modules/parse-bmfont-binary/index.js
var require_parse_bmfont_binary = __commonJS({
  "node_modules/parse-bmfont-binary/index.js"(exports2, module2) {
    var HEADER = [66, 77, 70];
    module2.exports = function readBMFontBinary(buf) {
      if (buf.length < 6)
        throw new Error("invalid buffer length for BMFont");
      var header = HEADER.every(function(byte, i3) {
        return buf.readUInt8(i3) === byte;
      });
      if (!header)
        throw new Error("BMFont missing BMF byte header");
      var i2 = 3;
      var vers = buf.readUInt8(i2++);
      if (vers > 3)
        throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
      var target = { kernings: [], chars: [] };
      for (var b = 0; b < 5; b++)
        i2 += readBlock(target, buf, i2);
      return target;
    };
    function readBlock(target, buf, i2) {
      if (i2 > buf.length - 1)
        return 0;
      var blockID = buf.readUInt8(i2++);
      var blockSize = buf.readInt32LE(i2);
      i2 += 4;
      switch (blockID) {
        case 1:
          target.info = readInfo(buf, i2);
          break;
        case 2:
          target.common = readCommon(buf, i2);
          break;
        case 3:
          target.pages = readPages(buf, i2, blockSize);
          break;
        case 4:
          target.chars = readChars(buf, i2, blockSize);
          break;
        case 5:
          target.kernings = readKernings(buf, i2, blockSize);
          break;
      }
      return 5 + blockSize;
    }
    function readInfo(buf, i2) {
      var info = {};
      info.size = buf.readInt16LE(i2);
      var bitField = buf.readUInt8(i2 + 2);
      info.smooth = bitField >> 7 & 1;
      info.unicode = bitField >> 6 & 1;
      info.italic = bitField >> 5 & 1;
      info.bold = bitField >> 4 & 1;
      if (bitField >> 3 & 1)
        info.fixedHeight = 1;
      info.charset = buf.readUInt8(i2 + 3) || "";
      info.stretchH = buf.readUInt16LE(i2 + 4);
      info.aa = buf.readUInt8(i2 + 6);
      info.padding = [
        buf.readInt8(i2 + 7),
        buf.readInt8(i2 + 8),
        buf.readInt8(i2 + 9),
        buf.readInt8(i2 + 10)
      ];
      info.spacing = [
        buf.readInt8(i2 + 11),
        buf.readInt8(i2 + 12)
      ];
      info.outline = buf.readUInt8(i2 + 13);
      info.face = readStringNT(buf, i2 + 14);
      return info;
    }
    function readCommon(buf, i2) {
      var common = {};
      common.lineHeight = buf.readUInt16LE(i2);
      common.base = buf.readUInt16LE(i2 + 2);
      common.scaleW = buf.readUInt16LE(i2 + 4);
      common.scaleH = buf.readUInt16LE(i2 + 6);
      common.pages = buf.readUInt16LE(i2 + 8);
      var bitField = buf.readUInt8(i2 + 10);
      common.packed = 0;
      common.alphaChnl = buf.readUInt8(i2 + 11);
      common.redChnl = buf.readUInt8(i2 + 12);
      common.greenChnl = buf.readUInt8(i2 + 13);
      common.blueChnl = buf.readUInt8(i2 + 14);
      return common;
    }
    function readPages(buf, i2, size) {
      var pages = [];
      var text = readNameNT(buf, i2);
      var len = text.length + 1;
      var count = size / len;
      for (var c = 0; c < count; c++) {
        pages[c] = buf.slice(i2, i2 + text.length).toString("utf8");
        i2 += len;
      }
      return pages;
    }
    function readChars(buf, i2, blockSize) {
      var chars = [];
      var count = blockSize / 20;
      for (var c = 0; c < count; c++) {
        var char = {};
        var off = c * 20;
        char.id = buf.readUInt32LE(i2 + 0 + off);
        char.x = buf.readUInt16LE(i2 + 4 + off);
        char.y = buf.readUInt16LE(i2 + 6 + off);
        char.width = buf.readUInt16LE(i2 + 8 + off);
        char.height = buf.readUInt16LE(i2 + 10 + off);
        char.xoffset = buf.readInt16LE(i2 + 12 + off);
        char.yoffset = buf.readInt16LE(i2 + 14 + off);
        char.xadvance = buf.readInt16LE(i2 + 16 + off);
        char.page = buf.readUInt8(i2 + 18 + off);
        char.chnl = buf.readUInt8(i2 + 19 + off);
        chars[c] = char;
      }
      return chars;
    }
    function readKernings(buf, i2, blockSize) {
      var kernings = [];
      var count = blockSize / 10;
      for (var c = 0; c < count; c++) {
        var kern = {};
        var off = c * 10;
        kern.first = buf.readUInt32LE(i2 + 0 + off);
        kern.second = buf.readUInt32LE(i2 + 4 + off);
        kern.amount = buf.readInt16LE(i2 + 8 + off);
        kernings[c] = kern;
      }
      return kernings;
    }
    function readNameNT(buf, offset) {
      var pos = offset;
      for (; pos < buf.length; pos++) {
        if (buf[pos] === 0)
          break;
      }
      return buf.slice(offset, pos);
    }
    function readStringNT(buf, offset) {
      return readNameNT(buf, offset).toString("utf8");
    }
  }
});

// node_modules/mime/types.json
var require_types = __commonJS({
  "node_modules/mime/types.json"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/mime.js
var require_mime2 = __commonJS({
  "node_modules/mime/mime.js"(exports2, module2) {
    var path4 = require("path");
    var fs = require("fs");
    function Mime() {
      this.types = /* @__PURE__ */ Object.create(null);
      this.extensions = /* @__PURE__ */ Object.create(null);
    }
    Mime.prototype.define = function(map) {
      for (var type in map) {
        var exts = map[type];
        for (var i2 = 0; i2 < exts.length; i2++) {
          if (process.env.DEBUG_MIME && this.types[exts[i2]]) {
            console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i2] + '" extension type from ' + this.types[exts[i2]] + " to " + type);
          }
          this.types[exts[i2]] = type;
        }
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    Mime.prototype.load = function(file) {
      this._loading = file;
      var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
      lines.forEach(function(line) {
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
        map[fields.shift()] = fields;
      });
      this.define(map);
      this._loading = null;
    };
    Mime.prototype.lookup = function(path5, fallback) {
      var ext = path5.replace(/^.*[\.\/\\]/, "").toLowerCase();
      return this.types[ext] || fallback || this.default_type;
    };
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    var mime = new Mime();
    mime.define(require_types());
    mime.default_type = mime.lookup("bin");
    mime.Mime = Mime;
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
      }
    };
    module2.exports = mime;
  }
});

// node_modules/buffer-equal/index.js
var require_buffer_equal = __commonJS({
  "node_modules/buffer-equal/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    module2.exports = function(a, b) {
      if (!Buffer2.isBuffer(a))
        return void 0;
      if (!Buffer2.isBuffer(b))
        return void 0;
      if (typeof a.equals === "function")
        return a.equals(b);
      if (a.length !== b.length)
        return false;
      for (var i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b[i2])
          return false;
      }
      return true;
    };
  }
});

// node_modules/load-bmfont/lib/is-binary.js
var require_is_binary = __commonJS({
  "node_modules/load-bmfont/lib/is-binary.js"(exports2, module2) {
    var equal = require_buffer_equal();
    var HEADER = Buffer.from([66, 77, 70, 3]);
    module2.exports = function(buf) {
      if (typeof buf === "string")
        return buf.substring(0, 3) === "BMF";
      return buf.length > 4 && equal(buf.slice(0, 4), HEADER);
    };
  }
});

// node_modules/load-bmfont/index.js
var require_load_bmfont = __commonJS({
  "node_modules/load-bmfont/index.js"(exports2, module2) {
    var fs = require("fs");
    var url = require("url");
    var path4 = require("path");
    var request = require_phin_compiled();
    var parseASCII = require_parse_bmfont_ascii();
    var parseXML = require_lib7();
    var readBinary = require_parse_bmfont_binary();
    var mime = require_mime2();
    var noop = function() {
    };
    var isBinary = require_is_binary();
    function parseFont(file, data, cb) {
      var result, binary;
      if (isBinary(data)) {
        if (typeof data === "string")
          data = Buffer.from(data, "binary");
        binary = true;
      } else
        data = data.toString().trim();
      try {
        if (binary)
          result = readBinary(data);
        else if (/json/.test(mime.lookup(file)) || data.charAt(0) === "{")
          result = JSON.parse(data);
        else if (/xml/.test(mime.lookup(file)) || data.charAt(0) === "<")
          result = parseXML(data);
        else
          result = parseASCII(data);
      } catch (e) {
        cb(e);
        cb = noop;
      }
      cb(null, result);
    }
    module2.exports = function loadFont(opt, cb) {
      cb = typeof cb === "function" ? cb : noop;
      if (typeof opt === "string")
        opt = { uri: opt, url: opt };
      else if (!opt)
        opt = {};
      var file = opt.uri || opt.url;
      function handleData(err, data) {
        if (err)
          return cb(err);
        parseFont(file, data.body || data, cb);
      }
      if (url.parse(file).host) {
        request(opt, handleData);
      } else {
        fs.readFile(file, opt, handleData);
      }
    };
  }
});

// node_modules/@jimp/plugin-print/dist/measure-text.js
var require_measure_text = __commonJS({
  "node_modules/@jimp/plugin-print/dist/measure-text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.measureText = measureText;
    exports2.measureTextHeight = measureTextHeight;
    exports2.splitLines = splitLines;
    function measureText(font, text) {
      let x = 0;
      for (let i2 = 0; i2 < text.length; i2++) {
        if (font.chars[text[i2]]) {
          const kerning = font.kernings[text[i2]] && font.kernings[text[i2]][text[i2 + 1]] ? font.kernings[text[i2]][text[i2 + 1]] : 0;
          x += (font.chars[text[i2]].xadvance || 0) + kerning;
        }
      }
      return x;
    }
    function splitLines(font, text, maxWidth) {
      const words = text.split(" ");
      const lines = [];
      let currentLine = [];
      let longestLine = 0;
      words.forEach((word) => {
        const line = [...currentLine, word].join(" ");
        const length = measureText(font, line);
        if (length <= maxWidth) {
          if (length > longestLine) {
            longestLine = length;
          }
          currentLine.push(word);
        } else {
          lines.push(currentLine);
          currentLine = [word];
        }
      });
      lines.push(currentLine);
      return {
        lines,
        longestLine
      };
    }
    function measureTextHeight(font, text, maxWidth) {
      const {
        lines
      } = splitLines(font, text, maxWidth);
      return lines.length * font.common.lineHeight;
    }
  }
});

// node_modules/@jimp/plugin-print/dist/index.js
var require_dist25 = __commonJS({
  "node_modules/@jimp/plugin-print/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _loadBmfont = _interopRequireDefault(require_load_bmfont());
    var _utils = require_dist();
    var _measureText = require_measure_text();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function xOffsetBasedOnAlignment(constants2, font, line, maxWidth, alignment) {
      if (alignment === constants2.HORIZONTAL_ALIGN_LEFT) {
        return 0;
      }
      if (alignment === constants2.HORIZONTAL_ALIGN_CENTER) {
        return (maxWidth - (0, _measureText.measureText)(font, line)) / 2;
      }
      return maxWidth - (0, _measureText.measureText)(font, line);
    }
    function drawCharacter(image2, font, x, y, char) {
      if (char.width > 0 && char.height > 0) {
        const characterPage = font.pages[char.page];
        image2.blit(characterPage, x + char.xoffset, y + char.yoffset, char.x, char.y, char.width, char.height);
      }
      return image2;
    }
    function printText(font, x, y, text, defaultCharWidth) {
      for (let i2 = 0; i2 < text.length; i2++) {
        let char;
        if (font.chars[text[i2]]) {
          char = text[i2];
        } else if (/\s/.test(text[i2])) {
          char = "";
        } else {
          char = "?";
        }
        const fontChar = font.chars[char] || {};
        const fontKerning = font.kernings[char];
        drawCharacter(this, font, x, y, fontChar || {});
        const kerning = fontKerning && fontKerning[text[i2 + 1]] ? fontKerning[text[i2 + 1]] : 0;
        x += kerning + (fontChar.xadvance || defaultCharWidth);
      }
    }
    function loadPages(Jimp, dir2, pages) {
      const newPages = pages.map((page) => {
        return Jimp.read(dir2 + "/" + page);
      });
      return Promise.all(newPages);
    }
    var dir = process.env.DIRNAME || `${__dirname}/../`;
    var _default = () => ({
      constants: {
        measureText: _measureText.measureText,
        measureTextHeight: _measureText.measureTextHeight,
        FONT_SANS_8_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
        FONT_SANS_10_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
        FONT_SANS_12_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
        FONT_SANS_14_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
        FONT_SANS_16_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
        FONT_SANS_32_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
        FONT_SANS_64_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
        FONT_SANS_128_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
        FONT_SANS_8_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
        FONT_SANS_16_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
        FONT_SANS_32_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
        FONT_SANS_64_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
        FONT_SANS_128_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
        /**
         * Loads a bitmap font from a file
         * @param {string} file the file path of a .fnt file
         * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded
         * @returns {Promise} a promise
         */
        loadFont(file, cb) {
          if (typeof file !== "string")
            return _utils.throwError.call(this, "file must be a string", cb);
          return new Promise((resolve5, reject2) => {
            cb = cb || function(err, font) {
              if (err)
                reject2(err);
              else
                resolve5(font);
            };
            (0, _loadBmfont.default)(file, (err, font) => {
              const chars = {};
              const kernings = {};
              if (err) {
                return _utils.throwError.call(this, err, cb);
              }
              for (let i2 = 0; i2 < font.chars.length; i2++) {
                chars[String.fromCharCode(font.chars[i2].id)] = font.chars[i2];
              }
              for (let i2 = 0; i2 < font.kernings.length; i2++) {
                const firstString = String.fromCharCode(font.kernings[i2].first);
                kernings[firstString] = kernings[firstString] || {};
                kernings[firstString][String.fromCharCode(font.kernings[i2].second)] = font.kernings[i2].amount;
              }
              loadPages(this, _path.default.dirname(file), font.pages).then((pages) => {
                cb(null, {
                  chars,
                  kernings,
                  pages,
                  common: font.common,
                  info: font.info
                });
              });
            });
          });
        }
      },
      class: {
        /**
         * Draws a text on a image on a given boundary
         * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command
         * @param {number} x the x position to start drawing the text
         * @param {number} y the y position to start drawing the text
         * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
         * @param {number} maxWidth (optional) the boundary width to draw in
         * @param {number} maxHeight (optional) the boundary height to draw in
         * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written
         * @returns {Jimp} this for chaining of methods
         */
        print(font, x, y, text, maxWidth, maxHeight, cb) {
          if (typeof maxWidth === "function" && typeof cb === "undefined") {
            cb = maxWidth;
            maxWidth = Infinity;
          }
          if (typeof maxWidth === "undefined") {
            maxWidth = Infinity;
          }
          if (typeof maxHeight === "function" && typeof cb === "undefined") {
            cb = maxHeight;
            maxHeight = Infinity;
          }
          if (typeof maxHeight === "undefined") {
            maxHeight = Infinity;
          }
          if (typeof font !== "object") {
            return _utils.throwError.call(this, "font must be a Jimp loadFont", cb);
          }
          if (typeof x !== "number" || typeof y !== "number" || typeof maxWidth !== "number") {
            return _utils.throwError.call(this, "x, y and maxWidth must be numbers", cb);
          }
          if (typeof maxWidth !== "number") {
            return _utils.throwError.call(this, "maxWidth must be a number", cb);
          }
          if (typeof maxHeight !== "number") {
            return _utils.throwError.call(this, "maxHeight must be a number", cb);
          }
          let alignmentX;
          let alignmentY;
          if (typeof text === "object" && text.text !== null && text.text !== void 0) {
            alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;
            alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
            ({
              text
            } = text);
          } else {
            alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;
            alignmentY = this.constructor.VERTICAL_ALIGN_TOP;
            text = text.toString();
          }
          if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {
            y += maxHeight - (0, _measureText.measureTextHeight)(font, text, maxWidth);
          } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {
            y += maxHeight / 2 - (0, _measureText.measureTextHeight)(font, text, maxWidth) / 2;
          }
          const defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;
          const {
            lines,
            longestLine
          } = (0, _measureText.splitLines)(font, text, maxWidth);
          lines.forEach((line) => {
            const lineString = line.join(" ");
            const alignmentWidth = xOffsetBasedOnAlignment(this.constructor, font, lineString, maxWidth, alignmentX);
            printText.call(this, font, x + alignmentWidth, y, lineString, defaultCharWidth);
            y += font.common.lineHeight;
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this, {
              x: x + longestLine,
              y
            });
          }
          return this;
        }
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-resize/dist/modules/resize.js
var require_resize = __commonJS({
  "node_modules/@jimp/plugin-resize/dist/modules/resize.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
      this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
      this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
      this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
      this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
      this.colorChannels = blendAlpha ? 4 : 3;
      this.interpolationPass = Boolean(interpolationPass);
      this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {
      };
      this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
      this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
      this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
      this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
      this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
      this.initialize();
    }
    Resize.prototype.initialize = function() {
      if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
        this.configurePasses();
      } else {
        throw new Error("Invalid settings specified for the resizer.");
      }
    };
    Resize.prototype.configurePasses = function() {
      if (this.widthOriginal === this.targetWidth) {
        this.resizeWidth = this.bypassResizer;
      } else {
        this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
        if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
          this.initializeFirstPassBuffers(true);
          this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
        } else {
          this.initializeFirstPassBuffers(false);
          this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
        }
      }
      if (this.heightOriginal === this.targetHeight) {
        this.resizeHeight = this.bypassResizer;
      } else {
        this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
        if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
          this.initializeSecondPassBuffers(true);
          this.resizeHeight = this.resizeHeightInterpolated;
        } else {
          this.initializeSecondPassBuffers(false);
          this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
        }
      }
    };
    Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
      const channelsNum = fourthChannel ? 4 : 3;
      const ratioWeight = this.ratioWeightWidthPass;
      const outputBuffer = this.widthBuffer;
      let weight = 0;
      let finalOffset = 0;
      let pixelOffset = 0;
      let firstWeight = 0;
      let secondWeight = 0;
      let targetPosition;
      for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
        for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
          outputBuffer[finalOffset] = buffer[pixelOffset];
          outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
          outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
          if (fourthChannel)
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
      }
      weight -= 1 / 3;
      let interpolationWidthSourceReadStop;
      for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
          outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
          outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
          outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
          if (fourthChannel)
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
        }
      }
      for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
        for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
          outputBuffer[finalOffset] = buffer[pixelOffset];
          outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
          outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
          if (fourthChannel)
            outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
        }
      }
      return outputBuffer;
    };
    Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
      const channelsNum = fourthChannel ? 4 : 3;
      const ratioWeight = this.ratioWeightWidthPass;
      const ratioWeightDivisor = 1 / ratioWeight;
      const nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
      const nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
      const output = this.outputWidthWorkBench;
      const outputBuffer = this.widthBuffer;
      const trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
      let weight = 0;
      let amountToNext = 0;
      let actualPosition = 0;
      let currentPosition = 0;
      let line = 0;
      let pixelOffset = 0;
      let outputOffset = 0;
      let multiplier = 1;
      let r = 0;
      let g = 0;
      let b = 0;
      let a = 0;
      do {
        for (line = 0; line < this.originalHeightMultipliedByChannels; ) {
          output[line++] = 0;
          output[line++] = 0;
          output[line++] = 0;
          if (fourthChannel) {
            output[line++] = 0;
            trustworthyColorsCount[line / channelsNum - 1] = 0;
          }
        }
        weight = ratioWeight;
        do {
          amountToNext = 1 + actualPosition - currentPosition;
          multiplier = Math.min(weight, amountToNext);
          for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
            r = buffer[pixelOffset];
            g = buffer[++pixelOffset];
            b = buffer[++pixelOffset];
            a = fourthChannel ? buffer[++pixelOffset] : 255;
            output[line++] += (a ? r : 0) * multiplier;
            output[line++] += (a ? g : 0) * multiplier;
            output[line++] += (a ? b : 0) * multiplier;
            if (fourthChannel) {
              output[line++] += a * multiplier;
              trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
            }
          }
          if (weight >= amountToNext) {
            actualPosition += channelsNum;
            currentPosition = actualPosition;
            weight -= amountToNext;
          } else {
            currentPosition += weight;
            break;
          }
        } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
        for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
          weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
          multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
          outputBuffer[pixelOffset] = output[line++] * multiplier;
          outputBuffer[++pixelOffset] = output[line++] * multiplier;
          outputBuffer[++pixelOffset] = output[line++] * multiplier;
          if (fourthChannel)
            outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
        }
        outputOffset += channelsNum;
      } while (outputOffset < this.targetWidthMultipliedByChannels);
      return outputBuffer;
    };
    Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
      const ratioWeight = this.ratioWeightHeightPass;
      const ratioWeightDivisor = 1 / ratioWeight;
      const output = this.outputHeightWorkBench;
      const outputBuffer = this.heightBuffer;
      const trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
      let weight = 0;
      let amountToNext = 0;
      let actualPosition = 0;
      let currentPosition = 0;
      let pixelOffset = 0;
      let outputOffset = 0;
      let caret = 0;
      let multiplier = 1;
      let r = 0;
      let g = 0;
      let b = 0;
      let a = 0;
      do {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          output[pixelOffset++] = 0;
          output[pixelOffset++] = 0;
          output[pixelOffset++] = 0;
          if (fourthChannel) {
            output[pixelOffset++] = 0;
            trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
          }
        }
        weight = ratioWeight;
        do {
          amountToNext = 1 + actualPosition - currentPosition;
          multiplier = Math.min(weight, amountToNext);
          caret = actualPosition;
          for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
            r = buffer[caret++];
            g = buffer[caret++];
            b = buffer[caret++];
            a = fourthChannel ? buffer[caret++] : 255;
            output[pixelOffset++] += (a ? r : 0) * multiplier;
            output[pixelOffset++] += (a ? g : 0) * multiplier;
            output[pixelOffset++] += (a ? b : 0) * multiplier;
            if (fourthChannel) {
              output[pixelOffset++] += a * multiplier;
              trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
            }
          }
          if (weight >= amountToNext) {
            actualPosition = caret;
            currentPosition = actualPosition;
            weight -= amountToNext;
          } else {
            currentPosition += weight;
            break;
          }
        } while (weight > 0 && actualPosition < this.widthPassResultSize);
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
          multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
          outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
          if (fourthChannel) {
            outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
          }
        }
      } while (outputOffset < this.finalResultSize);
      return outputBuffer;
    };
    Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
      return this._resizeWidthInterpolatedRGBChannels(buffer, false);
    };
    Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
      return this._resizeWidthInterpolatedRGBChannels(buffer, true);
    };
    Resize.prototype.resizeWidthRGB = function(buffer) {
      return this._resizeWidthRGBChannels(buffer, false);
    };
    Resize.prototype.resizeWidthRGBA = function(buffer) {
      return this._resizeWidthRGBChannels(buffer, true);
    };
    Resize.prototype.resizeHeightInterpolated = function(buffer) {
      const ratioWeight = this.ratioWeightHeightPass;
      const outputBuffer = this.heightBuffer;
      let weight = 0;
      let finalOffset = 0;
      let pixelOffset = 0;
      let pixelOffsetAccumulated = 0;
      let pixelOffsetAccumulated2 = 0;
      let firstWeight = 0;
      let secondWeight = 0;
      let interpolationHeightSourceReadStop;
      for (; weight < 1 / 3; weight += ratioWeight) {
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
          outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
        }
      }
      weight -= 1 / 3;
      for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
        secondWeight = weight % 1;
        firstWeight = 1 - secondWeight;
        pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
        pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
        for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
          outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
        }
      }
      while (finalOffset < this.finalResultSize) {
        for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
          outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
        }
      }
      return outputBuffer;
    };
    Resize.prototype.resizeHeightRGB = function(buffer) {
      return this._resizeHeightRGBChannels(buffer, false);
    };
    Resize.prototype.resizeHeightRGBA = function(buffer) {
      return this._resizeHeightRGBChannels(buffer, true);
    };
    Resize.prototype.resize = function(buffer) {
      this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
    };
    Resize.prototype.bypassResizer = function(buffer) {
      return buffer;
    };
    Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
      this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
      if (!BILINEARAlgo) {
        this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
        if (this.colorChannels > 3) {
          this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
        }
      }
    };
    Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
      this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
      if (!BILINEARAlgo) {
        this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
        if (this.colorChannels > 3) {
          this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
        }
      }
    };
    Resize.prototype.generateFloatBuffer = function(bufferLength) {
      try {
        return new Float32Array(bufferLength);
      } catch (error) {
        return [];
      }
    };
    Resize.prototype.generateFloat64Buffer = function(bufferLength) {
      try {
        return new Float64Array(bufferLength);
      } catch (error) {
        return [];
      }
    };
    Resize.prototype.generateUint8Buffer = function(bufferLength) {
      try {
        return new Uint8Array(bufferLength);
      } catch (error) {
        return [];
      }
    };
    var _default = Resize;
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-resize/dist/modules/resize2.js
var require_resize2 = __commonJS({
  "node_modules/@jimp/plugin-resize/dist/modules/resize2.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var operations = {
      nearestNeighbor(src, dst) {
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const bufSrc = src.data;
        const bufDst = dst.data;
        for (let i2 = 0; i2 < hDst; i2++) {
          for (let j = 0; j < wDst; j++) {
            let posDst = (i2 * wDst + j) * 4;
            const iSrc = Math.floor(i2 * hSrc / hDst);
            const jSrc = Math.floor(j * wSrc / wDst);
            let posSrc = (iSrc * wSrc + jSrc) * 4;
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
            bufDst[posDst++] = bufSrc[posSrc++];
          }
        }
      },
      bilinearInterpolation(src, dst) {
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const bufSrc = src.data;
        const bufDst = dst.data;
        const interpolate = function(k, kMin, vMin, kMax, vMax) {
          if (kMin === kMax) {
            return vMin;
          }
          return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
        };
        const assign = function(pos, offset, x, xMin, xMax, y, yMin, yMax) {
          let posMin = (yMin * wSrc + xMin) * 4 + offset;
          let posMax = (yMin * wSrc + xMax) * 4 + offset;
          const vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
          if (yMax === yMin) {
            bufDst[pos + offset] = vMin;
          } else {
            posMin = (yMax * wSrc + xMin) * 4 + offset;
            posMax = (yMax * wSrc + xMax) * 4 + offset;
            const vMax = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
            bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
          }
        };
        for (let i2 = 0; i2 < hDst; i2++) {
          for (let j = 0; j < wDst; j++) {
            const posDst = (i2 * wDst + j) * 4;
            const x = j * wSrc / wDst;
            const xMin = Math.floor(x);
            const xMax = Math.min(Math.ceil(x), wSrc - 1);
            const y = i2 * hSrc / hDst;
            const yMin = Math.floor(y);
            const yMax = Math.min(Math.ceil(y), hSrc - 1);
            assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
            assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
          }
        }
      },
      _interpolate2D(src, dst, options, interpolate) {
        const bufSrc = src.data;
        const bufDst = dst.data;
        const wSrc = src.width;
        const hSrc = src.height;
        const wDst = dst.width;
        const hDst = dst.height;
        const wM = Math.max(1, Math.floor(wSrc / wDst));
        const wDst2 = wDst * wM;
        const hM = Math.max(1, Math.floor(hSrc / hDst));
        const hDst2 = hDst * hM;
        const buf1 = Buffer.alloc(wDst2 * hSrc * 4);
        for (let i2 = 0; i2 < hSrc; i2++) {
          for (let j = 0; j < wDst2; j++) {
            const x = j * (wSrc - 1) / wDst2;
            const xPos = Math.floor(x);
            const t = x - xPos;
            const srcPos = (i2 * wSrc + xPos) * 4;
            const buf1Pos = (i2 * wDst2 + j) * 4;
            for (let k = 0; k < 4; k++) {
              const kPos = srcPos + k;
              const x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
              const x1 = bufSrc[kPos];
              const x2 = bufSrc[kPos + 4];
              const x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
              buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
            }
          }
        }
        const buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
        for (let i2 = 0; i2 < hDst2; i2++) {
          for (let j = 0; j < wDst2; j++) {
            const y = i2 * (hSrc - 1) / hDst2;
            const yPos = Math.floor(y);
            const t = y - yPos;
            const buf1Pos = (yPos * wDst2 + j) * 4;
            const buf2Pos = (i2 * wDst2 + j) * 4;
            for (let k = 0; k < 4; k++) {
              const kPos = buf1Pos + k;
              const y0 = yPos > 0 ? buf1[kPos - wDst2 * 4] : 2 * buf1[kPos] - buf1[kPos + wDst2 * 4];
              const y1 = buf1[kPos];
              const y2 = buf1[kPos + wDst2 * 4];
              const y3 = yPos < hSrc - 2 ? buf1[kPos + wDst2 * 8] : 2 * buf1[kPos + wDst2 * 4] - buf1[kPos];
              buf2[buf2Pos + k] = interpolate(y0, y1, y2, y3, t);
            }
          }
        }
        const m = wM * hM;
        if (m > 1) {
          for (let i2 = 0; i2 < hDst; i2++) {
            for (let j = 0; j < wDst; j++) {
              let r = 0;
              let g = 0;
              let b = 0;
              let a = 0;
              let realColors = 0;
              for (let y = 0; y < hM; y++) {
                const yPos = i2 * hM + y;
                for (let x = 0; x < wM; x++) {
                  const xPos = j * wM + x;
                  const xyPos = (yPos * wDst2 + xPos) * 4;
                  const pixelAlpha = buf2[xyPos + 3];
                  if (pixelAlpha) {
                    r += buf2[xyPos];
                    g += buf2[xyPos + 1];
                    b += buf2[xyPos + 2];
                    realColors++;
                  }
                  a += pixelAlpha;
                }
              }
              const pos = (i2 * wDst + j) * 4;
              bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
              bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
              bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
              bufDst[pos + 3] = Math.round(a / m);
            }
          }
        } else {
          dst.data = buf2;
        }
      },
      bicubicInterpolation(src, dst, options) {
        const interpolateCubic = function(x0, x1, x2, x3, t) {
          const a0 = x3 - x2 - x0 + x1;
          const a1 = x0 - x1 - a0;
          const a2 = x2 - x0;
          const a3 = x1;
          return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
        };
        return this._interpolate2D(src, dst, options, interpolateCubic);
      },
      hermiteInterpolation(src, dst, options) {
        const interpolateHermite = function(x0, x1, x2, x3, t) {
          const c0 = x1;
          const c1 = 0.5 * (x2 - x0);
          const c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
          const c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
          return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
        };
        return this._interpolate2D(src, dst, options, interpolateHermite);
      },
      bezierInterpolation(src, dst, options) {
        const interpolateBezier = function(x0, x1, x2, x3, t) {
          const cp1 = x1 + (x2 - x0) / 4;
          const cp2 = x2 - (x3 - x1) / 4;
          const nt = 1 - t;
          const c0 = x1 * nt * nt * nt;
          const c1 = 3 * cp1 * nt * nt * t;
          const c2 = 3 * cp2 * nt * t * t;
          const c3 = x2 * t * t * t;
          return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
        };
        return this._interpolate2D(src, dst, options, interpolateBezier);
      }
    };
    var _default = operations;
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-resize/dist/index.js
var require_dist26 = __commonJS({
  "node_modules/@jimp/plugin-resize/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _resize = _interopRequireDefault(require_resize());
    var _resize2 = _interopRequireDefault(require_resize2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = () => ({
      constants: {
        RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
        RESIZE_BILINEAR: "bilinearInterpolation",
        RESIZE_BICUBIC: "bicubicInterpolation",
        RESIZE_HERMITE: "hermiteInterpolation",
        RESIZE_BEZIER: "bezierInterpolation"
      },
      class: {
        /**
         * Resizes the image to a set width and height using a 2-pass bilinear algorithm
         * @param {number} w the width to resize the image to (or Jimp.AUTO)
         * @param {number} h the height to resize the image to (or Jimp.AUTO)
         * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
         * @param {function(Error, Jimp)} cb (optional) a callback for when complete
         * @returns {Jimp} this for chaining of methods
         */
        resize(w, h, mode, cb) {
          if (typeof w !== "number" || typeof h !== "number") {
            return _utils.throwError.call(this, "w and h must be numbers", cb);
          }
          if (typeof mode === "function" && typeof cb === "undefined") {
            cb = mode;
            mode = null;
          }
          if (w === this.constructor.AUTO && h === this.constructor.AUTO) {
            return _utils.throwError.call(this, "w and h cannot both be set to auto", cb);
          }
          if (w === this.constructor.AUTO) {
            w = this.bitmap.width * (h / this.bitmap.height);
          }
          if (h === this.constructor.AUTO) {
            h = this.bitmap.height * (w / this.bitmap.width);
          }
          if (w < 0 || h < 0) {
            return _utils.throwError.call(this, "w and h must be positive numbers", cb);
          }
          w = Math.round(w) || 1;
          h = Math.round(h) || 1;
          if (typeof _resize2.default[mode] === "function") {
            const dst = {
              data: Buffer.alloc(w * h * 4),
              width: w,
              height: h
            };
            _resize2.default[mode](this.bitmap, dst);
            this.bitmap = dst;
          } else {
            const image2 = this;
            const resize = new _resize.default(this.bitmap.width, this.bitmap.height, w, h, true, true, (buffer) => {
              image2.bitmap.data = Buffer.from(buffer);
              image2.bitmap.width = w;
              image2.bitmap.height = h;
            });
            resize.resize(this.bitmap.data);
          }
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-rotate/dist/index.js
var require_dist27 = __commonJS({
  "node_modules/@jimp/plugin-rotate/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    function matrixRotate(deg) {
      if (Math.abs(deg) % 90 !== 0) {
        throw new Error("Unsupported matrix rotation degree");
      }
      deg %= 360;
      if (Math.abs(deg) === 0) {
        return;
      }
      const w = this.bitmap.width;
      const h = this.bitmap.height;
      let angle;
      switch (deg) {
        case 90:
        case -270:
          angle = 90;
          break;
        case 180:
        case -180:
          angle = 180;
          break;
        case 270:
        case -90:
          angle = -90;
          break;
        default:
          throw new Error("Unsupported matrix rotation degree");
      }
      const nW = angle === 180 ? w : h;
      const nH = angle === 180 ? h : w;
      const dstBuffer = Buffer.alloc(this.bitmap.data.length);
      function createIdxTranslationFunction(w2, h2) {
        return function(x, y) {
          return y * w2 + x << 2;
        };
      }
      const srcIdxFunction = createIdxTranslationFunction(w, h);
      const dstIdxFunction = createIdxTranslationFunction(nW, nH);
      for (let x = 0; x < w; x++) {
        for (let y = 0; y < h; y++) {
          const srcIdx = srcIdxFunction(x, y);
          const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
          let dstIdx;
          switch (angle) {
            case 90:
              dstIdx = dstIdxFunction(y, w - x - 1);
              break;
            case -90:
              dstIdx = dstIdxFunction(h - y - 1, x);
              break;
            case 180:
              dstIdx = dstIdxFunction(w - x - 1, h - y - 1);
              break;
            default:
              throw new Error("Unsupported matrix rotation angle");
          }
          dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
        }
      }
      this.bitmap.data = dstBuffer;
      this.bitmap.width = nW;
      this.bitmap.height = nH;
    }
    function advancedRotate(deg, mode) {
      deg %= 360;
      const rad = deg * Math.PI / 180;
      const cosine = Math.cos(rad);
      const sine = Math.sin(rad);
      let w = this.bitmap.width;
      let h = this.bitmap.height;
      if (mode === true || typeof mode === "string") {
        w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
        h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;
        if (w % 2 !== 0) {
          w++;
        }
        if (h % 2 !== 0) {
          h++;
        }
        const c = this.cloneQuiet();
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
          this.bitmap.data.writeUInt32BE(this._background, idx);
        });
        const max2 = Math.max(w, h, this.bitmap.width, this.bitmap.height);
        this.resize(max2, max2, mode);
        this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
      }
      const bW = this.bitmap.width;
      const bH = this.bitmap.height;
      const dstBuffer = Buffer.alloc(this.bitmap.data.length);
      function createTranslationFunction(deltaX, deltaY) {
        return function(x, y) {
          return {
            x: x + deltaX,
            y: y + deltaY
          };
        };
      }
      const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
      const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
      for (let y = 1; y <= bH; y++) {
        for (let x = 1; x <= bW; x++) {
          const cartesian = translate2Cartesian(x, y);
          const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
          const dstIdx = bW * (y - 1) + x - 1 << 2;
          if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
            const srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
            const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
            dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
          } else {
            dstBuffer.writeUInt32BE(this._background, dstIdx);
          }
        }
      }
      this.bitmap.data = dstBuffer;
      if (mode === true || typeof mode === "string") {
        const x = bW / 2 - w / 2;
        const y = bH / 2 - h / 2;
        this.crop(x, y, w, h);
      }
    }
    var _default = () => ({
      /**
       * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
       * @param {number} deg the number of degrees to rotate the image by
       * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      rotate(deg, mode, cb) {
        if (typeof mode === "undefined" || mode === null) {
          mode = true;
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = true;
        }
        if (typeof deg !== "number") {
          return _utils.throwError.call(this, "deg must be a number", cb);
        }
        if (typeof mode !== "boolean" && typeof mode !== "string") {
          return _utils.throwError.call(this, "mode must be a boolean or a string", cb);
        }
        const matrixRotateAllowed = deg % 90 === 0 && (mode || this.bitmap.width === this.bitmap.height || deg % 180 === 0);
        if (matrixRotateAllowed) {
          matrixRotate.call(this, deg);
        } else {
          advancedRotate.call(this, deg, mode, cb);
        }
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-scale/dist/index.js
var require_dist28 = __commonJS({
  "node_modules/@jimp/plugin-scale/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      /**
       * Uniformly scales the image by a factor.
       * @param {number} f the factor to scale the image by
       * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      scale(f, mode, cb) {
        if (typeof f !== "number") {
          return _utils.throwError.call(this, "f must be a number", cb);
        }
        if (f < 0) {
          return _utils.throwError.call(this, "f must be a positive number", cb);
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        const w = this.bitmap.width * f;
        const h = this.bitmap.height * f;
        this.resize(w, h, mode);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      },
      /**
       * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
       * @param {number} w the width to resize the image to
       * @param {number} h the height to resize the image to
       * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
       * @param {function(Error, Jimp)} cb (optional) a callback for when complete
       * @returns {Jimp} this for chaining of methods
       */
      scaleToFit(w, h, mode, cb) {
        if (typeof w !== "number" || typeof h !== "number") {
          return _utils.throwError.call(this, "w and h must be numbers", cb);
        }
        if (typeof mode === "function" && typeof cb === "undefined") {
          cb = mode;
          mode = null;
        }
        const f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
        this.scale(f, mode);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-shadow/dist/index.js
var require_dist29 = __commonJS({
  "node_modules/@jimp/plugin-shadow/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      shadow() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let cb = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        const {
          opacity = 0.7,
          size = 1.1,
          x = -25,
          y = 25,
          blur = 5
        } = options;
        const orig = this.clone();
        const shadow = this.clone();
        shadow.scan(0, 0, shadow.bitmap.width, shadow.bitmap.height, (x2, y2, idx) => {
          shadow.bitmap.data[idx] = 0;
          shadow.bitmap.data[idx + 1] = 0;
          shadow.bitmap.data[idx + 2] = 0;
          shadow.bitmap.data[idx + 3] = shadow.constructor.limit255(shadow.bitmap.data[idx + 3] * opacity);
          this.bitmap.data[idx] = 0;
          this.bitmap.data[idx + 1] = 0;
          this.bitmap.data[idx + 2] = 0;
          this.bitmap.data[idx + 3] = 0;
        });
        shadow.resize(shadow.bitmap.width * size, shadow.bitmap.height * size).blur(blur);
        this.composite(shadow, x, y);
        this.composite(orig, 0, 0);
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugin-threshold/dist/index.js
var require_dist30 = __commonJS({
  "node_modules/@jimp/plugin-threshold/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_dist();
    var _default = () => ({
      threshold(_ref, cb) {
        let {
          max: max2,
          replace = 255,
          autoGreyscale = true
        } = _ref;
        if (typeof max2 !== "number") {
          return _utils.throwError.call(this, "max must be a number", cb);
        }
        if (typeof replace !== "number") {
          return _utils.throwError.call(this, "replace must be a number", cb);
        }
        if (typeof autoGreyscale !== "boolean") {
          return _utils.throwError.call(this, "autoGreyscale must be a boolean", cb);
        }
        max2 = this.constructor.limit255(max2);
        replace = this.constructor.limit255(replace);
        if (autoGreyscale) {
          this.greyscale();
        }
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
          const grey = this.bitmap.data[idx] < max2 ? this.bitmap.data[idx] : replace;
          this.bitmap.data[idx] = grey;
          this.bitmap.data[idx + 1] = grey;
          this.bitmap.data[idx + 2] = grey;
        });
        if ((0, _utils.isNodePattern)(cb)) {
          cb.call(this, null, this);
        }
        return this;
      }
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/@jimp/plugins/dist/index.js
var require_dist31 = __commonJS({
  "node_modules/@jimp/plugins/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _timm = require_timm();
    var _pluginBlit = _interopRequireDefault(require_dist10());
    var _pluginBlur = _interopRequireDefault(require_dist11());
    var _pluginCircle = _interopRequireDefault(require_dist12());
    var _pluginColor = _interopRequireDefault(require_dist13());
    var _pluginContain = _interopRequireDefault(require_dist14());
    var _pluginCover = _interopRequireDefault(require_dist15());
    var _pluginCrop = _interopRequireDefault(require_dist16());
    var _pluginDisplace = _interopRequireDefault(require_dist17());
    var _pluginDither = _interopRequireDefault(require_dist18());
    var _pluginFisheye = _interopRequireDefault(require_dist19());
    var _pluginFlip = _interopRequireDefault(require_dist20());
    var _pluginGaussian = _interopRequireDefault(require_dist21());
    var _pluginInvert = _interopRequireDefault(require_dist22());
    var _pluginMask = _interopRequireDefault(require_dist23());
    var _pluginNormalize = _interopRequireDefault(require_dist24());
    var _pluginPrint = _interopRequireDefault(require_dist25());
    var _pluginResize = _interopRequireDefault(require_dist26());
    var _pluginRotate = _interopRequireDefault(require_dist27());
    var _pluginScale = _interopRequireDefault(require_dist28());
    var _pluginShadow = _interopRequireDefault(require_dist29());
    var _pluginThreshold = _interopRequireDefault(require_dist30());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var plugins = [_pluginBlit.default, _pluginBlur.default, _pluginCircle.default, _pluginColor.default, _pluginContain.default, _pluginCover.default, _pluginCrop.default, _pluginDisplace.default, _pluginDither.default, _pluginFisheye.default, _pluginFlip.default, _pluginGaussian.default, _pluginInvert.default, _pluginMask.default, _pluginNormalize.default, _pluginPrint.default, _pluginResize.default, _pluginRotate.default, _pluginScale.default, _pluginShadow.default, _pluginThreshold.default];
    var _default = (jimpEvChange) => {
      const initializedPlugins = plugins.map((pluginModule) => {
        let plugin = pluginModule(jimpEvChange) || {};
        if (!plugin.class && !plugin.constants) {
          plugin = {
            class: plugin
          };
        }
        return plugin;
      });
      return (0, _timm.mergeDeep)(...initializedPlugins);
    };
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// node_modules/jimp/dist/index.js
var require_dist32 = __commonJS({
  "node_modules/jimp/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _custom = _interopRequireDefault(require_dist3());
    var _types = _interopRequireDefault(require_dist9());
    var _plugins = _interopRequireDefault(require_dist31());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = (0, _custom.default)({
      types: [_types.default],
      plugins: [_plugins.default]
    });
    exports2.default = _default;
    module2.exports = exports2.default;
    module2.exports.default = exports2.default;
  }
});

// index.mjs
var import_prompt = __toESM(require_prompt(), 1);
var import_jimp = __toESM(require_dist32(), 1);

// ../../../../t4apiwrapper/t4.ts/esm/lib/utility/Global.js
var max = 999999;
var min = 1e5;
var MediaTypeCodes;
(function(MediaTypeCodes2) {
  MediaTypeCodes2[MediaTypeCodes2["Image"] = 1] = "Image";
  MediaTypeCodes2[MediaTypeCodes2["MicrosoftOfficeDocument"] = 2] = "MicrosoftOfficeDocument";
  MediaTypeCodes2[MediaTypeCodes2["PDF"] = 3] = "PDF";
  MediaTypeCodes2[MediaTypeCodes2["StylesheetCss"] = 4] = "StylesheetCss";
  MediaTypeCodes2[MediaTypeCodes2["JavascriptFileProgrammableLayout"] = 5] = "JavascriptFileProgrammableLayout";
  MediaTypeCodes2[MediaTypeCodes2["Font"] = 6] = "Font";
  MediaTypeCodes2[MediaTypeCodes2["PHP"] = 7] = "PHP";
  MediaTypeCodes2[MediaTypeCodes2["JavascriptFileOnPageJavascript"] = 8] = "JavascriptFileOnPageJavascript";
  MediaTypeCodes2[MediaTypeCodes2["WebDavCSS"] = 9] = "WebDavCSS";
  MediaTypeCodes2[MediaTypeCodes2["ImageGallery"] = 10] = "ImageGallery";
  MediaTypeCodes2[MediaTypeCodes2["MP3"] = 11] = "MP3";
  MediaTypeCodes2[MediaTypeCodes2["XMLDocument"] = 12] = "XMLDocument";
  MediaTypeCodes2[MediaTypeCodes2["XBM"] = 13] = "XBM";
  MediaTypeCodes2[MediaTypeCodes2["MP4"] = 14] = "MP4";
  MediaTypeCodes2[MediaTypeCodes2["Text"] = 15] = "Text";
  MediaTypeCodes2[MediaTypeCodes2["ASPX"] = 16] = "ASPX";
  MediaTypeCodes2[MediaTypeCodes2["KML"] = 17] = "KML";
  MediaTypeCodes2[MediaTypeCodes2["ZIP"] = 18] = "ZIP";
  MediaTypeCodes2[MediaTypeCodes2["wat"] = 19] = "wat";
  MediaTypeCodes2[MediaTypeCodes2["CSV"] = 20] = "CSV";
  MediaTypeCodes2[MediaTypeCodes2["ICS"] = 21] = "ICS";
  MediaTypeCodes2[MediaTypeCodes2["Mobileconfig"] = 22] = "Mobileconfig";
  MediaTypeCodes2[MediaTypeCodes2["htaccess"] = 23] = "htaccess";
  MediaTypeCodes2[MediaTypeCodes2["DXF"] = 24] = "DXF";
  MediaTypeCodes2[MediaTypeCodes2["JSON"] = 25] = "JSON";
  MediaTypeCodes2[MediaTypeCodes2["Ebook"] = 26] = "Ebook";
  MediaTypeCodes2[MediaTypeCodes2["PHAR"] = 27] = "PHAR";
  MediaTypeCodes2[MediaTypeCodes2["iCal"] = 28] = "iCal";
  MediaTypeCodes2[MediaTypeCodes2["CommonCartridgeCanvasCourse"] = 29] = "CommonCartridgeCanvasCourse";
  MediaTypeCodes2[MediaTypeCodes2["Javascript"] = 30] = "Javascript";
})(MediaTypeCodes || (MediaTypeCodes = {}));
var SyntaxTypeCodes;
(function(SyntaxTypeCodes2) {
  SyntaxTypeCodes2[SyntaxTypeCodes2["None"] = 0] = "None";
  SyntaxTypeCodes2[SyntaxTypeCodes2["Javascript"] = 1] = "Javascript";
  SyntaxTypeCodes2[SyntaxTypeCodes2["CSS"] = 2] = "CSS";
  SyntaxTypeCodes2[SyntaxTypeCodes2["HTML"] = 3] = "HTML";
  SyntaxTypeCodes2[SyntaxTypeCodes2["PHP"] = 4] = "PHP";
  SyntaxTypeCodes2[SyntaxTypeCodes2["Java"] = 5] = "Java";
})(SyntaxTypeCodes || (SyntaxTypeCodes = {}));
function MediaUploadData(data) {
  return {
    name: data.name,
    description: data.description,
    type: String(data.type),
    file: new Blob(),
    syntaxType: String(data.syntaxType || 0),
    myMedia: String(data.myMedia || 0),
    elements: JSON.stringify({ "keywords#9:undefined": `${data.keywords?.join(", ") || ""}` }),
    version: data.version || "undefined",
    binaryLanguage: data.binaryLanguage || "smxx",
    fileName: String(data.fileName),
    language: data.language || "smxx",
    categories: String(data.categoryID)
  };
}
function contentUploadData(options) {
  const { archiveSection, canPublishNow, canSaveAndApprove, channels, contentTypeID, elements, excludedMirrorSectionIds, expiryDate, language, owner, publishDate, reviewDate, status } = options;
  return {
    archiveSection,
    canPublishNow,
    canSaveAndApprove,
    channels,
    contentTypeID,
    elements,
    excludedMirrorSectionIds: excludedMirrorSectionIds || [],
    expiryDate,
    language,
    owner: owner || { id: 0, type: "USER" },
    publishDate,
    reviewDate,
    status,
    id: Math.floor(-Math.abs(Math.random() * (max - min) + min))
  };
}

// ../../../../t4apiwrapper/t4.ts/esm/lib/Content.js
var ContentEndpoint = "content";
var Content = class {
  client;
  util;
  constructor(client) {
    this.client = client;
    this.util = {
      getElementNames: (elements) => {
        return elements.reduce((elementObj, { alias, name: name2, id, type }) => {
          elementObj[alias || name2] = `${name2}#${id}:${type}`;
          return elementObj;
        }, {});
      },
      lazyMap: (elements, formattedNames) => {
        let newElements = {};
        Object.keys(elements).forEach((key) => {
          if (formattedNames.hasOwnProperty(key)) {
            newElements[formattedNames[key]] = elements[key];
          }
        });
        return newElements;
      }
    };
  }
  async getVersions(contentId, language = this.client.language) {
    const response = await this.client.call("GET", `${ContentEndpoint}/${contentId}/${language}/version`, null);
    let jsonResp = await response.json();
    if (jsonResp.errorText) {
      jsonResp = await this.client.version.get(contentId, language);
    }
    return jsonResp;
  }
  async get(contentId, sectionId, language = this.client.language) {
    const response = await this.client.call("GET", `${ContentEndpoint}/${sectionId}/${contentId}/${language}`, null);
    return await response.json();
  }
  async getWithoutSection(contentId, version, language = this.client.language) {
    if (!version)
      version = (await this.getVersions(contentId, language))[0].version;
    const response = await this.client.call("GET", `${ContentEndpoint}/${contentId}/${language}/version/${version}`, null);
    return await response.json();
  }
  async delete(contentId, sectionId, language = this.client.language) {
    const response = await this.client.call("DELETE", `${ContentEndpoint}/${sectionId}/${contentId}/${language}`, null);
    return response?.ok;
  }
  async create(sectionId, options, isFormatted = false) {
    const { channels, canPublishNow, canSaveAndApprove, contentType } = await this.prePopulateContentInfo(options.contentTypeID, sectionId);
    if (!isFormatted) {
      const formattedElementNames = this.util.getElementNames(contentType.contentTypeElements);
      options.elements = this.util.lazyMap(options.elements, formattedElementNames);
    }
    const uploadData = contentUploadData({
      channels,
      canPublishNow,
      canSaveAndApprove,
      ...options
    });
    const response = await this.client.call("POST", `${ContentEndpoint}/${sectionId}/${options.language}?prepareForEditor=true`, {
      body: uploadData
    });
    return await response.json();
  }
  async prePopulateContentInfo(contentTypeId, sectionId) {
    const response = await this.client.call("GET", `${ContentEndpoint}/type/${contentTypeId}/${sectionId}`, null);
    return await response.json();
  }
  async listLinkContent(sectionId) {
    const response = await this.client.call("GET", `${ContentEndpoint}/link/${sectionId}`, null);
    return await response.json();
  }
  async modify(contentId, sectionId, options, language = this.client.language) {
    let existingContent = await this.get(contentId, sectionId, language);
    if (!existingContent)
      throw Error(`Content ${contentId} in section ${sectionId} does not exist`);
    const response = await this.client.call("POST", `${ContentEndpoint}/${sectionId}/${contentId}/${language}`, {
      body: {
        ...existingContent,
        ...options,
        elements: {
          ...existingContent.elements,
          ...options.elements
        }
      }
    });
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/ContentType.js
var ContentTypeEndpoint = "contenttype";
var ContentType = class {
  clinet;
  constructor(client) {
    this.clinet = client;
  }
  async list() {
    const response = await this.clinet.call("GET", ContentTypeEndpoint, null);
    return await response.json();
  }
  async get(contentTypeId) {
    const response = await this.clinet.call("GET", `${ContentTypeEndpoint}/${contentTypeId}`, null);
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/Download.js
var DownloadEndpoint = "download";
var Download = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async getFileFromElement(element, contentId, language = this.client.language) {
    const response = await this.client.call("GET", `${DownloadEndpoint}/${contentId}/${language}/${element}`, null);
    return await response.json();
  }
  async getFileFromElementVersion(element, contentId, version, language) {
    const response = await this.client.call("GET", `${DownloadEndpoint}/${contentId}/${language}/${version}/${element}`, null);
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/FormBuilder.js
var FormBuilderEndpoint = "formbuilder";
var FormBuilder = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async list(language = this.client.language) {
    const response = await this.client.call("POST", `${FormBuilderEndpoint}/${language}`, {
      body: "draw=5&columns%5B0%5D%5Bdata%5D=0&columns%5B0%5D%5Bname%5D=name&columns%5B0%5D%5Bsearchable%5D=true&columns%5B0%5D%5Borderable%5D=true&columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B1%5D%5Bdata%5D=lastModified&columns%5B1%5D%5Bname%5D=lastModified&columns%5B1%5D%5Bsearchable%5D=true&columns%5B1%5D%5Borderable%5D=true&columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B2%5D%5Bdata%5D=2&columns%5B2%5D%5Bname%5D=usage&columns%5B2%5D%5Bsearchable%5D=true&columns%5B2%5D%5Borderable%5D=false&columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B3%5D%5Bdata%5D=3&columns%5B3%5D%5Bname%5D=actions&columns%5B3%5D%5Bsearchable%5D=true&columns%5B3%5D%5Borderable%5D=false&columns%5B3%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B3%5D%5Bsearch%5D%5Bregex%5D=false&order%5B0%5D%5Bcolumn%5D=0&order%5B0%5D%5Bdir%5D=asc&start=0&length=-1&search%5Bvalue%5D=&search%5Bregex%5D=false",
      headers: {
        "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
      }
    });
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/Hierarchy.js
var HierarchyEndpoint = "hierarchy";
var Hierarchy = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async get(id, language = this.client.language) {
    const response = await this.client.call("GET", `${HierarchyEndpoint}/${id}/${language}`, null);
    return await response.json();
  }
  async getSection(id, options) {
    const response = await this.client.call("POST", `${HierarchyEndpoint}/section`, {
      body: {
        read: {
          section: { id, language: "en" },
          activeNode: id,
          openNodes: [id],
          recursionDepth: -1,
          restrictedToPermitedSections: false,
          showContentInfo: true,
          showAllSections: true,
          expandCollapseAllChildren: true,
          ...options
        }
      }
    });
    const json = await response.json();
    return json[0] || json;
  }
  async getContents(id, options) {
    const response = await this.client.call("POST", `${HierarchyEndpoint}/content`, {
      body: {
        read: {
          section: { id, language: "en" },
          activeNode: id,
          openNodes: [id],
          recursionDepth: 1,
          restrictedToPermitedSections: false,
          showContentInfo: true,
          showAllSections: true,
          expandCollapseAllChildren: true,
          ...options
        }
      }
    });
    return await response.json();
  }
  async delete(id, isMandatory) {
    const response = await this.client.call("DELETE", `${HierarchyEndpoint}/${id}${isMandatory ? "?mandatory=true" : ""}`, null);
    return response?.ok;
  }
  async update(id, options, language = this.client.language) {
    const section = await this.get(id, language);
    const response = await this.client.call("PUT", `${HierarchyEndpoint}/${id}/${language}`, { body: Object.assign({}, section, options) });
    return response?.ok;
  }
  async add(parentID, options, language = this.client.language) {
    const response = await this.client.call("POST", `${HierarchyEndpoint}/${language}`, {
      body: {
        parent: parentID,
        ...options
      }
    });
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/utility/helpers.js
async function* batch(tasks, limit, callback = (obj) => obj) {
  for (let i2 = 0; i2 < tasks.length; i2 = i2 + limit) {
    const batch2 = tasks.slice(i2, i2 + limit);
    const result = await Promise.all(batch2.map((task) => callback(task)));
    yield result;
  }
}
async function batcher(tasks, limit, timeout, callback) {
  let results = [];
  for await (const item2 of batch(tasks, limit, callback)) {
    results = results.concat(item2);
    await wait(timeout);
  }
  return results;
}
function wait(ms) {
  return new Promise((resolve5) => {
    setTimeout(() => resolve5(), ms);
  });
}

// ../../../../t4apiwrapper/t4.ts/esm/lib/Media.js
var path2 = __toESM(require("path"), 1);
var import_promises = require("fs/promises");
var MediaEndpoint = "media";
var Media = class {
  client;
  util;
  constructor(client) {
    this.client = client;
    this.util = {
      getMediaIDs: async (parentID, arrLimit = 50, reqTimeout = 1e4) => {
        const structure = await this.client.mediaCategory.list(parentID, "en");
        let categoryIds = [];
        const populateIds = (category) => {
          if (category?.id)
            categoryIds.push(category.id);
          if (category?.children?.length)
            category.children.map((cat) => populateIds(cat));
        };
        populateIds(structure[0]);
        const list = async (id) => await client.media.list(id, "en");
        const categories = await batcher(categoryIds, arrLimit, reqTimeout, list);
        const IdList = categories.map((category) => category.mediaRows.map((row) => row.id));
        return IdList.flat(Infinity);
      }
    };
  }
  async add(data) {
    const formData = new FormData();
    const expandedData = MediaUploadData(data);
    const filePath = path2.resolve(data.file);
    if (!await (0, import_promises.stat)(filePath))
      throw Error(`File at ${filePath} does not exist.`);
    if (!expandedData.fileName || expandedData.fileName == "undefined")
      expandedData.fileName = path2.basename(filePath);
    const blob = new Blob([await (0, import_promises.readFile)(filePath)]);
    for (let key in expandedData) {
      key == "file" ? formData.append("file", blob, expandedData.fileName) : formData.append(key, expandedData[key]);
    }
    const response = await this.client.call("POST", `${MediaEndpoint}`, { body: formData });
    return await response.json();
  }
  async get(contentId, language = this.client.language) {
    const response = await this.client.call("GET", `${MediaEndpoint}/${contentId}/${language}`, null);
    return await response.json();
  }
  async getMediaUsage(mediaID, language = this.client.language) {
    const response = await this.client.call("GET", `${MediaEndpoint}/${mediaID}/${language}/usage`, null);
    return await response.json();
  }
  async bulkGetMediaUsage(mediaIDs, language = this.client.language) {
    const response = await this.client.call("POST", `${MediaEndpoint}/getUsage/${language}`, { body: mediaIDs });
    return await response.json();
  }
  async list(categoryID, language = this.client.language) {
    const response = await this.client.call("POST", `${MediaEndpoint}/category/${categoryID}/${language}/list?showPending=true&showUntranslated=true`, {
      body: "draw=1&columns%5B0%5D%5Bdata%5D=0&columns%5B0%5D%5Bname%5D=&columns%5B0%5D%5Bsearchable%5D=true&columns%5B0%5D%5Borderable%5D=false&columns%5B0%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B0%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B1%5D%5Bdata%5D=1&columns%5B1%5D%5Bname%5D=&columns%5B1%5D%5Bsearchable%5D=true&columns%5B1%5D%5Borderable%5D=true&columns%5B1%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B1%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B2%5D%5Bdata%5D=2&columns%5B2%5D%5Bname%5D=&columns%5B2%5D%5Bsearchable%5D=true&columns%5B2%5D%5Borderable%5D=true&columns%5B2%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B2%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B3%5D%5Bdata%5D=3&columns%5B3%5D%5Bname%5D=&columns%5B3%5D%5Bsearchable%5D=true&columns%5B3%5D%5Borderable%5D=true&columns%5B3%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B3%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B4%5D%5Bdata%5D=4&columns%5B4%5D%5Bname%5D=&columns%5B4%5D%5Bsearchable%5D=true&columns%5B4%5D%5Borderable%5D=true&columns%5B4%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B4%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B5%5D%5Bdata%5D=5&columns%5B5%5D%5Bname%5D=&columns%5B5%5D%5Bsearchable%5D=true&columns%5B5%5D%5Borderable%5D=true&columns%5B5%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B5%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B6%5D%5Bdata%5D=6&columns%5B6%5D%5Bname%5D=&columns%5B6%5D%5Bsearchable%5D=true&columns%5B6%5D%5Borderable%5D=false&columns%5B6%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B6%5D%5Bsearch%5D%5Bregex%5D=false&columns%5B7%5D%5Bdata%5D=7&columns%5B7%5D%5Bname%5D=&columns%5B7%5D%5Bsearchable%5D=true&columns%5B7%5D%5Borderable%5D=false&columns%5B7%5D%5Bsearch%5D%5Bvalue%5D=&columns%5B7%5D%5Bsearch%5D%5Bregex%5D=false&order%5B0%5D%5Bcolumn%5D=5&order%5B0%5D%5Bdir%5D=desc&start=0&length=10&search%5Bvalue%5D=&search%5Bregex%5D=false",
      headers: {
        "content-type": "application/x-www-form-urlencoded;charset=UTF-8"
      }
    });
    return await response.json();
  }
  async downloadSingle(id, type, version) {
    if (!version)
      version = (await this.client.content.getVersions(id, "smxx"))[0].version;
    const inital = await this.client.call("GET", `${MediaEndpoint}/${id}/smxx/${version}/${type}`, { redirect: "manual" });
    if (inital.status != 302)
      return null;
    const fileURL = await inital.text();
    const response = await fetch(fileURL);
    return await response.arrayBuffer();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/MediaCategory.js
var MediaCategoryEndpoint = "mediacategory";
var MediaCategory = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async list(categoryID, language) {
    const response = await this.client.call("POST", MediaCategoryEndpoint, {
      body: {
        category: {
          id: categoryID,
          language
        },
        recursionDepth: -1,
        explode: true,
        activeNode: -1,
        showInactive: true,
        showMyMedia: false
      }
    });
    return await response.json();
  }
  async get(categoryID, language = this.client.language) {
    const response = await this.client.call("GET", `${MediaCategoryEndpoint}/${categoryID}/${language}`, null);
    return await response.json();
  }
  async update(categoryID, options, language = this.client.language) {
    const current = await this.get(categoryID, language), newObj = Object.assign({}, current, options);
    const response = await this.client.call("PUT", `${MediaCategoryEndpoint}/${categoryID}/${language}`, {
      body: newObj
    });
    return await response.json();
  }
  async add(parentID, options, language = this.client.language) {
    if (!options.name)
      throw Error("Name not specified for new media category");
    const response = await this.client.call("POST", `${MediaCategoryEndpoint}/${language}`, {
      body: {
        description: "",
        archive: false,
        status: 0,
        show: false,
        eForm: false,
        "output-uri": "",
        parent: parentID,
        name: options.name,
        workflow: "-2",
        ...options
      }
    });
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/MediaType.js
var MediaTypeEndpoint = "mediaType";
var MediaType = class {
  clinet;
  constructor(client) {
    this.clinet = client;
  }
  async list() {
    const response = await this.clinet.call("GET", MediaTypeEndpoint, null);
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/List.js
var ListEndpoint = "list";
var List = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async get(listId, language = this.client.language) {
    const response = await this.client.call("GET", `${ListEndpoint}/${listId}/${language}`, null);
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/Profile.js
var ProfileEndpoint = "profile";
var Profile = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async get() {
    const response = await this.client.call("GET", ProfileEndpoint, null);
    return await response.json();
  }
  async update(body) {
    const currentProfile = await this.get();
    if (!currentProfile)
      throw Error("Failed to get client profile");
    const response = await this.client.call("POST", ProfileEndpoint, {
      body: Object.assign(currentProfile, body)
    });
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/Upload.js
var import_node_fs = require("node:fs");
var path3 = __toESM(require("path"), 1);
var { readFile: readFile2 } = import_node_fs.promises;
var UploadEndpoint = "upload";
var Upload = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async list() {
    const response = await this.client.call("GET", UploadEndpoint, null);
    return await response.json();
  }
  async add({ file, filename, elementID }) {
    const filePath = path3.resolve(file);
    if (!filename)
      filename = path3.basename(filePath);
    const blob = new Blob([await readFile2(filePath)]);
    const data = { filename, file: blob, elementID };
    const formData = new FormData();
    for (let key in data) {
      key == "file" ? formData.append(key, data[key], data.filename) : formData.append(key, data[key]);
    }
    const response = await this.client.call("POST", UploadEndpoint, { body: formData });
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/ServerSideLink.js
var ServerSideLinkEndpoint = "ssl";
var ServerSideLink = class {
  client;
  util;
  linkId;
  sslRegex;
  constructor(client) {
    this.client = client;
    this.linkId = 14;
    this.sslRegex = /sslink_id="(\d+)"/;
    this.util = {
      getFromSection: async (sectionId, language = this.client.language) => {
        const { hierarchy, content } = this.client;
        const serverSideLinks = [];
        const contentIds = (await hierarchy.getContents(sectionId)).contents.map((content2) => content2.id);
        await Promise.all(contentIds.map(async (contentId) => {
          const { types, elements, id } = await content.get(contentId, sectionId, language);
          if (!types.some((entry) => entry.id == this.linkId))
            return;
          const keys = Object.keys(elements).filter((name2) => name2.split(":").pop() == this.linkId.toString());
          const maxId = Math.max(...keys.map((key) => elements[key].match(this.sslRegex)?.[1]).filter((entry) => entry != null).map(Number));
          if (!maxId)
            return;
          for (let i2 = 1; i2 <= maxId; i2++) {
            const link = await this.get(i2, sectionId, parseInt(id));
            if (link.id)
              serverSideLinks.push(link);
          }
        }));
        return serverSideLinks;
      }
    };
  }
  async set(options) {
    const destinationSection = await this.client.hierarchy.get(options.toSection, options.language);
    if (!destinationSection)
      throw Error(`${options.toSection} doesn't exist!`);
    if (!options.path)
      options.path = destinationSection.path;
    if (!options.toContent)
      options.toContent = 0;
    const response = await (await this.client.call("PUT", ServerSideLinkEndpoint, { body: options })).json();
    return response;
  }
  async delete(options) {
    const response = await this.client.call("DELETE", ServerSideLinkEndpoint, { body: options });
    return await response.text();
  }
  async modify(linkId, options) {
    const response = await this.client.call("PUT", `${ServerSideLinkEndpoint}/${linkId}`, { body: options });
    return await response.json();
  }
  async get(linkId, sectionId, contentId, language = this.client.language) {
    const response = await this.client.call("GET", `${ServerSideLinkEndpoint}/${linkId}/${language}/${sectionId}/${contentId}`, null);
    try {
      return await response.json();
    } catch (e) {
      return {};
    }
  }
  async getSelectedContentsLinks(ids, language = this.client.language) {
    const response = await this.client.call("POST", `${ServerSideLinkEndpoint}/${language}`, { body: ids });
    return await response.json();
  }
  async getLinks(sectionId, contentId, language = this.client.language) {
    const response = await this.client.call("GET", `${ServerSideLinkEndpoint}/${language}/${sectionId}/${contentId}`, null);
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/Version.js
var VersionEndpoint = "version";
var Version = class {
  client;
  constructor(client) {
    this.client = client;
  }
  async get(contentId, language = this.client.language) {
    const response = await this.client.call("GET", `${VersionEndpoint}/${contentId}/${language}`, null);
    return await response.json();
  }
};

// ../../../../t4apiwrapper/t4.ts/esm/lib/Client.js
var Client = class {
  url;
  token;
  content;
  contentType;
  download;
  formBuilder;
  hierarchy;
  media;
  mediaCategory;
  mediaType;
  language;
  list;
  profile;
  serverSideLink;
  upload;
  version;
  constructor(url, token, language = "en") {
    this.url = url;
    this.token = token;
    this.language = language;
    this.content = new Content(this);
    this.contentType = new ContentType(this);
    this.download = new Download(this);
    this.formBuilder = new FormBuilder(this);
    this.hierarchy = new Hierarchy(this);
    this.media = new Media(this);
    this.mediaCategory = new MediaCategory(this);
    this.mediaType = new MediaType(this);
    this.list = new List(this);
    this.profile = new Profile(this);
    this.serverSideLink = new ServerSideLink(this);
    this.upload = new Upload(this);
    this.version = new Version(this);
  }
  async call(method, endpoint, options) {
    if (!this.token)
      throw Error("Token not specified");
    try {
      let headers = {
        "authorization": `Bearer ${this.token}`,
        "accept": "application/json, text/javascript, */*; q=0.01",
        "accept-language": "en-US,en;q=0.9"
      };
      if (options?.body && (typeof options.body == "object" && !(options.body instanceof FormData) || Array.isArray(options.body))) {
        options.body = JSON.stringify(options.body);
        headers["content-type"] = "application/json";
      }
      headers = options?.headers ? Object.assign(options.headers, headers) : headers;
      const request = await fetch(`${this.url}/${endpoint}`, {
        ...options,
        headers,
        method
      });
      return request;
    } catch (error) {
      throw Error(`Request failed due to:
${error.message}
${error.cause}`);
    }
  }
  async isAuthorized() {
    return (await this.profile.get()).username !== void 0;
  }
};

// index.mjs
var import_path = require("path");
var import_promises2 = require("fs/promises");
import_prompt.default.start();
(async () => {
  while (true) {
    await realMain();
    await closeQuestion();
  }
})();
async function realMain() {
  const defaultDir = "./images";
  const { token, altToken } = await getConfig();
  const { media } = await getT4Client(token);
  const isAltAuth = await checkAltTextAIAuth(altToken);
  if (!isAltAuth || !media) {
    console.log("Failed to login. delete config.json to start over.");
    await closeQuestion();
  }
  if (!await exists(defaultDir)) {
    await (0, import_promises2.mkdir)((0, import_path.resolve)(defaultDir));
    await populateImages();
  }
  let fileNames = await (0, import_promises2.readdir)(defaultDir);
  if (fileNames.length == 0) {
    while (!fileNames.length) {
      await populateImages();
      fileNames = await (0, import_promises2.readdir)(defaultDir);
    }
  }
  console.log(`The following images will be uploaded to AltText.ai:
${fileNames.join("\n")}
`);
  const filePaths = await Promise.all((await (0, import_promises2.readdir)(defaultDir)).map(async (fileName) => await handleImage(fileName)));
  const { categoryID } = await import_prompt.default.get({ properties: { categoryID: { required: true, description: "Enter the media category ID (not URL) you'd like to upload these images to" } } });
  console.log(`Starting...`);
  const batcherResult = await batcher(filePaths, 3, 1e3, uploadToAltText);
  for (let filePos in filePaths) {
    const file = filePaths[filePos], altTextAiObj = batcherResult[filePos];
    try {
      const mediaID = await media.add({
        file: file.fullPath,
        description: altTextAiObj["alt_text"],
        categoryID,
        type: 1,
        name: file.fileName,
        language: "en"
      });
      if (typeof mediaID == "object" && mediaID !== null)
        throw Error("User does not have permission.");
      console.log(`${mediaID} - Uploaded ${file.fileName}`);
    } catch (e) {
      console.log(`Failed to upload ${file.fileName}
`, e);
    }
  }
  console.log("Finished. Closing...");
  async function populateImages() {
    return await import_prompt.default.get({
      properties: {
        placed: {
          required: true,
          description: `Place images you want to upload into the images folder. Type "done" once you're finished`
        }
      }
    });
  }
  async function handleImage(fileName) {
    const fullPath = (0, import_path.resolve)(`${defaultDir}/${fileName}`);
    const image2 = await import_jimp.default.read(fullPath);
    await image2.resize(200, import_jimp.default.AUTO);
    const buffer64 = await image2.getBase64Async(image2.getMIME());
    return { buffer64, fileName, fullPath };
  }
  async function checkAltTextAIAuth() {
    const response = await fetch("https://alttext.ai/api/v1/account", {
      method: "GET",
      headers: {
        "X-API-Key": altToken
      }
    });
    try {
      const responseJson = await response.json();
      if (responseJson.name == void 0)
        return false;
      console.log(`Logged in to AltText.ai as ${responseJson.name}`);
      return true;
    } catch (e) {
      console.log(response.statusText, "\nFailed to login to AltText.ai\nClosing...");
      return false;
    }
  }
  async function uploadToAltText({ buffer64, fileName }) {
    console.log(`Getting alt text for ${fileName}...`);
    const response = await fetch("https://alttext.ai/api/v1/images", {
      method: "POST",
      headers: {
        "X-API-Key": altToken,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        image: {
          raw: buffer64
        }
      })
    });
    try {
      return await response.json();
    } catch (e) {
      console.log(response.statusText, `
Failed to upload ${fileName}`);
    }
  }
  async function getT4Client(token2) {
    const client = new Client("https://cms.seattleu.edu/terminalfour/rs", token2);
    const user = await client.profile.get();
    if (user.firstName == void 0)
      return { media: null };
    console.clear();
    console.log(`Hello, ${user.firstName}! You've successfully logged into T4!`);
    return client;
  }
  async function getConfig() {
    if (!await exists("./config.json"))
      return await newConfig();
    const { token: token2, altToken: altToken2 } = JSON.parse(await (0, import_promises2.readFile)("./config.json"));
    if (!token2 || !altToken2)
      return await newConfig();
    return { token: token2, altToken: altToken2 };
  }
  async function newConfig() {
    console.log("Config file not found or missing keys. Please follow the prompts below.");
    const { token: token2, altToken: altToken2 } = await import_prompt.default.get({
      properties: {
        token: {
          required: true,
          description: "Enter TerminalFour API key"
        },
        altToken: {
          required: true,
          description: "Enter AltText.ai API key"
        }
      }
    });
    try {
      await (0, import_promises2.writeFile)("./config.json", JSON.stringify({ token: token2, altToken: altToken2 }, null, 2));
    } catch (e) {
      console.log(`Failed to write keys to config.json due to:

${e.stack}`);
      console.log("Keys will only be kept during this session...");
    }
    return { token: token2, altToken: altToken2 };
  }
  async function exists(path4) {
    try {
      await (0, import_promises2.stat)((0, import_path.resolve)(path4));
      return true;
    } catch (e) {
      return false;
    }
  }
}
async function closeQuestion() {
  const { closeID } = await import_prompt.default.get({ properties: {
    closeID: {
      required: true,
      description: "If you're finished, type 1. If not, type 0"
    }
  } });
  if (parseInt(closeID))
    return process.close(1);
  return null;
}
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

timm/lib/timm.js:
  (*!
   * Timm
   *
   * Immutability helpers with fast reads and acceptable writes.
   *
   * @copyright Guillermo Grau Panea 2016
   * @license MIT
   *)

image-q/dist/cjs/image-q.cjs:
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cie94.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ciede2000.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cmetric.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * common.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * constants.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ditherErrorDiffusionArray.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * euclidean.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * helper.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * hueStatistics.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * iq.ts - Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * manhattanNeuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * nearestColor.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * palette.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pngQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * point.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pointContainer.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2hsl.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ssim.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * wuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * MIT License
   *
   * Copyright 2015-2018 Igor Bezkrovnyi
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * riemersma.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * colorHistogram.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * neuquant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgbquant.ts - part of Image Quantization Library
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
